

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6.6.6. Deriving any other class &mdash; Glasgow Haskell Compiler 9.2.5 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.5 User&#39;s Guide"
          href="../_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6.6.7. Deriving strategies" href="deriving_strategies.html" />
    <link rel="prev" title="6.6.5. Generalised derived instances for newtypes" href="newtype_deriving.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="../runghc.html">4. Using runghc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">5. Using GHC</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../exts.html">6. Language extensions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">6.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="syntax.html">6.2. Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="import_export.html">6.3. Import and export</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">6.4. Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="records.html">6.5. Records</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="deriving.html">6.6. Deriving mechanism</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="empty_data_deriving.html">6.6.1. Deriving instances for empty data types</a></li>
<li class="toctree-l3"><a class="reference internal" href="deriving_inferred.html">6.6.2. Inferred context for deriving clauses</a></li>
<li class="toctree-l3"><a class="reference internal" href="standalone_deriving.html">6.6.3. Stand-alone deriving declarations</a></li>
<li class="toctree-l3"><a class="reference internal" href="deriving_extra.html">6.6.4. Deriving instances of extra classes (<code class="docutils literal notranslate"><span class="pre">Data</span></code>, etc.)</a></li>
<li class="toctree-l3"><a class="reference internal" href="newtype_deriving.html">6.6.5. Generalised derived instances for newtypes</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">6.6.6. Deriving any other class</a></li>
<li class="toctree-l3"><a class="reference internal" href="deriving_strategies.html">6.6.7. Deriving strategies</a></li>
<li class="toctree-l3"><a class="reference internal" href="deriving_via.html">6.6.8. Deriving via</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="patterns.html">6.7. Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="typeclasses.html">6.8. Class and instances declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="literals.html">6.9. Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="constraints.html">6.10. Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="type_signatures.html">6.11. Type signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="bindings.html">6.12. Bindings and generalisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="template_haskell.html">6.13. Template Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="strict.html">6.14. Bang patterns and Strict Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel.html">6.15. Parallel and Concurrent</a></li>
<li class="toctree-l2"><a class="reference internal" href="primitives.html">6.16. Unboxed types and primitive operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffi.html">6.17. Foreign function interface (FFI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="safe_haskell.html">6.18. Safe Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc.html">6.19. Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="pragmas.html">6.20. Pragmas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../exts.html"><span class="section-number">6. </span>Language extensions</a> &raquo;</li>
        
          <li><a href="deriving.html"><span class="section-number">6.6. </span>Deriving mechanism</a> &raquo;</li>
        
      <li><span class="section-number">6.6.6. </span>Deriving any other class</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/exts/derive_any_class.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="deriving-any-other-class">
<span id="derive-any-class"></span><h1><span class="section-number">6.6.6. </span>Deriving any other class<a class="headerlink" href="#deriving-any-other-class" title="Permalink to this heading">¶</a></h1>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-DeriveAnyClass">
<span id="ghc-flag--XDeriveAnyClass"></span><span id="extension-NoDeriveAnyClass"></span><span class="sig-name descname"><span class="pre">DeriveAnyClass</span></span><a class="headerlink" href="#extension-DeriveAnyClass" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>7.10.1</p>
</dd>
</dl>
<p>Allow use of any typeclass in <code class="docutils literal notranslate"><span class="pre">deriving</span></code> clauses.</p>
</dd></dl>

<p>With <a class="reference internal" href="#extension-DeriveAnyClass"><code class="xref std std-extension docutils literal notranslate"><span class="pre">DeriveAnyClass</span></code></a> you can derive any other class. The compiler
will simply generate an instance declaration with no explicitly-defined
methods.
This is
mostly useful in classes whose <a class="reference external" href="#minimal-pragma">minimal set</a> is
empty, and especially when writing
<a class="reference external" href="#generic-programming">generic functions</a>.</p>
<p>As an example, consider a simple pretty-printer class <code class="docutils literal notranslate"><span class="pre">SPretty</span></code>, which outputs
pretty strings:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE DefaultSignatures, DeriveAnyClass #-}</span><span class="w"></span>

<span class="kr">class</span><span class="w"> </span><span class="kt">SPretty</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">sPpr</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="w">  </span><span class="kr">default</span><span class="w"> </span><span class="n">sPpr</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Show</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="w">  </span><span class="n">sPpr</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">show</span><span class="w"></span>
</pre></div>
</div>
<p>If a user does not provide a manual implementation for <code class="docutils literal notranslate"><span class="pre">sPpr</span></code>, then it will
default to <code class="docutils literal notranslate"><span class="pre">show</span></code>. Now we can leverage the <a class="reference internal" href="#extension-DeriveAnyClass"><code class="xref std std-extension docutils literal notranslate"><span class="pre">DeriveAnyClass</span></code></a> extension to
easily implement a <code class="docutils literal notranslate"><span class="pre">SPretty</span></code> instance for a new data type:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Show</span><span class="p">,</span><span class="w"> </span><span class="kt">SPretty</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>The above code is equivalent to:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="kr">deriving</span><span class="w"> </span><span class="kt">Show</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">SPretty</span><span class="w"> </span><span class="kt">Foo</span><span class="w"></span>
</pre></div>
</div>
<p>That is, an <code class="docutils literal notranslate"><span class="pre">SPretty</span> <span class="pre">Foo</span></code> instance will be created with empty implementations
for all methods. Since we are using <a class="reference internal" href="default_signatures.html#extension-DefaultSignatures"><code class="xref std std-extension docutils literal notranslate"><span class="pre">DefaultSignatures</span></code></a> in this example, a
default implementation of <code class="docutils literal notranslate"><span class="pre">sPpr</span></code> is filled in automatically.</p>
<p>Note the following details</p>
<ul>
<li><p>In case you try to derive some
class on a newtype, and <a class="reference internal" href="newtype_deriving.html#extension-GeneralizedNewtypeDeriving"><code class="xref std std-extension docutils literal notranslate"><span class="pre">GeneralizedNewtypeDeriving</span></code></a> is also on,
<a class="reference internal" href="#extension-DeriveAnyClass"><code class="xref std std-extension docutils literal notranslate"><span class="pre">DeriveAnyClass</span></code></a> takes precedence.</p></li>
<li><p>The instance context is determined by the type signatures of the derived
class’s methods. For instance, if the class is:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">bar</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="w">  </span><span class="kr">default</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Show</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="w">  </span><span class="n">bar</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">show</span><span class="w"></span>

<span class="w">  </span><span class="n">baz</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="w">  </span><span class="kr">default</span><span class="w"> </span><span class="n">baz</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="w">  </span><span class="n">baz</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">compare</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">EQ</span><span class="w"></span>
</pre></div>
</div>
<p>And you attempt to derive it using <a class="reference internal" href="#extension-DeriveAnyClass"><code class="xref std std-extension docutils literal notranslate"><span class="pre">DeriveAnyClass</span></code></a>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">Eq</span><span class="w">   </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Eq</span><span class="w">   </span><span class="p">(</span><span class="kt">Option</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">Ord</span><span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Ord</span><span class="w">  </span><span class="p">(</span><span class="kt">Option</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="kr">instance</span><span class="w"> </span><span class="kt">Show</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Show</span><span class="w"> </span><span class="p">(</span><span class="kt">Option</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Option</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">None</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Some</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">deriving</span><span class="w"> </span><span class="kt">Foo</span><span class="w"></span>
</pre></div>
</div>
<p>Then the derived <code class="docutils literal notranslate"><span class="pre">Foo</span></code> instance will be:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="p">(</span><span class="kt">Show</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="p">(</span><span class="kt">Option</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Since the default type signatures for <code class="docutils literal notranslate"><span class="pre">bar</span></code> and <code class="docutils literal notranslate"><span class="pre">baz</span></code> require <code class="docutils literal notranslate"><span class="pre">Show</span> <span class="pre">a</span></code>
and <code class="docutils literal notranslate"><span class="pre">Ord</span> <span class="pre">a</span></code> constraints, respectively.</p>
<p>Constraints on the non-default type signatures can play a role in inferring
the instance context as well. For example, if you have this class:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">HigherEq</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="o">==#</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="w">  </span><span class="kr">default</span><span class="w"> </span><span class="p">(</span><span class="o">==#</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">==#</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>And you tried to derive an instance for it:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="p">(</span><span class="kt">Option</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Option</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">None</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Some</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">deriving</span><span class="w"> </span><span class="kt">HigherEq</span><span class="w"></span>
</pre></div>
</div>
<p>Then it will fail with an error to the effect of:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">No</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="n">for</span><span class="w"> </span><span class="p">(</span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">arising</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">&#39;deriving&#39;</span><span class="w"> </span><span class="n">clause</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">data</span><span class="w"> </span><span class="kr">type</span><span class="w"> </span><span class="n">declaration</span><span class="w"></span>
</pre></div>
</div>
<p>That is because we require an <code class="docutils literal notranslate"><span class="pre">Eq</span> <span class="pre">(Option</span> <span class="pre">a)</span></code> instance from the default
type signature for <code class="docutils literal notranslate"><span class="pre">(==#)</span></code>, which in turn requires an <code class="docutils literal notranslate"><span class="pre">Eq</span> <span class="pre">a</span></code> instance,
which we don’t have in scope. But if you tweak the definition of
<code class="docutils literal notranslate"><span class="pre">HigherEq</span></code> slightly:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">HigherEq</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="o">==#</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="w">  </span><span class="kr">default</span><span class="w"> </span><span class="p">(</span><span class="o">==#</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">==#</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Then it becomes possible to derive a <code class="docutils literal notranslate"><span class="pre">HigherEq</span> <span class="pre">Option</span></code> instance. Note that
the only difference is that now the non-default type signature for <code class="docutils literal notranslate"><span class="pre">(==#)</span></code>
brings in an <code class="docutils literal notranslate"><span class="pre">Eq</span> <span class="pre">a</span></code> constraint. Constraints from non-default type
signatures never appear in the derived instance context itself, but they can
be used to discharge obligations that are demanded by the default type
signatures. In the example above, the default type signature demanded an
<code class="docutils literal notranslate"><span class="pre">Eq</span> <span class="pre">a</span></code> instance, and the non-default signature was able to satisfy that
request, so the derived instance is simply:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">HigherEq</span><span class="w"> </span><span class="kt">Option</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p><a class="reference internal" href="#extension-DeriveAnyClass"><code class="xref std std-extension docutils literal notranslate"><span class="pre">DeriveAnyClass</span></code></a> can be used with partially applied classes,
such as</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MKT</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">deriving</span><span class="p">(</span><span class="w"> </span><span class="kt">D</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>which generates</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">D</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">D</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="p">(</span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p><a class="reference internal" href="#extension-DeriveAnyClass"><code class="xref std std-extension docutils literal notranslate"><span class="pre">DeriveAnyClass</span></code></a> can be used to fill in default instances for
associated type families:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE DeriveAnyClass, TypeFamilies #-}</span><span class="w"></span>

<span class="kr">class</span><span class="w"> </span><span class="kt">Sizable</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">Size</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">Size</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Bar</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Bar</span><span class="w"> </span><span class="kr">deriving</span><span class="w"> </span><span class="kt">Sizable</span><span class="w"></span>

<span class="nf">doubleBarSize</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Size</span><span class="w"> </span><span class="kt">Bar</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Size</span><span class="w"> </span><span class="kt">Bar</span><span class="w"></span>
<span class="nf">doubleBarSize</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">deriving(</span> <span class="pre">Sizable</span> <span class="pre">)</span></code> is equivalent to saying</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">Sizeable</span><span class="w"> </span><span class="kt">Bar</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
</pre></div>
</div>
<p>and then the normal rules for filling in associated types from the
default will apply, making <code class="docutils literal notranslate"><span class="pre">Size</span> <span class="pre">Bar</span></code> equal to <code class="docutils literal notranslate"><span class="pre">Int</span></code>.</p>
</li>
</ul>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="deriving_strategies.html" class="btn btn-neutral float-right" title="6.6.7. Deriving strategies" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="newtype_deriving.html" class="btn btn-neutral float-left" title="6.6.5. Generalised derived instances for newtypes" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>