

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>13. Running GHC on Win32 systems &mdash; Glasgow Haskell Compiler 9.2.5 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.5 User&#39;s Guide"
          href="_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="14. Known bugs and infelicities" href="bugs.html" />
    <link rel="prev" title="12. Other Haskell utility programs" href="utils.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="runghc.html">4. Using runghc</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">5. Using GHC</a></li>
<li class="toctree-l1"><a class="reference internal" href="exts.html">6. Language extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">13. Running GHC on Win32 systems</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#starting-ghc-on-windows-platforms">13.1. Starting GHC on Windows platforms</a></li>
<li class="toctree-l2"><a class="reference internal" href="#running-ghci-on-windows">13.2. Running GHCi on Windows</a></li>
<li class="toctree-l2"><a class="reference internal" href="#interacting-with-the-terminal">13.3. Interacting with the terminal</a></li>
<li class="toctree-l2"><a class="reference internal" href="#differences-in-library-behaviour">13.4. Differences in library behaviour</a></li>
<li class="toctree-l2"><a class="reference internal" href="#file-paths-under-windows">13.5. File paths under Windows</a></li>
<li class="toctree-l2"><a class="reference internal" href="#using-ghc-and-other-ghc-compiled-executables-with-cygwin">13.6. Using GHC (and other GHC-compiled executables) with Cygwin</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#background">13.6.1. Background</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-problem">13.6.2. The problem</a></li>
<li class="toctree-l3"><a class="reference internal" href="#things-to-do">13.6.3. Things to do</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#building-and-using-win32-dlls">13.7. Building and using Win32 DLLs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#creating-a-dll">13.7.1. Creating a DLL</a></li>
<li class="toctree-l3"><a class="reference internal" href="#making-dlls-to-be-called-from-other-languages">13.7.2. Making DLLs to be called from other languages</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#using-from-vba">13.7.2.1. Using from VBA</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-from-c">13.7.2.2. Using from C++</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li><span class="section-number">13. </span>Running GHC on Win32 systems</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/win32-dlls.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="running-ghc-on-win32-systems">
<span id="win32"></span><h1><span class="section-number">13. </span>Running GHC on Win32 systems<a class="headerlink" href="#running-ghc-on-win32-systems" title="Permalink to this heading">¶</a></h1>
<section id="starting-ghc-on-windows-platforms">
<span id="ghc-windows"></span><h2><span class="section-number">13.1. </span>Starting GHC on Windows platforms<a class="headerlink" href="#starting-ghc-on-windows-platforms" title="Permalink to this heading">¶</a></h2>
<p>The installer that installs GHC on Win32 also sets up the file-suffix
associations for “.hs” and “.lhs” files so that double-clicking them
starts <code class="docutils literal notranslate"><span class="pre">ghci</span></code>.</p>
<p>Be aware of that <code class="docutils literal notranslate"><span class="pre">ghc</span></code> and <code class="docutils literal notranslate"><span class="pre">ghci</span></code> do require filenames containing
spaces to be escaped using quotes:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>c:\ghc\bin\ghci &quot;c:\\Program Files\\Haskell\\Project.hs&quot;
</pre></div>
</div>
<p>If the quotes are left off in the above command, <code class="docutils literal notranslate"><span class="pre">ghci</span></code> will interpret
the filename as two, <code class="docutils literal notranslate"><span class="pre">c:\\\\Program</span></code> and
<code class="docutils literal notranslate"><span class="pre">Files\\\\Haskell\\\\Project.hs</span></code>.</p>
</section>
<section id="running-ghci-on-windows">
<span id="ghci-windows"></span><h2><span class="section-number">13.2. </span>Running GHCi on Windows<a class="headerlink" href="#running-ghci-on-windows" title="Permalink to this heading">¶</a></h2>
<p>We recommend running GHCi in a standard Windows console: select the
<code class="docutils literal notranslate"><span class="pre">GHCi</span></code> option from the start menu item added by the GHC installer, or
use <code class="docutils literal notranslate"><span class="pre">Start-&gt;Run-&gt;cmd</span></code> to get a Windows console and invoke <code class="docutils literal notranslate"><span class="pre">ghci</span></code>
from there (as long as it’s in your <code class="docutils literal notranslate"><span class="pre">PATH</span></code>).</p>
<p>If you run GHCi in a Cygwin or MSYS shell, then the Control-C behaviour
is adversely affected. In one of these environments you should use the
<code class="docutils literal notranslate"><span class="pre">ghcii.sh</span></code> script to start GHCi, otherwise when you hit Control-C
you’ll be returned to the shell prompt but the GHCi process will still
be running. However, even using the <code class="docutils literal notranslate"><span class="pre">ghcii.sh</span></code> script, if you hit
Control-C then the GHCi process will be killed immediately, rather than
letting you interrupt a running program inside GHCi as it should. This
problem is caused by the fact that the Cygwin and MSYS shell
environments don’t pass Control-C events to non-Cygwin child processes,
because in order to do that there needs to be a Windows console.</p>
<p>There’s an exception: you can use a Cygwin shell if the <code class="docutils literal notranslate"><span class="pre">CYGWIN</span></code>
environment variable does <em>not</em> contain <code class="docutils literal notranslate"><span class="pre">tty</span></code>. In this mode, the
Cygwin shell behaves like a Windows console shell and console events are
propagated to child processes. Note that the <code class="docutils literal notranslate"><span class="pre">CYGWIN</span></code> environment
variable must be set <em>before</em> starting the Cygwin shell; changing it
afterwards has no effect on the shell.</p>
<p>This problem doesn’t just affect GHCi, it affects any GHC-compiled
program that wants to catch console events. See the
<a class="reference external" href="./../libraries/base-4.16.4.0/GHC-ConsoleHandler.html">GHC.ConsoleHandler</a> module.</p>
</section>
<section id="interacting-with-the-terminal">
<span id="terminal-interaction"></span><h2><span class="section-number">13.3. </span>Interacting with the terminal<a class="headerlink" href="#interacting-with-the-terminal" title="Permalink to this heading">¶</a></h2>
<p>By default GHC builds applications that open a console window when they
start. If you want to build a GUI-only application, with no console
window, use the flag <code class="docutils literal notranslate"><span class="pre">-optl-mwindows</span></code> in the link step.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Windows GUI-only programs have no stdin, stdout or stderr so
using the ordinary Haskell input/output functions will cause your
program to fail with an IO exception, such as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Fail: &lt;stdout&gt;: hPutChar: failed (Bad file descriptor)
</pre></div>
</div>
<p>However using Debug.Trace.trace is alright because it uses Windows
debugging output support rather than <code class="docutils literal notranslate"><span class="pre">stderr</span></code>.</p>
</div>
<p>For some reason, Mingw ships with the <code class="docutils literal notranslate"><span class="pre">readline</span></code> library, but not with
the <code class="docutils literal notranslate"><span class="pre">readline</span></code> headers. As a result, GHC (like Hugs) does not use
<code class="docutils literal notranslate"><span class="pre">readline</span></code> for interactive input on Windows. You can get a close
simulation by using an emacs shell buffer!</p>
</section>
<section id="differences-in-library-behaviour">
<span id="library-differences"></span><h2><span class="section-number">13.4. </span>Differences in library behaviour<a class="headerlink" href="#differences-in-library-behaviour" title="Permalink to this heading">¶</a></h2>
<p>Some of the standard Haskell libraries behave slightly differently on
Windows.</p>
<ul class="simple">
<li><p>On Windows, the <code class="docutils literal notranslate"><span class="pre">^Z</span></code> character is interpreted as an end-of-file
character, so if you read a file containing this character the file
will appear to end just before it. To avoid this, use
<code class="docutils literal notranslate"><span class="pre">IOExts.openFileEx</span></code> to open a file in binary (untranslated) mode or
change an already opened file handle into binary mode using
<code class="docutils literal notranslate"><span class="pre">IOExts.hSetBinaryMode</span></code>. The <code class="docutils literal notranslate"><span class="pre">IOExts</span></code> module is part of the
<code class="docutils literal notranslate"><span class="pre">lang</span></code> package.</p></li>
</ul>
</section>
<section id="file-paths-under-windows">
<span id="windows-file-paths"></span><h2><span class="section-number">13.5. </span>File paths under Windows<a class="headerlink" href="#file-paths-under-windows" title="Permalink to this heading">¶</a></h2>
<p>Windows paths are not all the same. The different kinds of paths each have
different meanings. The <code class="docutils literal notranslate"><span class="pre">MAX_PATH</span></code> limitation is not a limitation of the operating
system nor the file system. It is a limitation of the default namespace enforced
by the Win32 API for backwards compatibility.</p>
<p>The NT kernel however allows you ways to opt out of this path preprocessing by
the Win32 APIs. This is done by explicitly using the desired namespace in the
path.</p>
<p>The namespaces are:</p>
<blockquote>
<div><ul class="simple">
<li><p>file namespace: <code class="docutils literal notranslate"><span class="pre">\\?\</span></code></p></li>
<li><p>device namespace: <code class="docutils literal notranslate"><span class="pre">\\.\</span></code></p></li>
<li><p>NT namespace: <code class="docutils literal notranslate"><span class="pre">\</span></code></p></li>
</ul>
</div></blockquote>
<p>Each of these turn off path processing completely by the Win32 API and the paths
are passed untouched to the filesystem.</p>
<p>Paths with a drive letter are <em>legacy</em> paths. The drive letters are actually
meaningless to the kernel. Just like Unix operating systems, drive letters are
just a mount point. You can view your mount points by using the <strong class="command">mountvol</strong>
command.</p>
<p>Since GHC 8.6.1, the Haskell I/O manager automatically promotes paths in the legacy
format to Win32 file namespace. By default the I/O manager will do two things to
your paths:</p>
<blockquote>
<div><ul class="simple">
<li><p>replace <code class="docutils literal notranslate"><span class="pre">\</span></code> with <code class="docutils literal notranslate"><span class="pre">\\</span></code></p></li>
<li><p>expand relative paths to absolute paths</p></li>
</ul>
</div></blockquote>
<p>If you want to opt out of all preprocessing just explicitly use namespaces in
your paths. Due to this change, if you need to open raw devices (e.g. COM ports)
you need to use the device namespace explicitly. (e.g. <code class="docutils literal notranslate"><span class="pre">\\.\COM1</span></code>). GHC and
Haskell programs in general no longer support opening devices in the legacy
format.</p>
<p>See the
<a class="reference external" href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247.aspx">Windows documentation</a>
for more details.</p>
</section>
<section id="using-ghc-and-other-ghc-compiled-executables-with-cygwin">
<span id="ghci-cygwin"></span><h2><span class="section-number">13.6. </span>Using GHC (and other GHC-compiled executables) with Cygwin<a class="headerlink" href="#using-ghc-and-other-ghc-compiled-executables-with-cygwin" title="Permalink to this heading">¶</a></h2>
<section id="background">
<h3><span class="section-number">13.6.1. </span>Background<a class="headerlink" href="#background" title="Permalink to this heading">¶</a></h3>
<p>The Cygwin tools aim to provide a Unix-style API on top of the windows
libraries, to facilitate ports of Unix software to windows. To this end,
they introduce a Unix-style directory hierarchy under some root
directory (typically <code class="docutils literal notranslate"><span class="pre">/</span></code> is <code class="docutils literal notranslate"><span class="pre">C:\cygwin\</span></code>). Moreover, everything
built against the Cygwin API (including the Cygwin tools and programs
compiled with Cygwin’s GHC) will see <code class="docutils literal notranslate"><span class="pre">/</span></code> as the root of their file system,
happily pretending to work in a typical unix environment, and finding
things like <code class="docutils literal notranslate"><span class="pre">/bin</span></code> and <code class="docutils literal notranslate"><span class="pre">/usr/include</span></code> without ever explicitly
bothering with their actual location on the windows system (probably
<code class="docutils literal notranslate"><span class="pre">C:\cygwin\bin</span></code> and <code class="docutils literal notranslate"><span class="pre">C:\cygwin\usr\include</span></code>).</p>
</section>
<section id="the-problem">
<h3><span class="section-number">13.6.2. </span>The problem<a class="headerlink" href="#the-problem" title="Permalink to this heading">¶</a></h3>
<p>GHC, by default, no longer depends on cygwin, but is a native Windows
program. It is built using mingw, and it uses mingw’s GHC while
compiling your Haskell sources (even if you call it from cygwin’s bash),
but what matters here is that - just like any other normal windows
program - neither GHC nor the executables it produces are aware of
Cygwin’s pretended unix hierarchy. GHC will happily accept either <code class="docutils literal notranslate"><span class="pre">/</span></code> or
<code class="docutils literal notranslate"><span class="pre">\\</span></code> as path separators, but it won’t know where to find <code class="docutils literal notranslate"><span class="pre">/home/joe/Main.hs</span></code>
or <code class="docutils literal notranslate"><span class="pre">/bin/bash</span></code> or the like. This causes all kinds of fun when GHC is used from
within Cygwin’s bash, or in make-sessions running under Cygwin.</p>
</section>
<section id="things-to-do">
<h3><span class="section-number">13.6.3. </span>Things to do<a class="headerlink" href="#things-to-do" title="Permalink to this heading">¶</a></h3>
<ul>
<li><p>Don’t use absolute paths in <code class="docutils literal notranslate"><span class="pre">make</span></code>, <code class="docutils literal notranslate"><span class="pre">configure</span></code> &amp; co if there is any
chance that those might be passed to GHC (or to GHC-compiled
programs). Relative paths are fine because cygwin tools are happy
with them and GHC accepts <code class="docutils literal notranslate"><span class="pre">/</span></code> as path-separator. And relative paths
don’t depend on where Cygwin’s root directory is located, or on which
partition or network drive your source tree happens to reside, as
long as you <code class="docutils literal notranslate"><span class="pre">cd</span></code> there first.</p></li>
<li><p>If you have to use absolute paths (beware of the innocent-looking
<code class="docutils literal notranslate"><span class="pre">ROOT=$(pwd)</span></code> in makefile hierarchies or configure scripts), Cygwin
provides a tool called <code class="docutils literal notranslate"><span class="pre">cygpath</span></code> that can convert Cygwin’s
Unix-style paths to their actual Windows-style counterparts. Many
Cygwin tools actually accept absolute Windows-style paths (remember,
though, that you either need to escape <code class="docutils literal notranslate"><span class="pre">\\</span></code> or convert <code class="docutils literal notranslate"><span class="pre">\\</span></code> to <code class="docutils literal notranslate"><span class="pre">/</span></code>),
so you should be fine just using those everywhere. If you need to use
tools that do some kind of path-mangling that depends on unix-style
paths (one fun example is trying to interpret <code class="docutils literal notranslate"><span class="pre">:</span></code> as a separator in
path lists), you can still try to convert paths using <code class="docutils literal notranslate"><span class="pre">cygpath</span></code>
just before they are passed to GHC and friends.</p></li>
<li><p>If you don’t have <code class="docutils literal notranslate"><span class="pre">cygpath</span></code>, you probably don’t have cygwin and
hence no problems with it… unless you want to write one build
process for several platforms. Again, relative paths are your friend,
but if you have to use absolute paths, and don’t want to use
different tools on different platforms, you can simply write a short
Haskell program to print the current directory (thanks to George
Russell for this idea): compiled with GHC, this will give you the
view of the file system that GHC depends on (which will differ
depending on whether GHC is compiled with cygwin’s gcc or mingw’s gcc
or on a real Unix system..) - that little program can also deal with
escaping <code class="docutils literal notranslate"><span class="pre">\\</span></code> in paths. Apart from the banner and the startup time,
something like this would also do:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ echo &quot;Directory.getCurrentDirectory &gt;&gt;= putStrLn . init . tail . show &quot; | ghci
</pre></div>
</div>
</li>
</ul>
</section>
</section>
<section id="building-and-using-win32-dlls">
<span id="win32-dlls"></span><h2><span class="section-number">13.7. </span>Building and using Win32 DLLs<a class="headerlink" href="#building-and-using-win32-dlls" title="Permalink to this heading">¶</a></h2>
<p>Dynamic link libraries, Win32 DLLs, Win32 On Win32 platforms, the
compiler is capable of both producing and using dynamic link libraries
(DLLs) containing ghc-compiled code. This section shows you how to make
use of this facility.</p>
<p>There are two distinct ways in which DLLs can be used:</p>
<ul>
<li><p>You can turn each Haskell package into a DLL, so that multiple
Haskell executables using the same packages can share the DLL files.
(As opposed to linking the libraries statically, which in effect
creates a new copy of the RTS and all libraries for each executable
produced.)</p>
<p>That is the same as the dynamic linking on other platforms, and it is
described in <a class="reference internal" href="shared_libs.html#using-shared-libs"><span class="std std-ref">Using shared libraries</span></a>.</p>
</li>
<li><p>You can package up a complete Haskell program as a DLL, to be called
by some external (usually non-Haskell) program. This is usually used
to implement plugins and the like, and is described below.</p></li>
</ul>
<section id="creating-a-dll">
<span id="win32-dlls-create"></span><h3><span class="section-number">13.7.1. </span>Creating a DLL<a class="headerlink" href="#creating-a-dll" title="Permalink to this heading">¶</a></h3>
<p>Creating a Win32 DLL -shared Sealing up your Haskell library inside a
DLL is straightforward; compile up the object files that make up the
library, and then build the DLL by issuing a command of the form:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghc -shared -o foo.dll bar.o baz.o wibble.a -lfooble
</pre></div>
</div>
<p>By feeding the ghc compiler driver the option <code class="docutils literal notranslate"><span class="pre">-shared</span></code>, it will build
a DLL rather than produce an executable. The DLL will consist of all the
object files and archives given on the command line.</p>
<p>A couple of things to notice:</p>
<ul>
<li><p>By default, the entry points of all the object files will be exported
from the DLL when using <code class="docutils literal notranslate"><span class="pre">-shared</span></code>. Should you want to constrain
this, you can specify the <em>module definition file</em> to use on the
command line as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghc -shared -o .... MyDef.def
</pre></div>
</div>
<p>See Microsoft documentation for details, but a module definition file
simply lists what entry points you want to export. Here’s one that’s
suitable when building a Haskell COM server DLL:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>EXPORTS
 DllCanUnloadNow     = DllCanUnloadNow@0
 DllGetClassObject   = DllGetClassObject@12
 DllRegisterServer   = DllRegisterServer@0
 DllUnregisterServer = DllUnregisterServer@0
</pre></div>
</div>
</li>
<li><p>In addition to creating a DLL, the <code class="docutils literal notranslate"><span class="pre">-shared</span></code> option also creates an
import library. The import library name is derived from the name of
the DLL, as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DLL: HScool.dll  ==&gt; import lib: libHScool.dll.a
</pre></div>
</div>
<p>The naming scheme may look a bit weird, but it has the purpose of
allowing the co-existence of import libraries with ordinary static
libraries (e.g., <code class="docutils literal notranslate"><span class="pre">libHSfoo.a</span></code> and <code class="docutils literal notranslate"><span class="pre">libHSfoo.dll.a</span></code>. Additionally,
when the compiler driver is linking in non-static mode, it will
rewrite occurrence of <code class="docutils literal notranslate"><span class="pre">-lHSfoo</span></code> on the command line to
<code class="docutils literal notranslate"><span class="pre">-lHSfoo.dll</span></code>. By doing this for you, switching from non-static to
static linking is simply a question of adding <code class="docutils literal notranslate"><span class="pre">-static</span></code> to your
command line.</p>
</li>
</ul>
</section>
<section id="making-dlls-to-be-called-from-other-languages">
<span id="win32-dlls-foreign"></span><h3><span class="section-number">13.7.2. </span>Making DLLs to be called from other languages<a class="headerlink" href="#making-dlls-to-be-called-from-other-languages" title="Permalink to this heading">¶</a></h3>
<p>This section describes how to create DLLs to be called from other
languages, such as Visual Basic or C++. This is a special case of
<a class="reference internal" href="exts/ffi.html#ffi-library"><span class="std std-ref">Making a Haskell library that can be called from foreign code</span></a>; we’ll deal with the DLL-specific issues that arise
below. Here’s an example:</p>
<p>Use foreign export declarations to export the Haskell functions you want
to call from the outside. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Adder.hs</span><span class="w"></span>
<span class="cm">{-# LANGUAGE ForeignFunctionInterface #-}</span><span class="w"></span>
<span class="kr">module</span><span class="w"> </span><span class="nn">Adder</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>

<span class="nf">adder</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="kt">Int</span><span class="w">  </span><span class="c1">-- gratuitous use of IO</span><span class="w"></span>
<span class="nf">adder</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="w"></span>

<span class="nf">foreign</span><span class="w"> </span><span class="n">export</span><span class="w"> </span><span class="n">stdcall</span><span class="w"> </span><span class="n">adder</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
</pre></div>
</div>
<p>Add some helper code that starts up and shuts down the Haskell RTS:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// StartEnd.c</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;Rts.h&gt;</span><span class="cp"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">HsStart</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">argv</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;ghcDll&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">};</span><span class="w"> </span><span class="c1">// argv must end with NULL</span>

<span class="w">   </span><span class="c1">// Initialize Haskell runtime</span>
<span class="w">   </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">argv</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">hs_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">args</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">HsEnd</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">hs_exit</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">Adder</span></code> is the name of the root module in the module tree (as
mentioned above, there must be a single root module, and hence a single
module tree in the DLL). Compile everything up:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghc -c Adder.hs
ghc -c StartEnd.c
ghc -shared -o Adder.dll Adder.o Adder_stub.o StartEnd.o
</pre></div>
</div>
<p>Now the file <code class="docutils literal notranslate"><span class="pre">Adder.dll</span></code> can be used from other programming languages.
Before calling any functions in Adder it is necessary to call
<code class="docutils literal notranslate"><span class="pre">HsStart</span></code>, and at the very end call <code class="docutils literal notranslate"><span class="pre">HsEnd</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>It may appear tempting to use <code class="docutils literal notranslate"><span class="pre">DllMain</span></code> to call
<code class="docutils literal notranslate"><span class="pre">hs_init</span></code>/<code class="docutils literal notranslate"><span class="pre">hs_exit</span></code>, but this won’t work (particularly if you
compile with <code class="docutils literal notranslate"><span class="pre">-threaded</span></code>). There are severe restrictions on which
actions can be performed during <code class="docutils literal notranslate"><span class="pre">DllMain</span></code>, and <code class="docutils literal notranslate"><span class="pre">hs_init</span></code> violates
these restrictions, which can lead to your DLL freezing during startup
(see <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/3605">#3605</a>).</p>
</div>
<section id="using-from-vba">
<span id="win32-dlls-vba"></span><h4><span class="section-number">13.7.2.1. </span>Using from VBA<a class="headerlink" href="#using-from-vba" title="Permalink to this heading">¶</a></h4>
<p>An example of using <code class="docutils literal notranslate"><span class="pre">Adder.dll</span></code> from VBA is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Private Declare Function Adder Lib &quot;Adder.dll&quot; Alias &quot;adder@8&quot; _
      (ByVal x As Long, ByVal y As Long) As Long

Private Declare Sub HsStart Lib &quot;Adder.dll&quot; ()
Private Declare Sub HsEnd Lib &quot;Adder.dll&quot; ()

Private Sub Document_Close()
HsEnd
End Sub

Private Sub Document_Open()
HsStart
End Sub

Public Sub Test()
MsgBox &quot;12 + 5 = &quot; &amp; Adder(12, 5)
End Sub
</pre></div>
</div>
<p>This example uses the <code class="docutils literal notranslate"><span class="pre">Document_Open</span></code>/<code class="docutils literal notranslate"><span class="pre">Close</span></code> functions of Microsoft
Word, but provided <code class="docutils literal notranslate"><span class="pre">HsStart</span></code> is called before the first function, and
<code class="docutils literal notranslate"><span class="pre">HsEnd</span></code> after the last, then it will work fine.</p>
</section>
<section id="using-from-c">
<span id="win32-dlls-c"></span><h4><span class="section-number">13.7.2.2. </span>Using from C++<a class="headerlink" href="#using-from-c" title="Permalink to this heading">¶</a></h4>
<p>An example of using <code class="docutils literal notranslate"><span class="pre">Adder.dll</span></code> from C++ is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Tester.cpp</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;HsFFI.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;Adder_stub.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">HsStart</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">HsEnd</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">HsStart</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="c1">// can now safely call functions from the DLL</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;12 + 5 = %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">adder</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span><span class="w">    </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">HsEnd</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>This can be compiled and run with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ghc -o tester Tester.cpp Adder.dll.a
$ tester
12 + 5 = 17
</pre></div>
</div>
</section>
</section>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="bugs.html" class="btn btn-neutral float-right" title="14. Known bugs and infelicities" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="utils.html" class="btn btn-neutral float-left" title="12. Other Haskell utility programs" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>