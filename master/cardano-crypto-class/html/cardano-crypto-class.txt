-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Type classes abstracting over cryptography primitives for Cardano
--   
--   Type classes abstracting over cryptography primitives for Cardano
@package cardano-crypto-class
@version 2.1.0.0

module Cardano.Crypto.Libsodium.Constants
type CRYPTO_SHA256_BYTES = 32
type CRYPTO_SHA512_BYTES = 64
type CRYPTO_BLAKE2B_256_BYTES = 32
type CRYPTO_SHA256_STATE_SIZE = (104)
type CRYPTO_SHA512_STATE_SIZE = (208)
type CRYPTO_BLAKE2B_256_STATE_SIZE = (384)
type CRYPTO_SIGN_ED25519_BYTES = 64
type CRYPTO_SIGN_ED25519_SEEDBYTES = 32
type CRYPTO_SIGN_ED25519_PUBLICKEYBYTES = 32
type CRYPTO_SIGN_ED25519_SECRETKEYBYTES = 64

module Cardano.Crypto.Libsodium.UnsafeC

-- | Unsafe variant of <tt>c_sodium_compare</tt>.
c_sodium_compare_unsafe :: Ptr a -> Ptr a -> CSize -> IO Int

module Cardano.Crypto.SECP256K1.Constants
type SECP256K1_ECDSA_PRIVKEY_BYTES = 32
type SECP256K1_ECDSA_SIGNATURE_BYTES = 64
type SECP256K1_ECDSA_SIGNATURE_BYTES_INTERNAL = 64
type SECP256K1_ECDSA_PUBKEY_BYTES = 33
type SECP256K1_ECDSA_PUBKEY_BYTES_INTERNAL = 64
type SECP256K1_ECDSA_MESSAGE_BYTES = 32
type SECP256K1_SCHNORR_PUBKEY_BYTES = 32
type SECP256K1_SCHNORR_PRIVKEY_BYTES = 32
type SECP256K1_SCHNORR_PUBKEY_BYTES_INTERNAL = (64)
type SECP256K1_SCHNORR_KEYPAIR_BYTES = (96)
type SECP256K1_SCHNORR_SIGNATURE_BYTES = 64

module Cardano.Crypto.Util
class Empty a

-- | A class of types that have a representation in bytes that can be used
--   for signing and verifying.
class SignableRepresentation a
getSignableRepresentation :: SignableRepresentation a => a -> ByteString
getRandomWord64 :: MonadRandom m => m Word64
readBinaryWord64 :: ByteString -> Word64
writeBinaryWord64 :: Word64 -> ByteString
readBinaryNatural :: ByteString -> Natural
writeBinaryNatural :: Int -> Natural -> ByteString
splitsAt :: [Int] -> ByteString -> [ByteString]

-- | Create a <a>Natural</a> out of a <a>ByteString</a>, in big endian.
--   
--   This is fast enough to use in production.
bytesToNatural :: ByteString -> Natural

-- | The inverse of <a>bytesToNatural</a>. Note that this is a naive
--   implementation and only suitable for tests.
naturalToBytes :: Int -> Natural -> ByteString
slice :: Word -> Word -> ByteString -> ByteString

-- | Decode base16 ByteString, while ensuring expected length.
decodeHexByteString :: ByteString -> Int -> Either String ByteString

-- | Decode base16 String, while ensuring expected length. Unlike
--   <a>decodeHexByteString</a> this function expects a '0x' prefix.
decodeHexString :: String -> Int -> Either String ByteString

-- | Decode a <a>String</a> with Hex characters, while ensuring expected
--   length.
decodeHexStringQ :: String -> Int -> Q Exp
instance Cardano.Crypto.Util.SignableRepresentation Data.ByteString.Internal.ByteString
instance Cardano.Crypto.Util.Empty a


-- | Abstract hashing functionality.
module Cardano.Crypto.Hash.Class
class (KnownNat (SizeHash h), Typeable h) => HashAlgorithm h where {
    
    -- | Size of hash digest
    type SizeHash h :: Nat;
}
hashAlgorithmName :: HashAlgorithm h => proxy h -> String
digest :: HashAlgorithm h => proxy h -> ByteString -> ByteString

-- | The size in bytes of the output of <a>digest</a>
sizeHash :: forall h proxy. HashAlgorithm h => proxy h -> Word

-- | A space-efficient representation of a <a>Word8</a> vector, supporting
--   many efficient operations.
--   
--   A <a>ByteString</a> contains 8-bit bytes, or by using the operations
--   from <a>Data.ByteString.Char8</a> it can be interpreted as containing
--   8-bit characters.
data ByteString
data Hash h a
pattern UnsafeHash :: forall h a. HashAlgorithm h => ShortByteString -> Hash h a
data PackedBytes (n :: Nat)
[PackedBytes8] :: {-# UNPACK #-} !Word64 -> PackedBytes 8
[PackedBytes28] :: {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word32 -> PackedBytes 28
[PackedBytes32] :: {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> PackedBytes 32

-- | Hash the given value, using a serialisation function to turn it into
--   bytes.
hashWith :: forall h a. HashAlgorithm h => (a -> ByteString) -> a -> Hash h a

-- | A variation on <a>hashWith</a>, but specially for CBOR encodings.
hashWithSerialiser :: forall h a. HashAlgorithm h => (a -> Encoding) -> a -> Hash h a

-- | Cast the type of the hashed data.
--   
--   The <a>Hash</a> type has a phantom type parameter to indicate what
--   type the hash is of. It is sometimes necessary to fake this and hash a
--   value of one type and use it where as hash of a different type is
--   expected.
castHash :: Hash h a -> Hash h b

-- | The representation of the hash as bytes.
hashToBytes :: Hash h a -> ByteString

-- | Make a hash from it bytes representation.
hashFromBytes :: forall h a. HashAlgorithm h => ByteString -> Maybe (Hash h a)

-- | The representation of the hash as bytes, as a <a>ShortByteString</a>.
hashToBytesShort :: Hash h a -> ShortByteString

-- | Make a hash from it bytes representation, as a <a>ShortByteString</a>.
hashFromBytesShort :: forall h a. HashAlgorithm h => ShortByteString -> Maybe (Hash h a)

-- | Just like <a>hashFromBytesShort</a>, but allows using a region of a
--   <a>ShortByteString</a>.
hashFromOffsetBytesShort :: forall h a. HashAlgorithm h => ShortByteString -> Int -> Maybe (Hash h a)

-- | <i>O(1)</i> - Get the underlying hash representation
hashToPackedBytes :: Hash h a -> PackedBytes (SizeHash h)

-- | <i>O(1)</i> - Construct hash from the underlying representation
hashFromPackedBytes :: PackedBytes (SizeHash h) -> Hash h a

-- | Convert the hash to hex encoding, as <a>ByteString</a>.
hashToBytesAsHex :: Hash h a -> ByteString

-- | Make a hash from hex-encoded <a>ByteString</a> representation.
--   
--   This can fail for the same reason as <a>hashFromBytes</a>, or because
--   the input is invalid hex. The whole byte string must be valid hex, not
--   just a prefix.
hashFromBytesAsHex :: HashAlgorithm h => ByteString -> Maybe (Hash h a)

-- | Convert the hash to hex encoding, as <a>Text</a>.
hashToTextAsHex :: Hash h a -> Text

-- | Make a hash from hex-encoded <a>Text</a> representation.
--   
--   This can fail for the same reason as <a>hashFromBytes</a>, or because
--   the input is invalid hex. The whole byte string must be valid hex, not
--   just a prefix.
hashFromTextAsHex :: HashAlgorithm h => Text -> Maybe (Hash h a)

-- | Convert the hash to hex encoding, as <a>String</a>.
hashToStringAsHex :: Hash h a -> String

-- | Make a hash from hex-encoded <a>String</a> representation.
--   
--   This can fail for the same reason as <a>hashFromBytes</a>, or because
--   the input is invalid hex. The whole byte string must be valid hex, not
--   just a prefix.
hashFromStringAsHex :: HashAlgorithm h => String -> Maybe (Hash h a)

-- | XOR two hashes together
xor :: Hash h a -> Hash h a -> Hash h a

-- | <i>Deprecated: Use hashWith or hashWithSerialiser</i>
hash :: forall h a. (HashAlgorithm h, ToCBOR a) => a -> Hash h a

-- | <i>Deprecated: Use bytesToNatural . hashToBytes</i>
fromHash :: Hash h a -> Natural

-- | <i>Deprecated: Use hashWith</i>
hashRaw :: forall h a. HashAlgorithm h => (a -> ByteString) -> a -> Hash h a

-- | <i>Deprecated: Use hashToBytes</i>
getHash :: Hash h a -> ByteString

-- | <i>Deprecated: Use hashToBytesAsHex</i>
getHashBytesAsHex :: Hash h a -> ByteString
instance Control.DeepSeq.NFData (Cardano.Crypto.Hash.Class.Hash h a)
instance NoThunks.Class.NoThunks (Cardano.Crypto.Hash.Class.Hash h a)
instance GHC.Generics.Generic (Cardano.Crypto.Hash.Class.Hash h a)
instance GHC.Classes.Ord (Cardano.Crypto.Hash.Class.Hash h a)
instance GHC.Classes.Eq (Cardano.Crypto.Hash.Class.Hash h a)
instance Cardano.Crypto.Hash.Class.HashAlgorithm h => Data.String.IsString (Language.Haskell.TH.Syntax.Q (Language.Haskell.TH.Syntax.TExp (Cardano.Crypto.Hash.Class.Hash h a)))
instance Cardano.Crypto.Hash.Class.HashAlgorithm h => Data.String.IsString (Language.Haskell.TH.Syntax.Code Language.Haskell.TH.Syntax.Q (Cardano.Crypto.Hash.Class.Hash h a))
instance GHC.Show.Show (Cardano.Crypto.Hash.Class.Hash h a)
instance Cardano.Crypto.Hash.Class.HashAlgorithm h => GHC.Read.Read (Cardano.Crypto.Hash.Class.Hash h a)
instance Cardano.Crypto.Hash.Class.HashAlgorithm h => Data.String.IsString (Cardano.Crypto.Hash.Class.Hash h a)
instance Cardano.Crypto.Hash.Class.HashAlgorithm h => Data.Aeson.Types.ToJSON.ToJSONKey (Cardano.Crypto.Hash.Class.Hash h a)
instance Cardano.Crypto.Hash.Class.HashAlgorithm h => Data.Aeson.Types.FromJSON.FromJSONKey (Cardano.Crypto.Hash.Class.Hash h a)
instance Cardano.Crypto.Hash.Class.HashAlgorithm h => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Crypto.Hash.Class.Hash h a)
instance Cardano.Crypto.Hash.Class.HashAlgorithm h => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Crypto.Hash.Class.Hash h a)
instance Cardano.HeapWords.HeapWords (Cardano.Crypto.Hash.Class.Hash h a)
instance (Cardano.Crypto.Hash.Class.HashAlgorithm h, Data.Typeable.Internal.Typeable a) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.Hash.Class.Hash h a)
instance (Cardano.Crypto.Hash.Class.HashAlgorithm h, Data.Typeable.Internal.Typeable a) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.Hash.Class.Hash h a)


-- | Seeds for key generation.
module Cardano.Crypto.Seed

-- | A seed contains a finite number of bytes, and is used for seeding
--   cryptographic algorithms including key generation.
--   
--   This is not itself a PRNG, but can be used to seed a PRNG.
data Seed

-- | Construct a <a>Seed</a> deterministically from a number of bytes.
mkSeedFromBytes :: ByteString -> Seed

-- | Extract the full bytes from a seed. Note that this function does not
--   guarantee that the result is sufficiently long for the desired seed
--   size!
getSeedBytes :: Seed -> ByteString

-- | Obtain a <a>Seed</a> by reading <tt>n</tt> bytes of entropy from the
--   operating system.
readSeedFromSystemEntropy :: Word -> IO Seed

-- | Split a seed into two smaller seeds, the first of which is the given
--   number of bytes large, and the second is the remaining. This will fail
--   if not enough bytes are available. This can be chained multiple times
--   provided the seed is big enough to cover each use.
splitSeed :: Word -> Seed -> Maybe (Seed, Seed)

-- | Expand a seed into a pair of seeds using a cryptographic hash function
--   (in the role of a crypto PRNG). The whole input seed is consumed. The
--   output seeds are the size of the hash output.
expandSeed :: HashAlgorithm h => proxy h -> Seed -> (Seed, Seed)

-- | Get a number of bytes from the seed. This will fail if not enough
--   bytes are available. This can be chained multiple times provided the
--   seed is big enough to cover each use.
getBytesFromSeed :: Word -> Seed -> Maybe (ByteString, Seed)

-- | A flavor of <a>getBytesFromSeed</a> that throws
--   <a>SeedBytesExhausted</a> instead of returning <a>Nothing</a>.
getBytesFromSeedT :: Word -> Seed -> (ByteString, Seed)

-- | Run an action in <a>MonadRandom</a> deterministically using a seed as
--   a finite source of randomness. Note that this is not a PRNG, so like
--   with <a>getBytesFromSeed</a> it will fail if more bytes are requested
--   than are available.
--   
--   So this is only really suitable for key generation where there is a
--   known upper bound on the amount of entropy that will be requested.
runMonadRandomWithSeed :: Seed -> (forall m. MonadRandom m => m a) -> a
newtype SeedBytesExhausted
SeedBytesExhausted :: Int -> SeedBytesExhausted
[seedBytesSupplied] :: SeedBytesExhausted -> Int
instance Control.DeepSeq.NFData Cardano.Crypto.Seed.Seed
instance NoThunks.Class.NoThunks Cardano.Crypto.Seed.Seed
instance GHC.Base.Monoid Cardano.Crypto.Seed.Seed
instance GHC.Base.Semigroup Cardano.Crypto.Seed.Seed
instance GHC.Classes.Eq Cardano.Crypto.Seed.Seed
instance GHC.Show.Show Cardano.Crypto.Seed.Seed
instance GHC.Show.Show Cardano.Crypto.Seed.SeedBytesExhausted
instance GHC.Base.Monad Cardano.Crypto.Seed.MonadRandomFromSeed
instance GHC.Base.Applicative Cardano.Crypto.Seed.MonadRandomFromSeed
instance GHC.Base.Functor Cardano.Crypto.Seed.MonadRandomFromSeed
instance Crypto.Random.Types.MonadRandom Cardano.Crypto.Seed.MonadRandomFromSeed
instance GHC.Exception.Type.Exception Cardano.Crypto.Seed.SeedBytesExhausted


-- | Abstract key evolving signatures.
module Cardano.Crypto.KES.Class
class (Typeable v, Show (VerKeyKES v), Eq (VerKeyKES v), Show (SignKeyKES v), Show (SigKES v), Eq (SigKES v), NoThunks (SigKES v), NoThunks (SignKeyKES v), NoThunks (VerKeyKES v), KnownNat (SeedSizeKES v)) => KESAlgorithm v where {
    type SeedSizeKES v :: Nat;
    data VerKeyKES v :: Type;
    data SignKeyKES v :: Type;
    data SigKES v :: Type;
    
    -- | Context required to run the KES algorithm
    --   
    --   Unit by default (no context required)
    type ContextKES v :: Type;
    type Signable v :: Type -> Constraint;
    type ContextKES v = ();
    type Signable v = Empty;
}
algorithmNameKES :: KESAlgorithm v => proxy v -> String
deriveVerKeyKES :: KESAlgorithm v => SignKeyKES v -> VerKeyKES v
hashVerKeyKES :: (KESAlgorithm v, HashAlgorithm h) => VerKeyKES v -> Hash h (VerKeyKES v)
signKES :: (KESAlgorithm v, Signable v a, HasCallStack) => ContextKES v -> Period -> a -> SignKeyKES v -> SigKES v

-- | Full KES verification. This method checks that the signature itself
--   checks out (as per <a>verifySigKES</a>), and also makes sure that it
--   matches the provided VerKey.
verifyKES :: (KESAlgorithm v, Signable v a, HasCallStack) => ContextKES v -> VerKeyKES v -> Period -> a -> SigKES v -> Either String ()

-- | Update the KES signature key to the <i>next</i> period, given the
--   <i>current</i> period.
--   
--   It returns <a>Nothing</a> if the cannot be evolved any further.
--   
--   The precondition (to get a <a>Just</a> result) is that the current KES
--   period of the input key is not the last period. The given period must
--   be the current KES period of the input key (not the next or target).
--   
--   The postcondition is that in case a key is returned, its current KES
--   period is incremented by one compared to before.
--   
--   Note that you must track the current period separately, and to skip to
--   a later period requires repeated use of this function, since it only
--   increments one period at once.
updateKES :: (KESAlgorithm v, HasCallStack) => ContextKES v -> SignKeyKES v -> Period -> Maybe (SignKeyKES v)

-- | Return the total number of KES periods supported by this algorithm.
--   The KES algorithm is assumed to support a fixed maximum number of
--   periods, not a variable number.
--   
--   Do note that this is the total number of <i>periods</i> not the total
--   number of evolutions. The difference is off-by-one. For example if
--   there are 2 periods (period 0 and 1) then there is only one evolution.
totalPeriodsKES :: KESAlgorithm v => proxy v -> Word
genKeyKES :: KESAlgorithm v => Seed -> SignKeyKES v

-- | The upper bound on the <a>Seed</a> size needed by <a>genKeyKES</a>
seedSizeKES :: KESAlgorithm v => proxy v -> Word

-- | Forget a signing key synchronously, rather than waiting for GC. In
--   some non-mock instances this provides a guarantee that the signing key
--   is no longer in memory.
--   
--   The precondition is that this key value will not be used again.
forgetSignKeyKES :: KESAlgorithm v => SignKeyKES v -> IO ()
sizeVerKeyKES :: KESAlgorithm v => proxy v -> Word
sizeSignKeyKES :: KESAlgorithm v => proxy v -> Word
sizeSigKES :: KESAlgorithm v => proxy v -> Word
rawSerialiseVerKeyKES :: KESAlgorithm v => VerKeyKES v -> ByteString
rawSerialiseSignKeyKES :: KESAlgorithm v => SignKeyKES v -> ByteString
rawSerialiseSigKES :: KESAlgorithm v => SigKES v -> ByteString
rawDeserialiseVerKeyKES :: KESAlgorithm v => ByteString -> Maybe (VerKeyKES v)
rawDeserialiseSignKeyKES :: KESAlgorithm v => ByteString -> Maybe (SignKeyKES v)
rawDeserialiseSigKES :: KESAlgorithm v => ByteString -> Maybe (SigKES v)

-- | The KES period. Periods are enumerated from zero.
--   
--   Be careful of fencepost errors: if there are 2 periods (period 0 and
--   1) then there is only one key evolution.
type Period = Word

-- | Subclass for KES algorithms that embed a copy of the VerKey into the
--   signature itself, rather than relying on the externally supplied
--   VerKey alone. Some optimizations made in the <a>CompactSingleKES</a>
--   and <a>CompactSumKES</a> implementations require this additional
--   interface in order to avoid redundant computations.
class KESAlgorithm v => OptimizedKESAlgorithm v

-- | Partial verification: this method only verifies the signature itself,
--   but it does not check it against any externally-provided VerKey. Use
--   <a>verifyKES</a> for full KES verification.
verifySigKES :: (OptimizedKESAlgorithm v, Signable v a, HasCallStack) => ContextKES v -> Period -> a -> SigKES v -> Either String ()

-- | Extract a VerKey from a SigKES. Note that a VerKey embedded in or
--   derived from a SigKES is effectively user-supplied, so it is not
--   enough to validate a SigKES against this VerKey (like
--   <a>verifySigKES</a> does); you must also compare the VerKey against an
--   externally-provided key that you want to verify against (see
--   <a>verifyKES</a>).
verKeyFromSigKES :: OptimizedKESAlgorithm v => ContextKES v -> Period -> SigKES v -> VerKeyKES v
verifyOptimizedKES :: (OptimizedKESAlgorithm v, Signable v a, HasCallStack) => ContextKES v -> VerKeyKES v -> Period -> a -> SigKES v -> Either String ()
newtype SignedKES v a
SignedKES :: SigKES v -> SignedKES v a
[getSig] :: SignedKES v a -> SigKES v
signedKES :: (KESAlgorithm v, Signable v a) => ContextKES v -> Period -> a -> SignKeyKES v -> SignedKES v a
verifySignedKES :: (KESAlgorithm v, Signable v a) => ContextKES v -> VerKeyKES v -> Period -> a -> SignedKES v a -> Either String ()
encodeVerKeyKES :: KESAlgorithm v => VerKeyKES v -> Encoding
decodeVerKeyKES :: forall v s. KESAlgorithm v => Decoder s (VerKeyKES v)
encodeSignKeyKES :: KESAlgorithm v => SignKeyKES v -> Encoding
decodeSignKeyKES :: forall v s. KESAlgorithm v => Decoder s (SignKeyKES v)
encodeSigKES :: KESAlgorithm v => SigKES v -> Encoding
decodeSigKES :: forall v s. KESAlgorithm v => Decoder s (SigKES v)
encodeSignedKES :: KESAlgorithm v => SignedKES v a -> Encoding
decodeSignedKES :: KESAlgorithm v => Decoder s (SignedKES v a)

-- | <a>Size</a> expression for <a>VerKeyKES</a> which is using
--   <a>sizeVerKeyKES</a> encoded as <a>Size</a>.
encodedVerKeyKESSizeExpr :: forall v. KESAlgorithm v => Proxy (VerKeyKES v) -> Size

-- | <a>Size</a> expression for <a>SignKeyKES</a> which is using
--   <a>sizeSignKeyKES</a> encoded as <a>Size</a>.
encodedSignKeyKESSizeExpr :: forall v. KESAlgorithm v => Proxy (SignKeyKES v) -> Size

-- | <a>Size</a> expression for <a>SigKES</a> which is using
--   <a>sizeSigKES</a> encoded as <a>Size</a>.
encodedSigKESSizeExpr :: forall v. KESAlgorithm v => Proxy (SigKES v) -> Size
hashPairOfVKeys :: (KESAlgorithm d, HashAlgorithm h) => (VerKeyKES d, VerKeyKES d) -> Hash h (VerKeyKES d, VerKeyKES d)
zeroSeed :: KESAlgorithm d => Proxy d -> Seed
mungeName :: String -> String
instance GHC.Generics.Generic (Cardano.Crypto.KES.Class.SignedKES v a)
instance Cardano.Crypto.KES.Class.KESAlgorithm v => GHC.Show.Show (Cardano.Crypto.KES.Class.SignedKES v a)
instance Cardano.Crypto.KES.Class.KESAlgorithm v => GHC.Classes.Eq (Cardano.Crypto.KES.Class.SignedKES v a)
instance Cardano.Crypto.KES.Class.KESAlgorithm v => NoThunks.Class.NoThunks (Cardano.Crypto.KES.Class.SignedKES v a)
instance ((TypeError ...), GHC.Classes.Eq (Cardano.Crypto.KES.Class.SignKeyKES v)) => GHC.Classes.Ord (Cardano.Crypto.KES.Class.SignKeyKES v)
instance ((TypeError ...), Cardano.Crypto.KES.Class.KESAlgorithm v) => GHC.Classes.Ord (Cardano.Crypto.KES.Class.VerKeyKES v)

module Cardano.Crypto.KES.NeverUsed

-- | KES never used
--   
--   The type of keys and signatures is isomorphic to unit, but when
--   actually trying to sign or verify something a runtime exception will
--   be thrown.
data NeverKES
data VerKeyKES v :: Type
data SignKeyKES v :: Type
data SigKES v :: Type
instance NoThunks.Class.NoThunks (Cardano.Crypto.KES.Class.SigKES Cardano.Crypto.KES.NeverUsed.NeverKES)
instance GHC.Generics.Generic (Cardano.Crypto.KES.Class.SigKES Cardano.Crypto.KES.NeverUsed.NeverKES)
instance GHC.Classes.Eq (Cardano.Crypto.KES.Class.SigKES Cardano.Crypto.KES.NeverUsed.NeverKES)
instance GHC.Show.Show (Cardano.Crypto.KES.Class.SigKES Cardano.Crypto.KES.NeverUsed.NeverKES)
instance NoThunks.Class.NoThunks (Cardano.Crypto.KES.Class.SignKeyKES Cardano.Crypto.KES.NeverUsed.NeverKES)
instance GHC.Generics.Generic (Cardano.Crypto.KES.Class.SignKeyKES Cardano.Crypto.KES.NeverUsed.NeverKES)
instance GHC.Classes.Eq (Cardano.Crypto.KES.Class.SignKeyKES Cardano.Crypto.KES.NeverUsed.NeverKES)
instance GHC.Show.Show (Cardano.Crypto.KES.Class.SignKeyKES Cardano.Crypto.KES.NeverUsed.NeverKES)
instance NoThunks.Class.NoThunks (Cardano.Crypto.KES.Class.VerKeyKES Cardano.Crypto.KES.NeverUsed.NeverKES)
instance GHC.Generics.Generic (Cardano.Crypto.KES.Class.VerKeyKES Cardano.Crypto.KES.NeverUsed.NeverKES)
instance GHC.Classes.Eq (Cardano.Crypto.KES.Class.VerKeyKES Cardano.Crypto.KES.NeverUsed.NeverKES)
instance GHC.Show.Show (Cardano.Crypto.KES.Class.VerKeyKES Cardano.Crypto.KES.NeverUsed.NeverKES)
instance Cardano.Crypto.KES.Class.KESAlgorithm Cardano.Crypto.KES.NeverUsed.NeverKES


-- | Implementation of the SHA3_256 hashing algorithm.
module Cardano.Crypto.Hash.SHA3_256
data SHA3_256
instance Cardano.Crypto.Hash.Class.HashAlgorithm Cardano.Crypto.Hash.SHA3_256.SHA3_256

module Cardano.Crypto.Hash.NeverUsed

-- | HASH never used
--   
--   Will throw a runtime exception when trying to hash something.
data NeverHash
instance Cardano.Crypto.Hash.Class.HashAlgorithm Cardano.Crypto.Hash.NeverUsed.NeverHash


-- | Implementation of the Keccak256 hashing algorithm.
module Cardano.Crypto.Hash.Keccak256
data Keccak256
instance Cardano.Crypto.Hash.Class.HashAlgorithm Cardano.Crypto.Hash.Keccak256.Keccak256


-- | Abstract digital signatures.
module Cardano.Crypto.DSIGN.Class
class (Typeable v, Show (VerKeyDSIGN v), Eq (VerKeyDSIGN v), Show (SignKeyDSIGN v), Show (SigDSIGN v), Eq (SigDSIGN v), NoThunks (SigDSIGN v), NoThunks (SignKeyDSIGN v), NoThunks (VerKeyDSIGN v), KnownNat (SeedSizeDSIGN v), KnownNat (SizeVerKeyDSIGN v), KnownNat (SizeSignKeyDSIGN v), KnownNat (SizeSigDSIGN v)) => DSIGNAlgorithm v where {
    type SeedSizeDSIGN v :: Nat;
    type SizeVerKeyDSIGN v :: Nat;
    type SizeSignKeyDSIGN v :: Nat;
    type SizeSigDSIGN v :: Nat;
    data VerKeyDSIGN v :: Type;
    data SignKeyDSIGN v :: Type;
    data SigDSIGN v :: Type;
    
    -- | Context required to run the DSIGN algorithm
    --   
    --   Unit by default (no context required)
    type ContextDSIGN v :: Type;
    type Signable v :: Type -> Constraint;
    type ContextDSIGN v = ();
    type Signable v = Empty;
}
algorithmNameDSIGN :: DSIGNAlgorithm v => proxy v -> String
deriveVerKeyDSIGN :: DSIGNAlgorithm v => SignKeyDSIGN v -> VerKeyDSIGN v
hashVerKeyDSIGN :: (DSIGNAlgorithm v, HashAlgorithm h) => VerKeyDSIGN v -> Hash h (VerKeyDSIGN v)
signDSIGN :: (DSIGNAlgorithm v, Signable v a, HasCallStack) => ContextDSIGN v -> a -> SignKeyDSIGN v -> SigDSIGN v
verifyDSIGN :: (DSIGNAlgorithm v, Signable v a, HasCallStack) => ContextDSIGN v -> VerKeyDSIGN v -> a -> SigDSIGN v -> Either String ()

-- | Note that this function may error (with <a>SeedBytesExhausted</a>) if
--   the provided seed is not long enough. Callers should ensure that the
--   seed has is at least <a>seedSizeDSIGN</a> bytes long.
genKeyDSIGN :: DSIGNAlgorithm v => Seed -> SignKeyDSIGN v
rawSerialiseVerKeyDSIGN :: DSIGNAlgorithm v => VerKeyDSIGN v -> ByteString
rawSerialiseSignKeyDSIGN :: DSIGNAlgorithm v => SignKeyDSIGN v -> ByteString
rawSerialiseSigDSIGN :: DSIGNAlgorithm v => SigDSIGN v -> ByteString
rawDeserialiseVerKeyDSIGN :: DSIGNAlgorithm v => ByteString -> Maybe (VerKeyDSIGN v)
rawDeserialiseSignKeyDSIGN :: DSIGNAlgorithm v => ByteString -> Maybe (SignKeyDSIGN v)
rawDeserialiseSigDSIGN :: DSIGNAlgorithm v => ByteString -> Maybe (SigDSIGN v)

-- | A seed contains a finite number of bytes, and is used for seeding
--   cryptographic algorithms including key generation.
--   
--   This is not itself a PRNG, but can be used to seed a PRNG.
data Seed

-- | The upper bound on the <a>Seed</a> size needed by <a>genKeyDSIGN</a>
seedSizeDSIGN :: forall v proxy. DSIGNAlgorithm v => proxy v -> Word
sizeVerKeyDSIGN :: forall v proxy. DSIGNAlgorithm v => proxy v -> Word
sizeSignKeyDSIGN :: forall v proxy. DSIGNAlgorithm v => proxy v -> Word
sizeSigDSIGN :: forall v proxy. DSIGNAlgorithm v => proxy v -> Word
newtype SignedDSIGN v a
SignedDSIGN :: SigDSIGN v -> SignedDSIGN v a
signedDSIGN :: (DSIGNAlgorithm v, Signable v a) => ContextDSIGN v -> a -> SignKeyDSIGN v -> SignedDSIGN v a
verifySignedDSIGN :: (DSIGNAlgorithm v, Signable v a, HasCallStack) => ContextDSIGN v -> VerKeyDSIGN v -> a -> SignedDSIGN v a -> Either String ()
encodeVerKeyDSIGN :: DSIGNAlgorithm v => VerKeyDSIGN v -> Encoding
decodeVerKeyDSIGN :: forall v s. DSIGNAlgorithm v => Decoder s (VerKeyDSIGN v)
encodeSignKeyDSIGN :: DSIGNAlgorithm v => SignKeyDSIGN v -> Encoding
decodeSignKeyDSIGN :: forall v s. DSIGNAlgorithm v => Decoder s (SignKeyDSIGN v)
encodeSigDSIGN :: DSIGNAlgorithm v => SigDSIGN v -> Encoding
decodeSigDSIGN :: forall v s. DSIGNAlgorithm v => Decoder s (SigDSIGN v)
encodeSignedDSIGN :: DSIGNAlgorithm v => SignedDSIGN v a -> Encoding
decodeSignedDSIGN :: DSIGNAlgorithm v => Decoder s (SignedDSIGN v a)

-- | <a>Size</a> expression for <a>VerKeyDSIGN</a> which is using
--   <a>sizeVerKeyDSIGN</a> encoded as <a>Size</a>.
encodedVerKeyDSIGNSizeExpr :: forall v. DSIGNAlgorithm v => Proxy (VerKeyDSIGN v) -> Size

-- | <a>Size</a> expression for <a>SignKeyDSIGN</a> which is using
--   <a>sizeSignKeyDSIGN</a> encoded as <a>Size</a>.
encodedSignKeyDSIGNSizeExpr :: forall v. DSIGNAlgorithm v => Proxy (SignKeyDSIGN v) -> Size

-- | <a>Size</a> expression for <a>SigDSIGN</a> which is using
--   <a>sizeSigDSIGN</a> encoded as <a>Size</a>.
encodedSigDSIGNSizeExpr :: forall v. DSIGNAlgorithm v => Proxy (SigDSIGN v) -> Size
instance GHC.Generics.Generic (Cardano.Crypto.DSIGN.Class.SignedDSIGN v a)
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm v => GHC.Show.Show (Cardano.Crypto.DSIGN.Class.SignedDSIGN v a)
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm v => GHC.Classes.Eq (Cardano.Crypto.DSIGN.Class.SignedDSIGN v a)
instance Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.SigDSIGN v) => Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.SignedDSIGN v a)
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm v => NoThunks.Class.NoThunks (Cardano.Crypto.DSIGN.Class.SignedDSIGN v a)
instance ((TypeError ...), GHC.Classes.Eq (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN v)) => GHC.Classes.Ord (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN v)
instance ((TypeError ...), GHC.Classes.Eq (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN v)) => GHC.Classes.Ord (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN v)

module Cardano.Crypto.DSIGN.NeverUsed

-- | DSIGN never used
--   
--   The type of keys and signatures is isomorphic to unit, but when
--   actually trying to sign or verify something a runtime exception will
--   be thrown.
data NeverDSIGN
data VerKeyDSIGN v :: Type
data SignKeyDSIGN v :: Type
data SigDSIGN v :: Type
instance NoThunks.Class.NoThunks (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.NeverUsed.NeverDSIGN)
instance GHC.Generics.Generic (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.NeverUsed.NeverDSIGN)
instance GHC.Classes.Eq (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.NeverUsed.NeverDSIGN)
instance GHC.Show.Show (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.NeverUsed.NeverDSIGN)
instance NoThunks.Class.NoThunks (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.NeverUsed.NeverDSIGN)
instance GHC.Generics.Generic (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.NeverUsed.NeverDSIGN)
instance GHC.Classes.Eq (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.NeverUsed.NeverDSIGN)
instance GHC.Show.Show (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.NeverUsed.NeverDSIGN)
instance NoThunks.Class.NoThunks (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.NeverUsed.NeverDSIGN)
instance GHC.Generics.Generic (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.NeverUsed.NeverDSIGN)
instance GHC.Classes.Eq (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.NeverUsed.NeverDSIGN)
instance GHC.Show.Show (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.NeverUsed.NeverDSIGN)
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm Cardano.Crypto.DSIGN.NeverUsed.NeverDSIGN


-- | Ed448 digital signatures.
module Cardano.Crypto.DSIGN.Ed448
data Ed448DSIGN
data SigDSIGN v :: Type
data SignKeyDSIGN v :: Type
data VerKeyDSIGN v :: Type
instance NoThunks.Class.NoThunks (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.Ed448.Ed448DSIGN)
instance Data.ByteArray.Types.ByteArrayAccess (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.Ed448.Ed448DSIGN)
instance GHC.Generics.Generic (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.Ed448.Ed448DSIGN)
instance GHC.Classes.Eq (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.Ed448.Ed448DSIGN)
instance GHC.Show.Show (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.Ed448.Ed448DSIGN)
instance NoThunks.Class.NoThunks (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.Ed448.Ed448DSIGN)
instance Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.Ed448.Ed448DSIGN)
instance Data.ByteArray.Types.ByteArrayAccess (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.Ed448.Ed448DSIGN)
instance GHC.Generics.Generic (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.Ed448.Ed448DSIGN)
instance GHC.Classes.Eq (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.Ed448.Ed448DSIGN)
instance GHC.Show.Show (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.Ed448.Ed448DSIGN)
instance NoThunks.Class.NoThunks (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.Ed448.Ed448DSIGN)
instance Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.Ed448.Ed448DSIGN)
instance Data.ByteArray.Types.ByteArrayAccess (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.Ed448.Ed448DSIGN)
instance GHC.Generics.Generic (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.Ed448.Ed448DSIGN)
instance GHC.Classes.Eq (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.Ed448.Ed448DSIGN)
instance GHC.Show.Show (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.Ed448.Ed448DSIGN)
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm Cardano.Crypto.DSIGN.Ed448.Ed448DSIGN
instance Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.Ed448.Ed448DSIGN)
instance Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.Ed448.Ed448DSIGN)
instance Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.Ed448.Ed448DSIGN)
instance Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.Ed448.Ed448DSIGN)
instance Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.Ed448.Ed448DSIGN)
instance Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.Ed448.Ed448DSIGN)


-- | Abstract Verifiable Random Functions.
module Cardano.Crypto.VRF.Class
class (Typeable v, Show (VerKeyVRF v), Eq (VerKeyVRF v), Show (SignKeyVRF v), Show (CertVRF v), Eq (CertVRF v), NoThunks (CertVRF v), NoThunks (VerKeyVRF v), NoThunks (SignKeyVRF v)) => VRFAlgorithm v where {
    data VerKeyVRF v :: Type;
    data SignKeyVRF v :: Type;
    data CertVRF v :: Type;
    
    -- | Context required to run the VRF algorithm
    --   
    --   Unit by default (no context required)
    type ContextVRF v :: Type;
    type Signable v :: Type -> Constraint;
    type ContextVRF v = ();
    type Signable c = Empty;
}
algorithmNameVRF :: VRFAlgorithm v => proxy v -> String
deriveVerKeyVRF :: VRFAlgorithm v => SignKeyVRF v -> VerKeyVRF v
hashVerKeyVRF :: (VRFAlgorithm v, HashAlgorithm h) => VerKeyVRF v -> Hash h (VerKeyVRF v)
evalVRF :: (VRFAlgorithm v, HasCallStack, Signable v a) => ContextVRF v -> a -> SignKeyVRF v -> (OutputVRF v, CertVRF v)
verifyVRF :: (VRFAlgorithm v, HasCallStack, Signable v a) => ContextVRF v -> VerKeyVRF v -> a -> (OutputVRF v, CertVRF v) -> Bool
genKeyVRF :: VRFAlgorithm v => Seed -> SignKeyVRF v
genKeyPairVRF :: VRFAlgorithm v => Seed -> (SignKeyVRF v, VerKeyVRF v)

-- | The upper bound on the <a>Seed</a> size needed by <a>genKeyVRF</a>, in
--   bytes.
seedSizeVRF :: VRFAlgorithm v => proxy v -> Word
sizeVerKeyVRF :: VRFAlgorithm v => proxy v -> Word
sizeSignKeyVRF :: VRFAlgorithm v => proxy v -> Word
sizeCertVRF :: VRFAlgorithm v => proxy v -> Word
sizeOutputVRF :: VRFAlgorithm v => proxy v -> Word
rawSerialiseVerKeyVRF :: VRFAlgorithm v => VerKeyVRF v -> ByteString
rawSerialiseSignKeyVRF :: VRFAlgorithm v => SignKeyVRF v -> ByteString
rawSerialiseCertVRF :: VRFAlgorithm v => CertVRF v -> ByteString
rawDeserialiseVerKeyVRF :: VRFAlgorithm v => ByteString -> Maybe (VerKeyVRF v)
rawDeserialiseSignKeyVRF :: VRFAlgorithm v => ByteString -> Maybe (SignKeyVRF v)
rawDeserialiseCertVRF :: VRFAlgorithm v => ByteString -> Maybe (CertVRF v)

-- | The output bytes of the VRF.
--   
--   The output size is a fixed number of bytes and is given by
--   <a>sizeOutputVRF</a>.
newtype OutputVRF v
OutputVRF :: ByteString -> OutputVRF v
[getOutputVRFBytes] :: OutputVRF v -> ByteString

-- | The output bytes of the VRF interpreted as a big endian natural
--   number.
--   
--   The range of this number is determined by the size of the VRF output
--   bytes. It is thus in the range <tt>0 .. 2 ^ (8 * sizeOutputVRF proxy)
--   - 1</tt>.
getOutputVRFNatural :: OutputVRF v -> Natural

-- | For testing purposes, make an <a>OutputVRF</a> from a <a>Natural</a>.
--   
--   The <a>OutputVRF</a> will be of the appropriate size for the
--   <a>VRFAlgorithm</a>.
mkTestOutputVRF :: forall v. VRFAlgorithm v => Natural -> OutputVRF v
data CertifiedVRF v a
CertifiedVRF :: !OutputVRF v -> !CertVRF v -> CertifiedVRF v a
[certifiedOutput] :: CertifiedVRF v a -> !OutputVRF v
[certifiedProof] :: CertifiedVRF v a -> !CertVRF v
evalCertified :: (VRFAlgorithm v, Signable v a) => ContextVRF v -> a -> SignKeyVRF v -> CertifiedVRF v a
verifyCertified :: (VRFAlgorithm v, Signable v a) => ContextVRF v -> VerKeyVRF v -> a -> CertifiedVRF v a -> Bool
encodeVerKeyVRF :: VRFAlgorithm v => VerKeyVRF v -> Encoding
decodeVerKeyVRF :: forall v s. VRFAlgorithm v => Decoder s (VerKeyVRF v)
encodeSignKeyVRF :: VRFAlgorithm v => SignKeyVRF v -> Encoding
decodeSignKeyVRF :: forall v s. VRFAlgorithm v => Decoder s (SignKeyVRF v)
encodeCertVRF :: VRFAlgorithm v => CertVRF v -> Encoding
decodeCertVRF :: forall v s. VRFAlgorithm v => Decoder s (CertVRF v)

-- | <a>Size</a> expression for <a>VerKeyVRF</a> which is using
--   <a>sizeVerKeyVRF</a> encoded as <a>Size</a>.
encodedVerKeyVRFSizeExpr :: forall v. VRFAlgorithm v => Proxy (VerKeyVRF v) -> Size

-- | <a>Size</a> expression for <a>SignKeyVRF</a> which is using
--   <a>sizeSignKeyVRF</a> encoded as <a>Size</a>
encodedSignKeyVRFSizeExpr :: forall v. VRFAlgorithm v => Proxy (SignKeyVRF v) -> Size

-- | <a>Size</a> expression for <a>CertVRF</a> which is using
--   <a>sizeCertVRF</a> encoded as <a>Size</a>.
encodedCertVRFSizeExpr :: forall v. VRFAlgorithm v => Proxy (CertVRF v) -> Size
instance Control.DeepSeq.NFData (Cardano.Crypto.VRF.Class.OutputVRF v)
instance NoThunks.Class.NoThunks (Cardano.Crypto.VRF.Class.OutputVRF v)
instance Data.Typeable.Internal.Typeable v => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.VRF.Class.OutputVRF v)
instance Data.Typeable.Internal.Typeable v => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.VRF.Class.OutputVRF v)
instance GHC.Show.Show (Cardano.Crypto.VRF.Class.OutputVRF v)
instance GHC.Classes.Ord (Cardano.Crypto.VRF.Class.OutputVRF v)
instance GHC.Classes.Eq (Cardano.Crypto.VRF.Class.OutputVRF v)
instance GHC.Generics.Generic (Cardano.Crypto.VRF.Class.CertifiedVRF v a)
instance Cardano.Crypto.VRF.Class.VRFAlgorithm v => GHC.Show.Show (Cardano.Crypto.VRF.Class.CertifiedVRF v a)
instance Cardano.Crypto.VRF.Class.VRFAlgorithm v => GHC.Classes.Eq (Cardano.Crypto.VRF.Class.CertifiedVRF v a)
instance Cardano.Crypto.VRF.Class.VRFAlgorithm v => NoThunks.Class.NoThunks (Cardano.Crypto.VRF.Class.CertifiedVRF v a)
instance (Cardano.Crypto.VRF.Class.VRFAlgorithm v, Data.Typeable.Internal.Typeable a) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.VRF.Class.CertifiedVRF v a)
instance (Cardano.Crypto.VRF.Class.VRFAlgorithm v, Data.Typeable.Internal.Typeable a) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.VRF.Class.CertifiedVRF v a)
instance ((TypeError ...), GHC.Classes.Eq (Cardano.Crypto.VRF.Class.SignKeyVRF v)) => GHC.Classes.Ord (Cardano.Crypto.VRF.Class.SignKeyVRF v)
instance ((TypeError ...), GHC.Classes.Eq (Cardano.Crypto.VRF.Class.VerKeyVRF v)) => GHC.Classes.Ord (Cardano.Crypto.VRF.Class.VerKeyVRF v)

module Cardano.Crypto.VRF.NeverUsed

-- | VRF not available
--   
--   The type of keys and certificates is isomorphic to unit, but when
--   actually trying to sign or verify something a runtime exception will
--   be thrown.
data NeverVRF
data VerKeyVRF v :: Type
data SignKeyVRF v :: Type
data CertVRF v :: Type
instance NoThunks.Class.NoThunks (Cardano.Crypto.VRF.Class.CertVRF Cardano.Crypto.VRF.NeverUsed.NeverVRF)
instance GHC.Generics.Generic (Cardano.Crypto.VRF.Class.CertVRF Cardano.Crypto.VRF.NeverUsed.NeverVRF)
instance GHC.Classes.Ord (Cardano.Crypto.VRF.Class.CertVRF Cardano.Crypto.VRF.NeverUsed.NeverVRF)
instance GHC.Classes.Eq (Cardano.Crypto.VRF.Class.CertVRF Cardano.Crypto.VRF.NeverUsed.NeverVRF)
instance GHC.Show.Show (Cardano.Crypto.VRF.Class.CertVRF Cardano.Crypto.VRF.NeverUsed.NeverVRF)
instance NoThunks.Class.NoThunks (Cardano.Crypto.VRF.Class.SignKeyVRF Cardano.Crypto.VRF.NeverUsed.NeverVRF)
instance GHC.Generics.Generic (Cardano.Crypto.VRF.Class.SignKeyVRF Cardano.Crypto.VRF.NeverUsed.NeverVRF)
instance GHC.Classes.Eq (Cardano.Crypto.VRF.Class.SignKeyVRF Cardano.Crypto.VRF.NeverUsed.NeverVRF)
instance GHC.Show.Show (Cardano.Crypto.VRF.Class.SignKeyVRF Cardano.Crypto.VRF.NeverUsed.NeverVRF)
instance NoThunks.Class.NoThunks (Cardano.Crypto.VRF.Class.VerKeyVRF Cardano.Crypto.VRF.NeverUsed.NeverVRF)
instance GHC.Generics.Generic (Cardano.Crypto.VRF.Class.VerKeyVRF Cardano.Crypto.VRF.NeverUsed.NeverVRF)
instance GHC.Classes.Eq (Cardano.Crypto.VRF.Class.VerKeyVRF Cardano.Crypto.VRF.NeverUsed.NeverVRF)
instance GHC.Show.Show (Cardano.Crypto.VRF.Class.VerKeyVRF Cardano.Crypto.VRF.NeverUsed.NeverVRF)
instance Cardano.Crypto.VRF.Class.VRFAlgorithm Cardano.Crypto.VRF.NeverUsed.NeverVRF


-- | Utilities for FFI
module Cardano.Foreign
newtype SizedPtr (n :: Nat)
SizedPtr :: Ptr Void -> SizedPtr (n :: Nat)

-- | Like <a>allocaBytes</a>.
allocaSized :: forall n b. KnownNat n => (SizedPtr n -> IO b) -> IO b
memcpySized :: forall n. KnownNat n => SizedPtr n -> SizedPtr n -> IO ()
memsetSized :: forall n. KnownNat n => SizedPtr n -> Word8 -> IO ()

-- | <pre>
--   void *memcpy(void *dest, const void *src, size_t n);
--   </pre>
--   
--   Note: this is safe foreign import
c_memcpy :: Ptr a -> Ptr a -> CSize -> IO (Ptr ())

-- | <pre>
--   void *memset(void *s, int c, size_t n);
--   </pre>
--   
--   Note: for sure zeroing memory use <tt>c_sodium_memzero</tt>.
c_memset :: Ptr a -> Int -> CSize -> IO (Ptr ())

module Cardano.Crypto.SECP256K1.C
data SECP256k1Context
secpContextSignVerify :: CUInt
data SECP256k1SchnorrExtraParams
secpContextCreate :: CUInt -> IO (Ptr SECP256k1Context)
secpKeyPairCreate :: Ptr SECP256k1Context -> SizedPtr SECP256K1_SCHNORR_KEYPAIR_BYTES -> SizedPtr SECP256K1_SCHNORR_PRIVKEY_BYTES -> IO CInt
secpSchnorrSigSignCustom :: Ptr SECP256k1Context -> SizedPtr SECP256K1_SCHNORR_SIGNATURE_BYTES -> Ptr CUChar -> CSize -> SizedPtr SECP256K1_SCHNORR_KEYPAIR_BYTES -> Ptr SECP256k1SchnorrExtraParams -> IO CInt
secpKeyPairXOnlyPub :: Ptr SECP256k1Context -> SizedPtr SECP256K1_SCHNORR_PUBKEY_BYTES_INTERNAL -> Ptr CInt -> SizedPtr SECP256K1_SCHNORR_KEYPAIR_BYTES -> IO CInt
secpSchnorrSigVerify :: Ptr SECP256k1Context -> SizedPtr SECP256K1_SCHNORR_SIGNATURE_BYTES -> Ptr CUChar -> CSize -> SizedPtr SECP256K1_SCHNORR_PUBKEY_BYTES_INTERNAL -> CInt
secpXOnlyPubkeySerialize :: Ptr SECP256k1Context -> SizedPtr SECP256K1_SCHNORR_PUBKEY_BYTES -> SizedPtr SECP256K1_SCHNORR_PUBKEY_BYTES_INTERNAL -> IO CInt
secpXOnlyPubkeyParse :: Ptr SECP256k1Context -> SizedPtr SECP256K1_SCHNORR_PUBKEY_BYTES_INTERNAL -> Ptr CUChar -> IO CInt
secpCtxPtr :: ForeignPtr SECP256k1Context
secpEcPubkeyCreate :: Ptr SECP256k1Context -> SizedPtr SECP256K1_ECDSA_PUBKEY_BYTES_INTERNAL -> SizedPtr SECP256K1_ECDSA_PRIVKEY_BYTES -> IO CInt
secpEcdsaSign :: Ptr SECP256k1Context -> SizedPtr SECP256K1_ECDSA_SIGNATURE_BYTES_INTERNAL -> SizedPtr SECP256K1_ECDSA_MESSAGE_BYTES -> SizedPtr SECP256K1_ECDSA_PRIVKEY_BYTES -> Ptr CUChar -> Ptr CUChar -> IO CInt
secpEcdsaVerify :: Ptr SECP256k1Context -> SizedPtr SECP256K1_ECDSA_SIGNATURE_BYTES_INTERNAL -> SizedPtr SECP256K1_ECDSA_MESSAGE_BYTES -> SizedPtr SECP256K1_ECDSA_PUBKEY_BYTES_INTERNAL -> CInt
secpEcCompressed :: CUInt
secpEcPubkeySerialize :: Ptr SECP256k1Context -> Ptr CUChar -> Ptr CSize -> SizedPtr SECP256K1_ECDSA_PUBKEY_BYTES_INTERNAL -> CUInt -> IO CInt
secpEcdsaSignatureSerializeCompact :: Ptr SECP256k1Context -> SizedPtr SECP256K1_ECDSA_SIGNATURE_BYTES -> SizedPtr SECP256K1_ECDSA_SIGNATURE_BYTES_INTERNAL -> IO CInt
secpEcdsaSignatureParseCompact :: Ptr SECP256k1Context -> SizedPtr SECP256K1_ECDSA_SIGNATURE_BYTES_INTERNAL -> SizedPtr SECP256K1_ECDSA_SIGNATURE_BYTES -> IO CInt
secpEcPubkeyParse :: Ptr SECP256k1Context -> SizedPtr SECP256K1_ECDSA_PUBKEY_BYTES_INTERNAL -> Ptr CUChar -> CSize -> IO CInt

module Cardano.Crypto.Libsodium.C

-- | <pre>
--   void sodium_init();
--   </pre>
--   
--   <a>https://libsodium.gitbook.io/doc/usage</a>
c_sodium_init :: IO Int

-- | <pre>
--   void sodium_memzero(void * const pnt, const size_t len);
--   </pre>
--   
--   
--   <a>https://libsodium.gitbook.io/doc/memory_management#zeroing-memory</a>
c_sodium_memzero :: Ptr a -> CSize -> IO ()

-- | <pre>
--   void *sodium_malloc(size_t size);
--   </pre>
--   
--   <a>https://libsodium.gitbook.io/doc/memory_management</a>
c_sodium_malloc :: CSize -> IO (Ptr a)

-- | <pre>
--   void sodium_free(void *ptr);
--   </pre>
--   
--   <a>https://libsodium.gitbook.io/doc/memory_management</a>
c_sodium_free :: Ptr a -> IO ()

-- | <pre>
--   void sodium_free(void *ptr);
--   </pre>
--   
--   <a>https://libsodium.gitbook.io/doc/memory_management</a>
c_sodium_free_funptr :: FunPtr (Ptr a -> IO ())

-- | <pre>
--   int crypto_hash_sha256(unsigned char *out, const unsigned char *in, unsigned long long inlen);
--   </pre>
--   
--   <a>https://libsodium.gitbook.io/doc/advanced/sha-2_hash_function</a>
c_crypto_hash_sha256 :: SizedPtr CRYPTO_SHA256_BYTES -> Ptr CUChar -> CULLong -> IO Int

-- | <pre>
--   int crypto_hash_sha256_final(crypto_hash_sha256_state *state, unsigned char *out);
--   </pre>
c_crypto_hash_sha256_final :: SizedPtr CRYPTO_SHA256_STATE_SIZE -> SizedPtr CRYPTO_SHA256_BYTES -> IO Int

-- | <pre>
--   int crypto_hash_sha256_init(crypto_hash_sha256_state *state);
--   </pre>
c_crypto_hash_sha256_init :: SizedPtr CRYPTO_SHA256_STATE_SIZE -> IO Int

-- | <pre>
--   int crypto_hash_sha256_update(crypto_hash_sha256_state *state, const unsigned char *in, unsigned long long inlen);
--   </pre>
c_crypto_hash_sha256_update :: SizedPtr CRYPTO_SHA256_STATE_SIZE -> Ptr CUChar -> CULLong -> IO Int

-- | <pre>
--   int crypto_generichash_blake2b(unsigned char *out, size_t outlen, const unsigned char *in, unsigned long long inlen, const unsigned char *key, size_t keylen);
--   </pre>
--   
--   <a>https://libsodium.gitbook.io/doc/hashing/generic_hashing</a>
c_crypto_generichash_blake2b :: Ptr out -> CSize -> Ptr CUChar -> CULLong -> Ptr key -> CSize -> IO Int

-- | <pre>
--   int crypto_generichash_blake2b_final(crypto_generichash_blake2b_state *state, unsigned char *out, const size_t outlen);
--   </pre>
c_crypto_generichash_blake2b_final :: SizedPtr CRYPTO_BLAKE2B_256_STATE_SIZE -> Ptr out -> CSize -> IO Int

-- | <pre>
--   int crypto_generichash_blake2b_init(crypto_generichash_blake2b_state *state, const unsigned char *key, const size_t keylen, const size_t outlen);
--   </pre>
c_crypto_generichash_blake2b_init :: SizedPtr CRYPTO_BLAKE2B_256_STATE_SIZE -> Ptr key -> CSize -> CSize -> IO Int

-- | <pre>
--   int crypto_generichash_blake2b_update(crypto_generichash_blake2b_state *state, const unsigned char *in, unsigned long long inlen);
--   </pre>
c_crypto_generichash_blake2b_update :: SizedPtr CRYPTO_BLAKE2B_256_STATE_SIZE -> Ptr CUChar -> CULLong -> IO Int

-- | <pre>
--   int crypto_sign_ed25519_seed_keypair(unsigned char *pk, unsigned char *sk, const unsigned char *seed);
--   </pre>
c_crypto_sign_ed25519_seed_keypair :: SizedPtr CRYPTO_SIGN_ED25519_PUBLICKEYBYTES -> SizedPtr CRYPTO_SIGN_ED25519_SECRETKEYBYTES -> SizedPtr CRYPTO_SIGN_ED25519_SEEDBYTES -> IO Int

-- | <pre>
--   int crypto_sign_ed25519_sk_to_seed(unsigned char *seed, const unsigned char *sk);
--   </pre>
c_crypto_sign_ed25519_sk_to_seed :: SizedPtr CRYPTO_SIGN_ED25519_SEEDBYTES -> SizedPtr CRYPTO_SIGN_ED25519_SECRETKEYBYTES -> IO Int

-- | <pre>
--   int crypto_sign_ed25519_detached(unsigned char *sig, unsigned long long *siglen_p, const unsigned char *m, unsigned long long mlen, const unsigned char *sk);
--   </pre>
c_crypto_sign_ed25519_detached :: SizedPtr CRYPTO_SIGN_ED25519_BYTES -> Ptr CULLong -> Ptr CUChar -> CULLong -> SizedPtr CRYPTO_SIGN_ED25519_SECRETKEYBYTES -> IO Int

-- | <pre>
--   int crypto_sign_ed25519_verify_detached(const unsigned char *sig, const unsigned char *m, unsigned long long mlen, const unsigned char *pk);
--   </pre>
c_crypto_sign_ed25519_verify_detached :: SizedPtr CRYPTO_SIGN_ED25519_BYTES -> Ptr CUChar -> CULLong -> SizedPtr CRYPTO_SIGN_ED25519_PUBLICKEYBYTES -> IO Int

-- | <pre>
--   int crypto_sign_ed25519_sk_to_pk(unsigned char *pk, const unsigned char *sk);
--   </pre>
c_crypto_sign_ed25519_sk_to_pk :: SizedPtr CRYPTO_SIGN_ED25519_PUBLICKEYBYTES -> SizedPtr CRYPTO_SIGN_ED25519_SECRETKEYBYTES -> IO Int

-- | <pre>
--   int sodium_compare(const void * const b1_, const void * const b2_, size_t len);
--   </pre>
--   
--   
--   <a>https://libsodium.gitbook.io/doc/helpers#comparing-large-numbers</a>
c_sodium_compare :: Ptr a -> Ptr a -> CSize -> IO Int
type CRYPTO_SHA256_BYTES = 32
type CRYPTO_SHA512_BYTES = 64
type CRYPTO_BLAKE2B_256_BYTES = 32
type CRYPTO_SHA256_STATE_SIZE = (104)
type CRYPTO_SHA512_STATE_SIZE = (208)
type CRYPTO_BLAKE2B_256_STATE_SIZE = (384)
type CRYPTO_SIGN_ED25519_BYTES = 64
type CRYPTO_SIGN_ED25519_SEEDBYTES = 32
type CRYPTO_SIGN_ED25519_PUBLICKEYBYTES = 32
type CRYPTO_SIGN_ED25519_SECRETKEYBYTES = 64

module Cardano.Crypto.PinnedSizedBytes

-- | <tt>n</tt> bytes. <a>Storable</a>.
--   
--   We have two <tt>*Bytes</tt> types:
--   
--   <ul>
--   <li><tt>PinnedSizedBytes</tt> is backed by pinned ByteArray.</li>
--   <li><tt>MLockedSizedBytes</tt> is backed by ForeignPtr to
--   <tt>mlock</tt>-ed memory region.</li>
--   </ul>
--   
--   The <tt>ByteString</tt> is pinned datatype, but it's represented by
--   <tt>ForeignPtr</tt> + offset (and size).
--   
--   I'm sorry for adding more types for bytes. :(
data PinnedSizedBytes (n :: Nat)

-- | <i>Deprecated: This is not referentially transparent</i>
psbZero :: KnownNat n => PinnedSizedBytes n

-- | See <tt><a>IsString</a> (<a>PinnedSizedBytes</a> n)</tt> instance.
--   
--   <pre>
--   &gt;&gt;&gt; psbToBytes . (id @(PinnedSizedBytes 4)) . psbFromBytes $ [1,2,3,4]
--   [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; psbToBytes . (id @(PinnedSizedBytes 4)) . psbFromBytes $ [1,2]
--   [0,0,1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; psbToBytes . (id @(PinnedSizedBytes 4)) . psbFromBytes $ [1,2,3,4,5,6]
--   [3,4,5,6]
--   </pre>

-- | <i>Deprecated: This is not referentially transparent</i>
psbFromBytes :: forall n. KnownNat n => [Word8] -> PinnedSizedBytes n

-- | See <a>psbFromBytes</a>.
psbToBytes :: PinnedSizedBytes n -> [Word8]

-- | Convert a ByteString into PinnedSizedBytes. Input should contain the
--   exact number of bytes as expected by type level <tt>n</tt> size,
--   otherwise error.
psbFromByteString :: KnownNat n => ByteString -> PinnedSizedBytes n
psbFromByteStringCheck :: forall n. KnownNat n => ByteString -> Maybe (PinnedSizedBytes n)
psbToByteString :: PinnedSizedBytes n -> ByteString

-- | Use a <a>PinnedSizedBytes</a> in a setting where its size is
--   'forgotten' temporarily.
--   
--   <h1>Note</h1>
--   
--   The <a>Ptr</a> given to the function argument <i>must not</i> be used
--   as the result of type <tt>r</tt>.
psbUseAsCPtr :: forall (n :: Nat) (r :: Type). PinnedSizedBytes n -> (Ptr Word8 -> IO r) -> IO r

-- | As <a>psbUseAsCPtr</a>, but also gives the function argument the size
--   we are allowed to use as a <a>CSize</a>.
--   
--   This is mostly boilerplate removal, as it is quite common for C APIs
--   to take a combination of a pointer to some data and its length. A
--   possible use case (and one we run into) is where we know that we can
--   expect a certain data length (using <a>PinnedSizedBytes</a> as its
--   representation), but the C API allows any length we like, provided we
--   give the right argument to indicate this. Therefore, having a helper
--   like this one allows us to avoid having to manually <a>natVal</a> a
--   <a>Proxy</a>, as well as ensuring we don't get mismatches
--   accidentally.
--   
--   The same caveats apply to the use of this function as to the use of
--   <a>psbUseAsCPtr</a>.
psbUseAsCPtrLen :: forall (n :: Nat) (r :: Type). KnownNat n => PinnedSizedBytes n -> (Ptr Word8 -> CSize -> IO r) -> IO r

-- | As <a>psbUseAsCPtr</a>, but does not 'forget' the size.
--   
--   The same caveats apply to this use of this function as to the use of
--   <a>psbUseAsCPtr</a>.
psbUseAsSizedPtr :: forall (n :: Nat) (r :: Type). PinnedSizedBytes n -> (SizedPtr n -> IO r) -> IO r

-- | As <a>psbCreateResult</a>, but presumes that no useful value is
--   produced: that is, the function argument is run only for its side
--   effects.
psbCreate :: forall (n :: Nat). KnownNat n => (Ptr Word8 -> IO ()) -> IO (PinnedSizedBytes n)

-- | As <a>psbCreateResultLen</a>, but presumes that no useful value is
--   produced: that is, the function argument is run only for its side
--   effects.
psbCreateLen :: forall (n :: Nat). KnownNat n => (Ptr Word8 -> CSize -> IO ()) -> IO (PinnedSizedBytes n)

-- | As <a>psbCreateSizedResult</a>, but presumes that no useful value is
--   produced: that is, the function argument is run only for its side
--   effects.
psbCreateSized :: forall (n :: Nat). KnownNat n => (SizedPtr n -> IO ()) -> IO (PinnedSizedBytes n)

-- | Given an 'initialization action', which also produces some result,
--   allocate new pinned memory of the specified size, perform the action,
--   then return the result together with the initialized pinned memory (as
--   a <a>PinnedSizedBytes</a>).
--   
--   <h1>Note</h1>
--   
--   It is essential that <tt>r</tt> is not the <a>Ptr</a> given to the
--   function argument. Returning this <a>Ptr</a> is <i>extremely</i>
--   unsafe:
--   
--   <ul>
--   <li>It breaks referential transparency guarantees by aliasing
--   supposedly immutable memory; and</li>
--   <li>This <a>Ptr</a> could refer to memory which has already been
--   garbage collected, which can lead to segfaults or out-of-bounds
--   reads.</li>
--   </ul>
--   
--   This poses both correctness <i>and</i> security risks, so please don't
--   do it.
psbCreateResult :: forall (n :: Nat) (r :: Type). KnownNat n => (Ptr Word8 -> IO r) -> IO (PinnedSizedBytes n, r)

-- | As <a>psbCreateResult</a>, but also gives the number of bytes we are
--   allowed to operate on as a <a>CSize</a>.
--   
--   This function is provided for two reasons:
--   
--   <ul>
--   <li>It is a common practice in C libraries to pass a pointer to data
--   plus a length. While <i>our</i> use case might know the size we
--   expect, the C function we are calling might be more general. This
--   simplifies calling such functions.</li>
--   <li>We avoid <a>natVal</a>ing a <a>Proxy</a> <i>twice</i>, since we
--   have to do it anyway.</li>
--   </ul>
--   
--   The same caveats apply to this function as to <a>psbCreateResult</a>:
--   the <a>Ptr</a> given to the function argument <i>must not</i> be
--   returned as <tt>r</tt>.
psbCreateResultLen :: forall (n :: Nat) (r :: Type). KnownNat n => (Ptr Word8 -> CSize -> IO r) -> IO (PinnedSizedBytes n, r)

-- | As <a>psbCreateResult</a>, but gives a <a>SizedPtr</a> to the function
--   argument. The same caveats apply to this function as to
--   <a>psbCreateResult</a>: the <a>SizedPtr</a> given to the function
--   argument <i>must not</i> be resulted as <tt>r</tt>.
psbCreateSizedResult :: forall (n :: Nat) (r :: Type). KnownNat n => (SizedPtr n -> IO r) -> IO (PinnedSizedBytes n, r)
ptrPsbToSizedPtr :: Ptr (PinnedSizedBytes n) -> SizedPtr n
instance Control.DeepSeq.NFData (Cardano.Crypto.PinnedSizedBytes.PinnedSizedBytes n)
instance NoThunks.Class.NoThunks (Cardano.Crypto.PinnedSizedBytes.PinnedSizedBytes n)
instance GHC.Show.Show (Cardano.Crypto.PinnedSizedBytes.PinnedSizedBytes n)
instance GHC.TypeNats.KnownNat n => GHC.Classes.Eq (Cardano.Crypto.PinnedSizedBytes.PinnedSizedBytes n)
instance GHC.TypeNats.KnownNat n => GHC.Classes.Ord (Cardano.Crypto.PinnedSizedBytes.PinnedSizedBytes n)
instance GHC.TypeNats.KnownNat n => Data.String.IsString (Language.Haskell.TH.Syntax.Q (Language.Haskell.TH.Syntax.TExp (Cardano.Crypto.PinnedSizedBytes.PinnedSizedBytes n)))
instance GHC.TypeNats.KnownNat n => Data.String.IsString (Language.Haskell.TH.Syntax.Code Language.Haskell.TH.Syntax.Q (Cardano.Crypto.PinnedSizedBytes.PinnedSizedBytes n))
instance GHC.TypeNats.KnownNat n => Foreign.Storable.Storable (Cardano.Crypto.PinnedSizedBytes.PinnedSizedBytes n)

module Cardano.Crypto.DSIGN.EcdsaSecp256k1

-- | As ECDSA signatures on the SECP256k1 curve sign 32-byte hashes, rather
--   than whole messages, we provide a helper (opaque) newtype to ensure
--   that the size of the input for signing and verification is strictly
--   bounded.
--   
--   <h1>Important note</h1>
--   
--   If you are verifying a message using the algorithm provided here, you
--   should hash the message yourself before verifying. Specifically, the
--   sender should give you the message itself to verify, rather than the
--   hash of the message used to compute the signature.
data MessageHash

-- | Take a blob of bytes (which is presumed to be a 32-byte hash), verify
--   its length, and package it into a <a>MessageHash</a> if that length is
--   exactly 32.
toMessageHash :: ByteString -> Maybe MessageHash

-- | Turn a <a>MessageHash</a> into its bytes without a length marker.
fromMessageHash :: MessageHash -> ByteString

-- | A helper to use with the <a>HashAlgorithm</a> API, as this can ensure
--   sizing.
hashAndPack :: forall (h :: Type). (HashAlgorithm h, SizeHash h ~ SECP256K1_ECDSA_MESSAGE_BYTES) => Proxy h -> ByteString -> MessageHash
data EcdsaSecp256k1DSIGN
data VerKeyDSIGN v :: Type
data SignKeyDSIGN v :: Type
data SigDSIGN v :: Type
instance GHC.Show.Show Cardano.Crypto.DSIGN.EcdsaSecp256k1.MessageHash
instance GHC.Classes.Eq Cardano.Crypto.DSIGN.EcdsaSecp256k1.MessageHash
instance NoThunks.Class.NoThunks (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.EcdsaSecp256k1.EcdsaSecp256k1DSIGN)
instance GHC.Generics.Generic (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.EcdsaSecp256k1.EcdsaSecp256k1DSIGN)
instance GHC.Show.Show (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.EcdsaSecp256k1.EcdsaSecp256k1DSIGN)
instance Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.EcdsaSecp256k1.EcdsaSecp256k1DSIGN)
instance GHC.Classes.Eq (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.EcdsaSecp256k1.EcdsaSecp256k1DSIGN)
instance NoThunks.Class.NoThunks (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.EcdsaSecp256k1.EcdsaSecp256k1DSIGN)
instance GHC.Generics.Generic (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.EcdsaSecp256k1.EcdsaSecp256k1DSIGN)
instance GHC.Show.Show (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.EcdsaSecp256k1.EcdsaSecp256k1DSIGN)
instance Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.EcdsaSecp256k1.EcdsaSecp256k1DSIGN)
instance GHC.Classes.Eq (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.EcdsaSecp256k1.EcdsaSecp256k1DSIGN)
instance NoThunks.Class.NoThunks (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.EcdsaSecp256k1.EcdsaSecp256k1DSIGN)
instance GHC.Generics.Generic (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.EcdsaSecp256k1.EcdsaSecp256k1DSIGN)
instance GHC.Show.Show (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.EcdsaSecp256k1.EcdsaSecp256k1DSIGN)
instance Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.EcdsaSecp256k1.EcdsaSecp256k1DSIGN)
instance GHC.Classes.Eq (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.EcdsaSecp256k1.EcdsaSecp256k1DSIGN)
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm Cardano.Crypto.DSIGN.EcdsaSecp256k1.EcdsaSecp256k1DSIGN
instance Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.EcdsaSecp256k1.EcdsaSecp256k1DSIGN)
instance Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.EcdsaSecp256k1.EcdsaSecp256k1DSIGN)
instance Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.EcdsaSecp256k1.EcdsaSecp256k1DSIGN)
instance Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.EcdsaSecp256k1.EcdsaSecp256k1DSIGN)
instance Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.EcdsaSecp256k1.EcdsaSecp256k1DSIGN)
instance Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.EcdsaSecp256k1.EcdsaSecp256k1DSIGN)

module Cardano.Crypto.Libsodium.Memory.Internal

-- | Foreign pointer to securely allocated memory.
newtype MLockedForeignPtr a
SFP :: ForeignPtr a -> MLockedForeignPtr a
[_unwrapMLockedForeignPtr] :: MLockedForeignPtr a -> ForeignPtr a
withMLockedForeignPtr :: forall a b. MLockedForeignPtr a -> (Ptr a -> IO b) -> IO b

-- | Allocate secure memory using <a>c_sodium_malloc</a>.
--   
--   <a>https://libsodium.gitbook.io/doc/memory_management</a>
allocMLockedForeignPtr :: Storable a => IO (MLockedForeignPtr a)
finalizeMLockedForeignPtr :: forall a. MLockedForeignPtr a -> IO ()

-- | <i>Deprecated: Don't leave traceMLockedForeignPtr in production</i>
traceMLockedForeignPtr :: (Storable a, Show a) => MLockedForeignPtr a -> IO ()
mlockedAlloca :: forall a b. CSize -> (Ptr a -> IO b) -> IO b
mlockedAllocaSized :: forall n b. KnownNat n => (SizedPtr n -> IO b) -> IO b
sodiumMalloc :: CSize -> IO (Ptr a)
sodiumFree :: Ptr a -> IO ()
instance NoThunks.Class.NoThunks (Cardano.Crypto.Libsodium.Memory.Internal.MLockedForeignPtr a)

module Cardano.Crypto.Libsodium.Memory

-- | Foreign pointer to securely allocated memory.
data MLockedForeignPtr a
withMLockedForeignPtr :: forall a b. MLockedForeignPtr a -> (Ptr a -> IO b) -> IO b

-- | Allocate secure memory using <a>c_sodium_malloc</a>.
--   
--   <a>https://libsodium.gitbook.io/doc/memory_management</a>
allocMLockedForeignPtr :: Storable a => IO (MLockedForeignPtr a)
finalizeMLockedForeignPtr :: forall a. MLockedForeignPtr a -> IO ()

-- | <i>Deprecated: Don't leave traceMLockedForeignPtr in production</i>
traceMLockedForeignPtr :: (Storable a, Show a) => MLockedForeignPtr a -> IO ()

module Cardano.Crypto.Libsodium.MLockedBytes.Internal
newtype MLockedSizedBytes n
MLSB :: MLockedForeignPtr (PinnedSizedBytes n) -> MLockedSizedBytes n

-- | Note: this doesn't need to allocate mlocked memory, but we do that for
--   consistency
mlsbZero :: forall n. KnownNat n => MLockedSizedBytes n
mlsbFromByteString :: forall n. KnownNat n => ByteString -> MLockedSizedBytes n
mlsbFromByteStringCheck :: forall n. KnownNat n => ByteString -> Maybe (MLockedSizedBytes n)

-- | <i>Note:</i> the resulting <a>ByteString</a> will still refer to
--   secure memory, but the types don't prevent it from be exposed.
mlsbToByteString :: forall n. KnownNat n => MLockedSizedBytes n -> ByteString
mlsbUseAsCPtr :: MLockedSizedBytes n -> (Ptr Word8 -> IO r) -> IO r
mlsbUseAsSizedPtr :: MLockedSizedBytes n -> (SizedPtr n -> IO r) -> IO r

-- | Calls <a>finalizeMLockedForeignPtr</a> on underlying pointer. This
--   function invalidates argument.
mlsbFinalize :: MLockedSizedBytes n -> IO ()
instance NoThunks.Class.NoThunks (Cardano.Crypto.Libsodium.MLockedBytes.Internal.MLockedSizedBytes n)
instance GHC.TypeNats.KnownNat n => GHC.Classes.Eq (Cardano.Crypto.Libsodium.MLockedBytes.Internal.MLockedSizedBytes n)
instance GHC.TypeNats.KnownNat n => GHC.Classes.Ord (Cardano.Crypto.Libsodium.MLockedBytes.Internal.MLockedSizedBytes n)
instance GHC.TypeNats.KnownNat n => GHC.Show.Show (Cardano.Crypto.Libsodium.MLockedBytes.Internal.MLockedSizedBytes n)
instance Control.DeepSeq.NFData (Cardano.Crypto.Libsodium.MLockedBytes.Internal.MLockedSizedBytes n)

module Cardano.Crypto.Libsodium.MLockedBytes
data MLockedSizedBytes n

-- | Note: this doesn't need to allocate mlocked memory, but we do that for
--   consistency
mlsbZero :: forall n. KnownNat n => MLockedSizedBytes n
mlsbFromByteString :: forall n. KnownNat n => ByteString -> MLockedSizedBytes n
mlsbFromByteStringCheck :: forall n. KnownNat n => ByteString -> Maybe (MLockedSizedBytes n)

-- | <i>Note:</i> the resulting <a>ByteString</a> will still refer to
--   secure memory, but the types don't prevent it from be exposed.
mlsbToByteString :: forall n. KnownNat n => MLockedSizedBytes n -> ByteString
mlsbUseAsCPtr :: MLockedSizedBytes n -> (Ptr Word8 -> IO r) -> IO r
mlsbUseAsSizedPtr :: MLockedSizedBytes n -> (SizedPtr n -> IO r) -> IO r

-- | Calls <a>finalizeMLockedForeignPtr</a> on underlying pointer. This
--   function invalidates argument.
mlsbFinalize :: MLockedSizedBytes n -> IO ()

module Cardano.Crypto.Libsodium.Init
sodiumInit :: IO ()


-- | Initialization for the library's functionality
module Cardano.Crypto.Init

-- | Initialize all the functionality provided by this library. This should
--   be called at least once <i>before</i> you use anything this library
--   provides, in <tt>main</tt>.
--   
--   It is safe to call this multiple times, but isn't necessary.
--   
--   <h1>Note</h1>
--   
--   This includes a call to <a>sodiumInit</a>.
cryptoInit :: IO ()


-- | Implementation of the Blake2b hashing algorithm, with various sizes.
module Cardano.Crypto.Hash.Blake2b
data Blake2b_224
data Blake2b_256
blake2b_libsodium :: Int -> ByteString -> ByteString
instance Cardano.Crypto.Hash.Class.HashAlgorithm Cardano.Crypto.Hash.Blake2b.Blake2b_256
instance Cardano.Crypto.Hash.Class.HashAlgorithm Cardano.Crypto.Hash.Blake2b.Blake2b_224


-- | Implementation of short hashing algorithm, suitable for testing.
module Cardano.Crypto.Hash.Short
type ShortHash = Blake2bPrefix 8
data Blake2bPrefix (n :: Nat)
instance (GHC.TypeNats.KnownNat n, GHC.TypeNats.Internal.CmpNat n 33 GHC.Types.~ 'GHC.Types.LT) => Cardano.Crypto.Hash.Class.HashAlgorithm (Cardano.Crypto.Hash.Short.Blake2bPrefix n)


-- | Implementation of the SHA256 hashing algorithm.
module Cardano.Crypto.Hash.SHA256
data SHA256
instance Cardano.Crypto.Hash.Class.HashAlgorithm Cardano.Crypto.Hash.SHA256.SHA256


-- | Hashing functionality.
module Cardano.Crypto.Hash


-- | Mock implementations of verifiable random functions.
module Cardano.Crypto.VRF.Simple
data SimpleVRF
pointFromMaybe :: Maybe (Integer, Integer) -> Point
instance Control.DeepSeq.NFData Cardano.Crypto.VRF.Simple.Point
instance NoThunks.Class.NoThunks Cardano.Crypto.VRF.Simple.Point
instance GHC.Generics.Generic Cardano.Crypto.VRF.Simple.Point
instance GHC.Classes.Eq Cardano.Crypto.VRF.Simple.Point
instance Control.DeepSeq.NFData (Cardano.Crypto.VRF.Class.CertVRF Cardano.Crypto.VRF.Simple.SimpleVRF)
instance NoThunks.Class.NoThunks (Cardano.Crypto.VRF.Class.CertVRF Cardano.Crypto.VRF.Simple.SimpleVRF)
instance GHC.Generics.Generic (Cardano.Crypto.VRF.Class.CertVRF Cardano.Crypto.VRF.Simple.SimpleVRF)
instance GHC.Classes.Eq (Cardano.Crypto.VRF.Class.CertVRF Cardano.Crypto.VRF.Simple.SimpleVRF)
instance GHC.Show.Show (Cardano.Crypto.VRF.Class.CertVRF Cardano.Crypto.VRF.Simple.SimpleVRF)
instance Control.DeepSeq.NFData (Cardano.Crypto.VRF.Class.SignKeyVRF Cardano.Crypto.VRF.Simple.SimpleVRF)
instance NoThunks.Class.NoThunks (Cardano.Crypto.VRF.Class.SignKeyVRF Cardano.Crypto.VRF.Simple.SimpleVRF)
instance GHC.Generics.Generic (Cardano.Crypto.VRF.Class.SignKeyVRF Cardano.Crypto.VRF.Simple.SimpleVRF)
instance GHC.Classes.Eq (Cardano.Crypto.VRF.Class.SignKeyVRF Cardano.Crypto.VRF.Simple.SimpleVRF)
instance GHC.Show.Show (Cardano.Crypto.VRF.Class.SignKeyVRF Cardano.Crypto.VRF.Simple.SimpleVRF)
instance Control.DeepSeq.NFData (Cardano.Crypto.VRF.Class.VerKeyVRF Cardano.Crypto.VRF.Simple.SimpleVRF)
instance NoThunks.Class.NoThunks (Cardano.Crypto.VRF.Class.VerKeyVRF Cardano.Crypto.VRF.Simple.SimpleVRF)
instance GHC.Generics.Generic (Cardano.Crypto.VRF.Class.VerKeyVRF Cardano.Crypto.VRF.Simple.SimpleVRF)
instance GHC.Classes.Eq (Cardano.Crypto.VRF.Class.VerKeyVRF Cardano.Crypto.VRF.Simple.SimpleVRF)
instance GHC.Show.Show (Cardano.Crypto.VRF.Class.VerKeyVRF Cardano.Crypto.VRF.Simple.SimpleVRF)
instance GHC.Show.Show Cardano.Crypto.VRF.Simple.Point
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Crypto.VRF.Simple.Point
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Crypto.VRF.Simple.Point
instance GHC.Base.Semigroup Cardano.Crypto.VRF.Simple.Point
instance GHC.Base.Monoid Cardano.Crypto.VRF.Simple.Point
instance Cardano.Crypto.VRF.Class.VRFAlgorithm Cardano.Crypto.VRF.Simple.SimpleVRF
instance Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.VRF.Class.VerKeyVRF Cardano.Crypto.VRF.Simple.SimpleVRF)
instance Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.VRF.Class.VerKeyVRF Cardano.Crypto.VRF.Simple.SimpleVRF)
instance Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.VRF.Class.SignKeyVRF Cardano.Crypto.VRF.Simple.SimpleVRF)
instance Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.VRF.Class.SignKeyVRF Cardano.Crypto.VRF.Simple.SimpleVRF)
instance Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.VRF.Class.CertVRF Cardano.Crypto.VRF.Simple.SimpleVRF)
instance Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.VRF.Class.CertVRF Cardano.Crypto.VRF.Simple.SimpleVRF)


-- | Mock implementations of verifiable random functions.
module Cardano.Crypto.VRF.Mock
data MockVRF
data VerKeyVRF v :: Type
data SignKeyVRF v :: Type
instance NoThunks.Class.NoThunks (Cardano.Crypto.VRF.Class.CertVRF Cardano.Crypto.VRF.Mock.MockVRF)
instance GHC.Generics.Generic (Cardano.Crypto.VRF.Class.CertVRF Cardano.Crypto.VRF.Mock.MockVRF)
instance GHC.Classes.Ord (Cardano.Crypto.VRF.Class.CertVRF Cardano.Crypto.VRF.Mock.MockVRF)
instance GHC.Classes.Eq (Cardano.Crypto.VRF.Class.CertVRF Cardano.Crypto.VRF.Mock.MockVRF)
instance GHC.Show.Show (Cardano.Crypto.VRF.Class.CertVRF Cardano.Crypto.VRF.Mock.MockVRF)
instance NoThunks.Class.NoThunks (Cardano.Crypto.VRF.Class.SignKeyVRF Cardano.Crypto.VRF.Mock.MockVRF)
instance GHC.Generics.Generic (Cardano.Crypto.VRF.Class.SignKeyVRF Cardano.Crypto.VRF.Mock.MockVRF)
instance GHC.Classes.Ord (Cardano.Crypto.VRF.Class.SignKeyVRF Cardano.Crypto.VRF.Mock.MockVRF)
instance GHC.Classes.Eq (Cardano.Crypto.VRF.Class.SignKeyVRF Cardano.Crypto.VRF.Mock.MockVRF)
instance GHC.Show.Show (Cardano.Crypto.VRF.Class.SignKeyVRF Cardano.Crypto.VRF.Mock.MockVRF)
instance NoThunks.Class.NoThunks (Cardano.Crypto.VRF.Class.VerKeyVRF Cardano.Crypto.VRF.Mock.MockVRF)
instance GHC.Generics.Generic (Cardano.Crypto.VRF.Class.VerKeyVRF Cardano.Crypto.VRF.Mock.MockVRF)
instance GHC.Classes.Ord (Cardano.Crypto.VRF.Class.VerKeyVRF Cardano.Crypto.VRF.Mock.MockVRF)
instance GHC.Classes.Eq (Cardano.Crypto.VRF.Class.VerKeyVRF Cardano.Crypto.VRF.Mock.MockVRF)
instance GHC.Show.Show (Cardano.Crypto.VRF.Class.VerKeyVRF Cardano.Crypto.VRF.Mock.MockVRF)
instance Cardano.Crypto.VRF.Class.VRFAlgorithm Cardano.Crypto.VRF.Mock.MockVRF
instance Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.VRF.Class.VerKeyVRF Cardano.Crypto.VRF.Mock.MockVRF)
instance Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.VRF.Class.VerKeyVRF Cardano.Crypto.VRF.Mock.MockVRF)
instance Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.VRF.Class.SignKeyVRF Cardano.Crypto.VRF.Mock.MockVRF)
instance Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.VRF.Class.SignKeyVRF Cardano.Crypto.VRF.Mock.MockVRF)
instance Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.VRF.Class.CertVRF Cardano.Crypto.VRF.Mock.MockVRF)
instance Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.VRF.Class.CertVRF Cardano.Crypto.VRF.Mock.MockVRF)


-- | Verifiable random functions.
module Cardano.Crypto.VRF

module Cardano.Crypto.Libsodium.Hash
class HashAlgorithm h => SodiumHashAlgorithm h
naclDigestPtr :: SodiumHashAlgorithm h => proxy h -> Ptr a -> Int -> IO (MLockedSizedBytes (SizeHash h))
digestMLockedStorable :: forall h a proxy. (SodiumHashAlgorithm h, Storable a) => proxy h -> Ptr a -> MLockedSizedBytes (SizeHash h)
digestMLockedBS :: forall h proxy. SodiumHashAlgorithm h => proxy h -> ByteString -> MLockedSizedBytes (SizeHash h)
expandHash :: forall h proxy. SodiumHashAlgorithm h => proxy h -> MLockedSizedBytes (SizeHash h) -> (MLockedSizedBytes (SizeHash h), MLockedSizedBytes (SizeHash h))
instance Cardano.Crypto.Libsodium.Hash.SodiumHashAlgorithm Cardano.Crypto.Hash.SHA256.SHA256
instance Cardano.Crypto.Libsodium.Hash.SodiumHashAlgorithm Cardano.Crypto.Hash.Blake2b.Blake2b_256

module Cardano.Crypto.Libsodium
sodiumInit :: IO ()

-- | Foreign pointer to securely allocated memory.
data MLockedForeignPtr a
withMLockedForeignPtr :: forall a b. MLockedForeignPtr a -> (Ptr a -> IO b) -> IO b

-- | Allocate secure memory using <a>c_sodium_malloc</a>.
--   
--   <a>https://libsodium.gitbook.io/doc/memory_management</a>
allocMLockedForeignPtr :: Storable a => IO (MLockedForeignPtr a)
finalizeMLockedForeignPtr :: forall a. MLockedForeignPtr a -> IO ()

-- | <i>Deprecated: Don't leave traceMLockedForeignPtr in production</i>
traceMLockedForeignPtr :: (Storable a, Show a) => MLockedForeignPtr a -> IO ()
data MLockedSizedBytes n

-- | Note: this doesn't need to allocate mlocked memory, but we do that for
--   consistency
mlsbZero :: forall n. KnownNat n => MLockedSizedBytes n
mlsbFromByteString :: forall n. KnownNat n => ByteString -> MLockedSizedBytes n
mlsbFromByteStringCheck :: forall n. KnownNat n => ByteString -> Maybe (MLockedSizedBytes n)

-- | <i>Note:</i> the resulting <a>ByteString</a> will still refer to
--   secure memory, but the types don't prevent it from be exposed.
mlsbToByteString :: forall n. KnownNat n => MLockedSizedBytes n -> ByteString

-- | Calls <a>finalizeMLockedForeignPtr</a> on underlying pointer. This
--   function invalidates argument.
mlsbFinalize :: MLockedSizedBytes n -> IO ()
class HashAlgorithm h => SodiumHashAlgorithm h
naclDigestPtr :: SodiumHashAlgorithm h => proxy h -> Ptr a -> Int -> IO (MLockedSizedBytes (SizeHash h))
digestMLockedStorable :: forall h a proxy. (SodiumHashAlgorithm h, Storable a) => proxy h -> Ptr a -> MLockedSizedBytes (SizeHash h)
digestMLockedBS :: forall h proxy. SodiumHashAlgorithm h => proxy h -> ByteString -> MLockedSizedBytes (SizeHash h)
expandHash :: forall h proxy. SodiumHashAlgorithm h => proxy h -> MLockedSizedBytes (SizeHash h) -> (MLockedSizedBytes (SizeHash h), MLockedSizedBytes (SizeHash h))


-- | Mock key evolving signatures.
module Cardano.Crypto.KES.Mock
data MockKES (t :: Nat)
data VerKeyKES v :: Type
data SignKeyKES v :: Type
data SigKES v :: Type
instance NoThunks.Class.NoThunks (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.Mock.MockKES t))
instance GHC.Generics.Generic (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.Mock.MockKES t))
instance (TypeError ...) => GHC.Classes.Ord (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.Mock.MockKES t))
instance GHC.Classes.Eq (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.Mock.MockKES t))
instance GHC.Show.Show (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.Mock.MockKES t))
instance NoThunks.Class.NoThunks (Cardano.Crypto.KES.Class.SignKeyKES (Cardano.Crypto.KES.Mock.MockKES t))
instance GHC.Generics.Generic (Cardano.Crypto.KES.Class.SignKeyKES (Cardano.Crypto.KES.Mock.MockKES t))
instance GHC.Classes.Eq (Cardano.Crypto.KES.Class.SignKeyKES (Cardano.Crypto.KES.Mock.MockKES t))
instance GHC.Show.Show (Cardano.Crypto.KES.Class.SignKeyKES (Cardano.Crypto.KES.Mock.MockKES t))
instance NoThunks.Class.NoThunks (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.Mock.MockKES t))
instance GHC.Generics.Generic (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.Mock.MockKES t))
instance GHC.Classes.Eq (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.Mock.MockKES t))
instance GHC.Show.Show (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.Mock.MockKES t))
instance GHC.TypeNats.KnownNat t => Cardano.Crypto.KES.Class.KESAlgorithm (Cardano.Crypto.KES.Mock.MockKES t)
instance GHC.TypeNats.KnownNat t => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.Mock.MockKES t))
instance GHC.TypeNats.KnownNat t => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.Mock.MockKES t))
instance GHC.TypeNats.KnownNat t => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.KES.Class.SignKeyKES (Cardano.Crypto.KES.Mock.MockKES t))
instance GHC.TypeNats.KnownNat t => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.KES.Class.SignKeyKES (Cardano.Crypto.KES.Mock.MockKES t))
instance GHC.TypeNats.KnownNat t => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.Mock.MockKES t))
instance GHC.TypeNats.KnownNat t => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.Mock.MockKES t))


-- | Mock implementation of digital signatures.
module Cardano.Crypto.DSIGN.Mock
data MockDSIGN
data SignKeyDSIGN v :: Type
data VerKeyDSIGN v :: Type
data SigDSIGN v :: Type
mockSign :: SignableRepresentation a => a -> SignKeyDSIGN MockDSIGN -> SigDSIGN MockDSIGN
instance GHC.Show.Show Cardano.Crypto.DSIGN.Mock.VerificationFailure
instance Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.Mock.MockDSIGN)
instance NoThunks.Class.NoThunks (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.Mock.MockDSIGN)
instance GHC.Generics.Generic (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.Mock.MockDSIGN)
instance GHC.Classes.Ord (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.Mock.MockDSIGN)
instance GHC.Classes.Eq (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.Mock.MockDSIGN)
instance GHC.Show.Show (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.Mock.MockDSIGN)
instance Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.Mock.MockDSIGN)
instance NoThunks.Class.NoThunks (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.Mock.MockDSIGN)
instance GHC.Num.Num (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.Mock.MockDSIGN)
instance GHC.Generics.Generic (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.Mock.MockDSIGN)
instance GHC.Classes.Eq (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.Mock.MockDSIGN)
instance GHC.Show.Show (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.Mock.MockDSIGN)
instance Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.Mock.MockDSIGN)
instance NoThunks.Class.NoThunks (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.Mock.MockDSIGN)
instance GHC.Num.Num (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.Mock.MockDSIGN)
instance GHC.Generics.Generic (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.Mock.MockDSIGN)
instance GHC.Classes.Eq (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.Mock.MockDSIGN)
instance GHC.Show.Show (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.Mock.MockDSIGN)
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm Cardano.Crypto.DSIGN.Mock.MockDSIGN
instance Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.Mock.MockDSIGN)
instance Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.Mock.MockDSIGN)
instance Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.Mock.MockDSIGN)
instance Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.Mock.MockDSIGN)
instance Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.Mock.MockDSIGN)
instance Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.Mock.MockDSIGN)

module Cardano.Crypto.DSIGN.SchnorrSecp256k1
data SchnorrSecp256k1DSIGN
data VerKeyDSIGN v :: Type
data SignKeyDSIGN v :: Type
data SigDSIGN v :: Type
instance NoThunks.Class.NoThunks (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.SchnorrSecp256k1.SchnorrSecp256k1DSIGN)
instance GHC.Generics.Generic (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.SchnorrSecp256k1.SchnorrSecp256k1DSIGN)
instance GHC.Show.Show (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.SchnorrSecp256k1.SchnorrSecp256k1DSIGN)
instance Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.SchnorrSecp256k1.SchnorrSecp256k1DSIGN)
instance GHC.Classes.Eq (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.SchnorrSecp256k1.SchnorrSecp256k1DSIGN)
instance NoThunks.Class.NoThunks (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.SchnorrSecp256k1.SchnorrSecp256k1DSIGN)
instance GHC.Generics.Generic (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.SchnorrSecp256k1.SchnorrSecp256k1DSIGN)
instance GHC.Show.Show (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.SchnorrSecp256k1.SchnorrSecp256k1DSIGN)
instance Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.SchnorrSecp256k1.SchnorrSecp256k1DSIGN)
instance GHC.Classes.Eq (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.SchnorrSecp256k1.SchnorrSecp256k1DSIGN)
instance NoThunks.Class.NoThunks (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.SchnorrSecp256k1.SchnorrSecp256k1DSIGN)
instance GHC.Generics.Generic (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.SchnorrSecp256k1.SchnorrSecp256k1DSIGN)
instance GHC.Show.Show (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.SchnorrSecp256k1.SchnorrSecp256k1DSIGN)
instance Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.SchnorrSecp256k1.SchnorrSecp256k1DSIGN)
instance GHC.Classes.Eq (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.SchnorrSecp256k1.SchnorrSecp256k1DSIGN)
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm Cardano.Crypto.DSIGN.SchnorrSecp256k1.SchnorrSecp256k1DSIGN
instance Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.SchnorrSecp256k1.SchnorrSecp256k1DSIGN)
instance Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.SchnorrSecp256k1.SchnorrSecp256k1DSIGN)
instance Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.SchnorrSecp256k1.SchnorrSecp256k1DSIGN)
instance Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.SchnorrSecp256k1.SchnorrSecp256k1DSIGN)
instance Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.SchnorrSecp256k1.SchnorrSecp256k1DSIGN)
instance Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.SchnorrSecp256k1.SchnorrSecp256k1DSIGN)


-- | Ed25519 digital signatures.
module Cardano.Crypto.DSIGN.Ed25519
data Ed25519DSIGN
data SigDSIGN v :: Type
data SignKeyDSIGN v :: Type
data VerKeyDSIGN v :: Type
instance Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.Ed25519.Ed25519DSIGN)
instance GHC.Generics.Generic (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.Ed25519.Ed25519DSIGN)
instance GHC.Classes.Eq (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.Ed25519.Ed25519DSIGN)
instance GHC.Show.Show (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.Ed25519.Ed25519DSIGN)
instance Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.Ed25519.Ed25519DSIGN)
instance GHC.Generics.Generic (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.Ed25519.Ed25519DSIGN)
instance GHC.Classes.Eq (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.Ed25519.Ed25519DSIGN)
instance GHC.Show.Show (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.Ed25519.Ed25519DSIGN)
instance Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.Ed25519.Ed25519DSIGN)
instance GHC.Generics.Generic (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.Ed25519.Ed25519DSIGN)
instance GHC.Classes.Eq (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.Ed25519.Ed25519DSIGN)
instance GHC.Show.Show (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.Ed25519.Ed25519DSIGN)
instance NoThunks.Class.NoThunks (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.Ed25519.Ed25519DSIGN)
instance NoThunks.Class.NoThunks (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.Ed25519.Ed25519DSIGN)
instance NoThunks.Class.NoThunks (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.Ed25519.Ed25519DSIGN)
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm Cardano.Crypto.DSIGN.Ed25519.Ed25519DSIGN
instance Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.Ed25519.Ed25519DSIGN)
instance Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.Ed25519.Ed25519DSIGN)
instance Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.Ed25519.Ed25519DSIGN)
instance Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Crypto.DSIGN.Ed25519.Ed25519DSIGN)
instance Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.Ed25519.Ed25519DSIGN)
instance Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Crypto.DSIGN.Ed25519.Ed25519DSIGN)


-- | Digital signatures.
module Cardano.Crypto.DSIGN


-- | A standard signature scheme is a forward-secure signature scheme with
--   a single time period.
--   
--   This is the base case in the naive recursive implementation of the sum
--   composition from section 3 of the "MMM" paper:
--   
--   <i>Composition and Efficiency Tradeoffs for Forward-Secure Digital
--   Signatures</i> By Tal Malkin, Daniele Micciancio and Sara Miner
--   <a>https://eprint.iacr.org/2001/034</a>
--   
--   Specfically it states:
--   
--   <pre>
--   In order to unify the presentation, we regard standard signature schemes
--   as forward-seure signature schemes with one time period, namely T = 1.
--   </pre>
--   
--   So this module simply provides a wrapper <a>SingleKES</a> that turns
--   any <a>DSIGNAlgorithm</a> into an instance of <a>KESAlgorithm</a> with
--   a single period.
--   
--   See <a>Cardano.Crypto.KES.Sum</a> for the composition case.
module Cardano.Crypto.KES.Single

-- | A standard signature scheme is a forward-secure signature scheme with
--   a single time period.
data SingleKES d
data VerKeyKES v :: Type
data SignKeyKES v :: Type
data SigKES v :: Type
instance GHC.Generics.Generic (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.Single.SingleKES d))
instance GHC.Generics.Generic (Cardano.Crypto.KES.Class.SignKeyKES (Cardano.Crypto.KES.Single.SingleKES d))
instance GHC.Generics.Generic (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.Single.SingleKES d))
instance Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN d) => Control.DeepSeq.NFData (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.Single.SingleKES d))
instance Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN d) => Control.DeepSeq.NFData (Cardano.Crypto.KES.Class.SignKeyKES (Cardano.Crypto.KES.Single.SingleKES d))
instance Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.SigDSIGN d) => Control.DeepSeq.NFData (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.Single.SingleKES d))
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => GHC.Show.Show (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.Single.SingleKES d))
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => GHC.Classes.Eq (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.Single.SingleKES d))
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => GHC.Show.Show (Cardano.Crypto.KES.Class.SignKeyKES (Cardano.Crypto.KES.Single.SingleKES d))
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => GHC.Show.Show (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.Single.SingleKES d))
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => GHC.Classes.Eq (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.Single.SingleKES d))
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => Cardano.Crypto.KES.Class.KESAlgorithm (Cardano.Crypto.KES.Single.SingleKES d)
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => NoThunks.Class.NoThunks (Cardano.Crypto.KES.Class.SignKeyKES (Cardano.Crypto.KES.Single.SingleKES d))
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.Single.SingleKES d))
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.Single.SingleKES d))
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => NoThunks.Class.NoThunks (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.Single.SingleKES d))
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.KES.Class.SignKeyKES (Cardano.Crypto.KES.Single.SingleKES d))
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.KES.Class.SignKeyKES (Cardano.Crypto.KES.Single.SingleKES d))
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => NoThunks.Class.NoThunks (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.Single.SingleKES d))
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.Single.SingleKES d))
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.Single.SingleKES d))


-- | A key evolving signatures implementation.
--   
--   It is a naive recursive implementation of the sum composition from
--   section 3.1 of the "MMM" paper:
--   
--   <i>Composition and Efficiency Tradeoffs for Forward-Secure Digital
--   Signatures</i> By Tal Malkin, Daniele Micciancio and Sara Miner
--   <a>https://eprint.iacr.org/2001/034</a>
--   
--   Specfically we do the binary sum composition directly as in the paper,
--   and then use that in a nested/recursive fashion to construct a 7-level
--   deep binary tree version.
--   
--   This relies on <a>Cardano.Crypto.KES.Single</a> for the base case.
module Cardano.Crypto.KES.Sum

-- | A composition of two KES schemes to give a KES scheme with the sum of
--   the time periods.
--   
--   While we could do this with two independent KES schemes (i.e. two
--   types) we only need it for two instances of the same scheme, and we
--   save substantially on the size of the type and runtime dictionaries if
--   we do it this way, especially when we start applying it recursively.
data SumKES h d
data VerKeyKES v :: Type
data SignKeyKES v :: Type
data SigKES v :: Type

-- | A 2^0 period KES
type Sum0KES d = SingleKES d

-- | A 2^1 period KES
type Sum1KES d h = SumKES h (Sum0KES d)

-- | A 2^2 period KES
type Sum2KES d h = SumKES h (Sum1KES d h)

-- | A 2^3 period KES
type Sum3KES d h = SumKES h (Sum2KES d h)

-- | A 2^4 period KES
type Sum4KES d h = SumKES h (Sum3KES d h)

-- | A 2^5 period KES
type Sum5KES d h = SumKES h (Sum4KES d h)

-- | A 2^6 period KES
type Sum6KES d h = SumKES h (Sum5KES d h)

-- | A 2^7 period KES
type Sum7KES d h = SumKES h (Sum6KES d h)
instance GHC.Generics.Generic (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.Sum.SumKES h d))
instance GHC.Generics.Generic (Cardano.Crypto.KES.Class.SignKeyKES (Cardano.Crypto.KES.Sum.SumKES h d))
instance Control.DeepSeq.NFData (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.Sum.SumKES h d))
instance GHC.Generics.Generic (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.Sum.SumKES h d))
instance Cardano.Crypto.Hash.Class.HashAlgorithm h => GHC.Show.Show (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.Sum.SumKES h d))
instance GHC.Classes.Eq (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.Sum.SumKES h d))
instance Cardano.Crypto.KES.Class.KESAlgorithm d => GHC.Show.Show (Cardano.Crypto.KES.Class.SignKeyKES (Cardano.Crypto.KES.Sum.SumKES h d))
instance Cardano.Crypto.KES.Class.KESAlgorithm d => GHC.Show.Show (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.Sum.SumKES h d))
instance Cardano.Crypto.KES.Class.KESAlgorithm d => GHC.Classes.Eq (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.Sum.SumKES h d))
instance (Control.DeepSeq.NFData (Cardano.Crypto.KES.Class.SigKES d), Control.DeepSeq.NFData (Cardano.Crypto.KES.Class.VerKeyKES d)) => Control.DeepSeq.NFData (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.Sum.SumKES h d))
instance (Control.DeepSeq.NFData (Cardano.Crypto.KES.Class.SignKeyKES d), Control.DeepSeq.NFData (Cardano.Crypto.KES.Class.VerKeyKES d)) => Control.DeepSeq.NFData (Cardano.Crypto.KES.Class.SignKeyKES (Cardano.Crypto.KES.Sum.SumKES h d))
instance (Cardano.Crypto.KES.Class.KESAlgorithm d, Cardano.Crypto.Hash.Class.HashAlgorithm h) => Cardano.Crypto.KES.Class.KESAlgorithm (Cardano.Crypto.KES.Sum.SumKES h d)
instance Cardano.Crypto.KES.Class.KESAlgorithm d => NoThunks.Class.NoThunks (Cardano.Crypto.KES.Class.SignKeyKES (Cardano.Crypto.KES.Sum.SumKES h d))
instance (Cardano.Crypto.KES.Class.KESAlgorithm d, Cardano.Crypto.Hash.Class.HashAlgorithm h) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.Sum.SumKES h d))
instance (Cardano.Crypto.KES.Class.KESAlgorithm d, Cardano.Crypto.Hash.Class.HashAlgorithm h) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.Sum.SumKES h d))
instance Cardano.Crypto.KES.Class.KESAlgorithm d => NoThunks.Class.NoThunks (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.Sum.SumKES h d))
instance (Cardano.Crypto.KES.Class.KESAlgorithm d, Cardano.Crypto.Hash.Class.HashAlgorithm h) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.KES.Class.SignKeyKES (Cardano.Crypto.KES.Sum.SumKES h d))
instance (Cardano.Crypto.KES.Class.KESAlgorithm d, Cardano.Crypto.Hash.Class.HashAlgorithm h) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.KES.Class.SignKeyKES (Cardano.Crypto.KES.Sum.SumKES h d))
instance Cardano.Crypto.KES.Class.KESAlgorithm d => NoThunks.Class.NoThunks (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.Sum.SumKES h d))
instance (Cardano.Crypto.KES.Class.KESAlgorithm d, Cardano.Crypto.Hash.Class.HashAlgorithm h) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.Sum.SumKES h d))
instance (Cardano.Crypto.KES.Class.KESAlgorithm d, Cardano.Crypto.Hash.Class.HashAlgorithm h) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.Sum.SumKES h d))


-- | Mock key evolving signatures.
module Cardano.Crypto.KES.Simple
data SimpleKES d (t :: Nat)
data SigKES v :: Type
data SignKeyKES v :: Type

-- | See <a>VerKeySimpleKES</a>.
pattern SignKeySimpleKES :: Vector (SignKeyDSIGN d) -> SignKeyKES (SimpleKES d t)
instance GHC.Generics.Generic (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.Simple.SimpleKES d t))
instance GHC.Generics.Generic (Cardano.Crypto.KES.Class.SignKeyKES (Cardano.Crypto.KES.Simple.SimpleKES d t))
instance GHC.Generics.Generic (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.Simple.SimpleKES d t))
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => GHC.Show.Show (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.Simple.SimpleKES d t))
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => GHC.Show.Show (Cardano.Crypto.KES.Class.SignKeyKES (Cardano.Crypto.KES.Simple.SimpleKES d t))
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => GHC.Show.Show (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.Simple.SimpleKES d t))
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => GHC.Classes.Eq (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.Simple.SimpleKES d t))
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => GHC.Classes.Eq (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.Simple.SimpleKES d t))
instance (Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d, GHC.TypeNats.KnownNat t, GHC.TypeNats.KnownNat (Cardano.Crypto.DSIGN.Class.SeedSizeDSIGN d GHC.TypeNats.* t)) => Cardano.Crypto.KES.Class.KESAlgorithm (Cardano.Crypto.KES.Simple.SimpleKES d t)
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => NoThunks.Class.NoThunks (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.Simple.SimpleKES d t))
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => NoThunks.Class.NoThunks (Cardano.Crypto.KES.Class.SignKeyKES (Cardano.Crypto.KES.Simple.SimpleKES d t))
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => NoThunks.Class.NoThunks (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.Simple.SimpleKES d t))
instance (Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d, GHC.TypeNats.KnownNat t, GHC.TypeNats.KnownNat (Cardano.Crypto.DSIGN.Class.SeedSizeDSIGN d GHC.TypeNats.* t)) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.Simple.SimpleKES d t))
instance (Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d, GHC.TypeNats.KnownNat t, GHC.TypeNats.KnownNat (Cardano.Crypto.DSIGN.Class.SeedSizeDSIGN d GHC.TypeNats.* t)) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.Simple.SimpleKES d t))
instance (Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d, GHC.TypeNats.KnownNat t, GHC.TypeNats.KnownNat (Cardano.Crypto.DSIGN.Class.SeedSizeDSIGN d GHC.TypeNats.* t)) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.KES.Class.SignKeyKES (Cardano.Crypto.KES.Simple.SimpleKES d t))
instance (Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d, GHC.TypeNats.KnownNat t, GHC.TypeNats.KnownNat (Cardano.Crypto.DSIGN.Class.SeedSizeDSIGN d GHC.TypeNats.* t)) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.KES.Class.SignKeyKES (Cardano.Crypto.KES.Simple.SimpleKES d t))
instance (Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d, GHC.TypeNats.KnownNat t, GHC.TypeNats.KnownNat (Cardano.Crypto.DSIGN.Class.SeedSizeDSIGN d GHC.TypeNats.* t)) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.Simple.SimpleKES d t))
instance (Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d, GHC.TypeNats.KnownNat t, GHC.TypeNats.KnownNat (Cardano.Crypto.DSIGN.Class.SeedSizeDSIGN d GHC.TypeNats.* t)) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.Simple.SimpleKES d t))


-- | A standard signature scheme is a forward-secure signature scheme with
--   a single time period.
--   
--   This is the base case in the naive recursive implementation of the sum
--   composition from section 3 of the "MMM" paper:
--   
--   <i>Composition and Efficiency Tradeoffs for Forward-Secure Digital
--   Signatures</i> By Tal Malkin, Daniele Micciancio and Sara Miner
--   <a>https://eprint.iacr.org/2001/034</a>
--   
--   Specfically it states:
--   
--   <pre>
--   In order to unify the presentation, we regard standard signature schemes
--   as forward-seure signature schemes with one time period, namely T = 1.
--   </pre>
--   
--   So this module simply provides a wrapper <a>CompactSingleKES</a> that
--   turns any <a>DSIGNAlgorithm</a> into an instance of
--   <a>KESAlgorithm</a> with a single period.
--   
--   See <a>Cardano.Crypto.KES.CompactSum</a> for the composition case.
--   
--   Compared to the implementation in <a>Single</a>, this flavor stores
--   the VerKey used for signing along with the signature. The purpose of
--   this is so that we can avoid storing a pair of VerKeys at every branch
--   node, like <a>Sum</a> does. See <a>CompactSum</a> for more details.
module Cardano.Crypto.KES.CompactSingle

-- | A standard signature scheme is a forward-secure signature scheme with
--   a single time period.
data CompactSingleKES d
data VerKeyKES v :: Type
data SignKeyKES v :: Type
data SigKES v :: Type
instance GHC.Generics.Generic (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.CompactSingle.CompactSingleKES d))
instance GHC.Generics.Generic (Cardano.Crypto.KES.Class.SignKeyKES (Cardano.Crypto.KES.CompactSingle.CompactSingleKES d))
instance GHC.Generics.Generic (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.CompactSingle.CompactSingleKES d))
instance Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN d) => Control.DeepSeq.NFData (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.CompactSingle.CompactSingleKES d))
instance Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN d) => Control.DeepSeq.NFData (Cardano.Crypto.KES.Class.SignKeyKES (Cardano.Crypto.KES.CompactSingle.CompactSingleKES d))
instance (Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.SigDSIGN d), Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN d)) => Control.DeepSeq.NFData (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.CompactSingle.CompactSingleKES d))
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => GHC.Show.Show (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.CompactSingle.CompactSingleKES d))
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => GHC.Classes.Eq (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.CompactSingle.CompactSingleKES d))
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => GHC.Show.Show (Cardano.Crypto.KES.Class.SignKeyKES (Cardano.Crypto.KES.CompactSingle.CompactSingleKES d))
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => GHC.Show.Show (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.CompactSingle.CompactSingleKES d))
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => GHC.Classes.Eq (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.CompactSingle.CompactSingleKES d))
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => Cardano.Crypto.KES.Class.KESAlgorithm (Cardano.Crypto.KES.CompactSingle.CompactSingleKES d)
instance (Cardano.Crypto.KES.Class.KESAlgorithm (Cardano.Crypto.KES.CompactSingle.CompactSingleKES d), Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d) => Cardano.Crypto.KES.Class.OptimizedKESAlgorithm (Cardano.Crypto.KES.CompactSingle.CompactSingleKES d)
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => NoThunks.Class.NoThunks (Cardano.Crypto.KES.Class.SignKeyKES (Cardano.Crypto.KES.CompactSingle.CompactSingleKES d))
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.CompactSingle.CompactSingleKES d))
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.CompactSingle.CompactSingleKES d))
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => NoThunks.Class.NoThunks (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.CompactSingle.CompactSingleKES d))
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.KES.Class.SignKeyKES (Cardano.Crypto.KES.CompactSingle.CompactSingleKES d))
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.KES.Class.SignKeyKES (Cardano.Crypto.KES.CompactSingle.CompactSingleKES d))
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => NoThunks.Class.NoThunks (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.CompactSingle.CompactSingleKES d))
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.CompactSingle.CompactSingleKES d))
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm d => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.CompactSingle.CompactSingleKES d))


-- | A key evolving signatures implementation.
--   
--   It is a naive recursive implementation of the sum composition from
--   section 3.1 of the "MMM" paper:
--   
--   <i>Composition and Efficiency Tradeoffs for Forward-Secure Digital
--   Signatures</i> By Tal Malkin, Daniele Micciancio and Sara Miner
--   <a>https://eprint.iacr.org/2001/034</a>
--   
--   Specfically we do the binary sum composition directly as in the paper,
--   and then use that in a nested/recursive fashion to construct a 7-level
--   deep binary tree version.
--   
--   This relies on <a>Cardano.Crypto.KES.CompactSingle</a> for the base
--   case.
--   
--   Compared to the implementation in <a>Sum</a>, this flavor stores only
--   one VerKey in the branch node.
--   
--   Consider the following Merkle tree:
--   
--   <pre>
--         (A)
--        /   
--     (B)     (C)
--     <i>      </i> 
--   (D) (E) (F) (G)
--        ^
--    0   1   2   3
--   </pre>
--   
--   The caret points at leaf node E, indicating that the current period is
--   1. The signatures for leaf nodes D through G all contain their
--   respective DSIGN keys; the signature for branch node B however only
--   holds the signature for node E, and the VerKey for node D. It can
--   reconstruct its own VerKey from these two. The signature for branch
--   node A (the root node), then, only contains the VerKey for node C, and
--   the signature for node B. In other words, the number of individual
--   hashes to be stored equals the depth of the Merkle tree. Compare that
--   to the older, naive <tt>SumKES</tt>, where each branch node stores two
--   VerKeys: here, the number of keys to store is the depth of the tree
--   times two.
--   
--   Note that when we verify such a signature, we need to also compare the
--   ultimate VerKey at the root against the one passed in externally,
--   because all VerKeys until that point have been derived from the
--   (user-supplied, so untrusted) signature. But we only need to do this
--   once, at the tree root, so we split up the verification into two
--   parts: verifying a signature against its embedded VerKey, and
--   comparing that VerKey against the externally supplied target key.
module Cardano.Crypto.KES.CompactSum

-- | A composition of two KES schemes to give a KES scheme with the sum of
--   the time periods.
--   
--   While we could do this with two independent KES schemes (i.e. two
--   types) we only need it for two instances of the same scheme, and we
--   save substantially on the size of the type and runtime dictionaries if
--   we do it this way, especially when we start applying it recursively.
data CompactSumKES h d
data VerKeyKES v :: Type
data SignKeyKES v :: Type
data SigKES v :: Type

-- | A 2^0 period KES
type CompactSum0KES d = CompactSingleKES d

-- | A 2^1 period KES
type CompactSum1KES d h = CompactSumKES h (CompactSum0KES d)

-- | A 2^2 period KES
type CompactSum2KES d h = CompactSumKES h (CompactSum1KES d h)

-- | A 2^3 period KES
type CompactSum3KES d h = CompactSumKES h (CompactSum2KES d h)

-- | A 2^4 period KES
type CompactSum4KES d h = CompactSumKES h (CompactSum3KES d h)

-- | A 2^5 period KES
type CompactSum5KES d h = CompactSumKES h (CompactSum4KES d h)

-- | A 2^6 period KES
type CompactSum6KES d h = CompactSumKES h (CompactSum5KES d h)

-- | A 2^7 period KES
type CompactSum7KES d h = CompactSumKES h (CompactSum6KES d h)
instance GHC.Generics.Generic (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.CompactSum.CompactSumKES h d))
instance GHC.Generics.Generic (Cardano.Crypto.KES.Class.SignKeyKES (Cardano.Crypto.KES.CompactSum.CompactSumKES h d))
instance Control.DeepSeq.NFData (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.CompactSum.CompactSumKES h d))
instance GHC.Generics.Generic (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.CompactSum.CompactSumKES h d))
instance Cardano.Crypto.Hash.Class.HashAlgorithm h => GHC.Show.Show (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.CompactSum.CompactSumKES h d))
instance GHC.Classes.Eq (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.CompactSum.CompactSumKES h d))
instance Cardano.Crypto.KES.Class.KESAlgorithm d => GHC.Show.Show (Cardano.Crypto.KES.Class.SignKeyKES (Cardano.Crypto.KES.CompactSum.CompactSumKES h d))
instance Cardano.Crypto.KES.Class.KESAlgorithm d => GHC.Show.Show (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.CompactSum.CompactSumKES h d))
instance Cardano.Crypto.KES.Class.KESAlgorithm d => GHC.Classes.Eq (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.CompactSum.CompactSumKES h d))
instance (Control.DeepSeq.NFData (Cardano.Crypto.KES.Class.SigKES d), Control.DeepSeq.NFData (Cardano.Crypto.KES.Class.VerKeyKES d)) => Control.DeepSeq.NFData (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.CompactSum.CompactSumKES h d))
instance (Control.DeepSeq.NFData (Cardano.Crypto.KES.Class.SignKeyKES d), Control.DeepSeq.NFData (Cardano.Crypto.KES.Class.VerKeyKES d)) => Control.DeepSeq.NFData (Cardano.Crypto.KES.Class.SignKeyKES (Cardano.Crypto.KES.CompactSum.CompactSumKES h d))
instance (Cardano.Crypto.KES.Class.OptimizedKESAlgorithm d, Cardano.Crypto.Hash.Class.HashAlgorithm h) => Cardano.Crypto.KES.Class.KESAlgorithm (Cardano.Crypto.KES.CompactSum.CompactSumKES h d)
instance (Cardano.Crypto.KES.Class.KESAlgorithm (Cardano.Crypto.KES.CompactSum.CompactSumKES h d), Cardano.Crypto.KES.Class.OptimizedKESAlgorithm d, Cardano.Crypto.Hash.Class.HashAlgorithm h) => Cardano.Crypto.KES.Class.OptimizedKESAlgorithm (Cardano.Crypto.KES.CompactSum.CompactSumKES h d)
instance Cardano.Crypto.KES.Class.KESAlgorithm d => NoThunks.Class.NoThunks (Cardano.Crypto.KES.Class.SignKeyKES (Cardano.Crypto.KES.CompactSum.CompactSumKES h d))
instance (Cardano.Crypto.KES.Class.OptimizedKESAlgorithm d, Cardano.Crypto.Hash.Class.HashAlgorithm h) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.CompactSum.CompactSumKES h d))
instance (Cardano.Crypto.KES.Class.OptimizedKESAlgorithm d, Cardano.Crypto.Hash.Class.HashAlgorithm h) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.CompactSum.CompactSumKES h d))
instance Cardano.Crypto.KES.Class.OptimizedKESAlgorithm d => NoThunks.Class.NoThunks (Cardano.Crypto.KES.Class.VerKeyKES (Cardano.Crypto.KES.CompactSum.CompactSumKES h d))
instance (Cardano.Crypto.KES.Class.OptimizedKESAlgorithm d, Cardano.Crypto.Hash.Class.HashAlgorithm h) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.KES.Class.SignKeyKES (Cardano.Crypto.KES.CompactSum.CompactSumKES h d))
instance (Cardano.Crypto.KES.Class.OptimizedKESAlgorithm d, Cardano.Crypto.Hash.Class.HashAlgorithm h) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.KES.Class.SignKeyKES (Cardano.Crypto.KES.CompactSum.CompactSumKES h d))
instance Cardano.Crypto.KES.Class.KESAlgorithm d => NoThunks.Class.NoThunks (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.CompactSum.CompactSumKES h d))
instance (Cardano.Crypto.KES.Class.OptimizedKESAlgorithm d, Cardano.Crypto.Hash.Class.HashAlgorithm h) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.CompactSum.CompactSumKES h d))
instance (Cardano.Crypto.KES.Class.OptimizedKESAlgorithm d, Cardano.Crypto.Hash.Class.HashAlgorithm h) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.KES.Class.SigKES (Cardano.Crypto.KES.CompactSum.CompactSumKES h d))


-- | Key evolving signatures.
module Cardano.Crypto.KES
