-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | ListT done right
--   
--   A correct implementation of the list monad-transformer. Useful for
--   basic streaming.
@package list-t
@version 1.0.5.3

module ListT

-- | A proper implementation of the list monad-transformer. Useful for
--   streaming of monadic data structures.
--   
--   Since it has instances of <a>MonadPlus</a> and <a>Alternative</a>, you
--   can use general utilities packages like <a>"monadplus"</a> with it.
newtype ListT m a
ListT :: m (Maybe (a, ListT m a)) -> ListT m a

-- | Execute in the inner monad, getting the head and the tail. Returns
--   nothing if it's empty.
uncons :: ListT m a -> m (Maybe (a, ListT m a))

-- | Execute, getting the head. Returns nothing if it's empty.
head :: Monad m => ListT m a -> m (Maybe a)

-- | Execute, getting the tail. Returns nothing if it's empty.
tail :: Monad m => ListT m a -> m (Maybe (ListT m a))

-- | Execute, checking whether it's empty.
null :: Monad m => ListT m a -> m Bool

-- | Execute in the inner monad, using its <a>(&lt;|&gt;)</a> function on
--   each entry.
alternate :: (Alternative m, Monad m) => ListT m a -> m a

-- | Use a monad morphism to convert a <a>ListT</a> to a similar monad,
--   such as '[]'.
--   
--   A more efficient alternative to <tt><a>alternate</a> . <a>hoist</a>
--   f</tt>.
alternateHoisting :: (Monad n, Alternative n) => (forall a. m a -> n a) -> ListT m a -> n a

-- | Execute, applying a left fold.
fold :: Monad m => (r -> a -> m r) -> r -> ListT m a -> m r

-- | A version of <a>fold</a>, which allows early termination.
foldMaybe :: Monad m => (r -> a -> m (Maybe r)) -> r -> ListT m a -> m r

-- | Apply a left fold abstraction from the "foldl" package.
applyFoldM :: Monad m => FoldM m i o -> ListT m i -> m o

-- | Execute, folding to a list.
toList :: Monad m => ListT m a -> m [a]

-- | Execute, folding to a list in the reverse order. Performs more
--   efficiently than <a>toList</a>.
toReverseList :: Monad m => ListT m a -> m [a]

-- | Execute, traversing the stream with a side effect in the inner monad.
traverse_ :: Monad m => (a -> m ()) -> ListT m a -> m ()

-- | Execute, consuming a list of the specified length and returning the
--   remainder stream.
splitAt :: Monad m => Int -> ListT m a -> m ([a], ListT m a)

-- | Prepend an element.
cons :: Monad m => a -> ListT m a -> ListT m a

-- | Construct from any foldable.
fromFoldable :: (Monad m, Foldable f) => f a -> ListT m a

-- | Construct from an MVar, interpreting the value of Nothing as the end.
fromMVar :: MonadIO m => MVar (Maybe a) -> ListT m a

-- | Construct by unfolding a pure data structure.
unfold :: Monad m => (b -> Maybe (a, b)) -> b -> ListT m a

-- | Construct by unfolding a monadic data structure
--   
--   This is the most memory-efficient way to construct ListT where the
--   length depends on the inner monad.
unfoldM :: Monad m => (b -> m (Maybe (a, b))) -> b -> ListT m a

-- | Produce an infinite stream.
repeat :: Monad m => a -> ListT m a

-- | A transformation, which traverses the stream with an action in the
--   inner monad.
traverse :: Monad m => (a -> m b) -> ListT m a -> ListT m b

-- | A transformation, reproducing the behaviour of
--   <tt>Data.List.<a>take</a></tt>.
take :: Monad m => Int -> ListT m a -> ListT m a

-- | A transformation, reproducing the behaviour of
--   <tt>Data.List.<a>drop</a></tt>.
drop :: Monad m => Int -> ListT m a -> ListT m a

-- | A transformation, which slices a list into chunks of the specified
--   length.
slice :: Monad m => Int -> ListT m a -> ListT m [a]
instance GHC.Generics.Generic (ListT.ListT m a)
instance Data.Traversable.Traversable m => Data.Traversable.Traversable (ListT.ListT m)
instance Data.Foldable.Foldable m => Data.Foldable.Foldable (ListT.ListT m)
instance GHC.Show.Show (m (GHC.Maybe.Maybe (a, ListT.ListT m a))) => GHC.Show.Show (ListT.ListT m a)
instance GHC.Read.Read (m (GHC.Maybe.Maybe (a, ListT.ListT m a))) => GHC.Read.Read (ListT.ListT m a)
instance GHC.Classes.Eq (m (GHC.Maybe.Maybe (a, ListT.ListT m a))) => GHC.Classes.Eq (ListT.ListT m a)
instance GHC.Classes.Ord (m (GHC.Maybe.Maybe (a, ListT.ListT m a))) => GHC.Classes.Ord (ListT.ListT m a)
instance (Data.Typeable.Internal.Typeable m, Data.Typeable.Internal.Typeable a, Data.Data.Data (m (GHC.Maybe.Maybe (a, ListT.ListT m a)))) => Data.Data.Data (ListT.ListT m a)
instance Data.Functor.Classes.Eq1 m => Data.Functor.Classes.Eq1 (ListT.ListT m)
instance Data.Functor.Classes.Ord1 m => Data.Functor.Classes.Ord1 (ListT.ListT m)
instance Data.Functor.Classes.Show1 m => Data.Functor.Classes.Show1 (ListT.ListT m)
instance GHC.Base.Monad m => GHC.Base.Semigroup (ListT.ListT m a)
instance GHC.Base.Monad m => GHC.Base.Monoid (ListT.ListT m a)
instance GHC.Base.Functor m => GHC.Base.Functor (ListT.ListT m)
instance (GHC.Base.Monad m, GHC.Base.Functor m) => GHC.Base.Applicative (ListT.ListT m)
instance (GHC.Base.Monad m, GHC.Base.Functor m) => GHC.Base.Alternative (ListT.ListT m)
instance GHC.Base.Monad m => GHC.Base.Monad (ListT.ListT m)
instance GHC.Base.Monad m => Control.Monad.Fail.MonadFail (ListT.ListT m)
instance GHC.Base.Monad m => GHC.Base.MonadPlus (ListT.ListT m)
instance Control.Monad.Trans.Class.MonadTrans ListT.ListT
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (ListT.ListT m)
instance Control.Monad.Morph.MFunctor ListT.ListT
instance Control.Monad.Morph.MMonad ListT.ListT
instance Control.Monad.Base.MonadBase b m => Control.Monad.Base.MonadBase b (ListT.ListT m)
instance Control.Monad.Trans.Control.MonadBaseControl b m => Control.Monad.Trans.Control.MonadBaseControl b (ListT.ListT m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (ListT.ListT m)
instance Control.Monad.Reader.Class.MonadReader e m => Control.Monad.Reader.Class.MonadReader e (ListT.ListT m)
instance Control.Monad.State.Class.MonadState e m => Control.Monad.State.Class.MonadState e (ListT.ListT m)
instance GHC.Base.Monad m => Control.Monad.Logic.Class.MonadLogic (ListT.ListT m)
instance Control.Monad.Zip.MonadZip m => Control.Monad.Zip.MonadZip (ListT.ListT m)
