

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6.4.10. Datatype promotion &mdash; Glasgow Haskell Compiler 9.2.5 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.5 User&#39;s Guide"
          href="../_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6.4.11. Kind polymorphism" href="poly_kinds.html" />
    <link rel="prev" title="6.4.9. Type families" href="type_families.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="../runghc.html">4. Using runghc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">5. Using GHC</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../exts.html">6. Language extensions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">6.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="syntax.html">6.2. Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="import_export.html">6.3. Import and export</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="types.html">6.4. Types</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="nullary_types.html">6.4.1. Data types with no constructors</a></li>
<li class="toctree-l3"><a class="reference internal" href="datatype_contexts.html">6.4.2. Data type contexts</a></li>
<li class="toctree-l3"><a class="reference internal" href="infix_tycons.html">6.4.3. Infix type constructors, classes, and type variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="type_operators.html">6.4.4. Type operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="liberal_type_synonyms.html">6.4.5. Liberalised type synonyms</a></li>
<li class="toctree-l3"><a class="reference internal" href="existential_quantification.html">6.4.6. Existentially quantified data constructors</a></li>
<li class="toctree-l3"><a class="reference internal" href="gadt_syntax.html">6.4.7. Declaring data types with explicit constructor signatures</a></li>
<li class="toctree-l3"><a class="reference internal" href="gadt.html">6.4.8. Generalised Algebraic Data Types (GADTs)</a></li>
<li class="toctree-l3"><a class="reference internal" href="type_families.html">6.4.9. Type families</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">6.4.10. Datatype promotion</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#motivation">6.4.10.1. Motivation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#overview">6.4.10.2. Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#distinguishing-between-types-and-constructors">6.4.10.3. Distinguishing between types and constructors</a></li>
<li class="toctree-l4"><a class="reference internal" href="#type-level-literals">6.4.10.4. Type-level literals</a></li>
<li class="toctree-l4"><a class="reference internal" href="#promoted-list-and-tuple-types">6.4.10.5. Promoted list and tuple types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#promoting-existential-data-constructors">6.4.10.6. Promoting existential data constructors</a></li>
<li class="toctree-l4"><a class="reference internal" href="#constraints-in-kinds">6.4.10.7. Constraints in kinds</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="poly_kinds.html">6.4.11. Kind polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="levity_polymorphism.html">6.4.12. Levity polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="type_literals.html">6.4.13. Type-Level Literals</a></li>
<li class="toctree-l3"><a class="reference internal" href="type_applications.html">6.4.14. Visible type application</a></li>
<li class="toctree-l3"><a class="reference internal" href="rank_polymorphism.html">6.4.15. Arbitrary-rank polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="impredicative_types.html">6.4.16. Impredicative polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="linear_types.html">6.4.17. Linear types</a></li>
<li class="toctree-l3"><a class="reference internal" href="type_errors.html">6.4.18. Custom compile-time errors</a></li>
<li class="toctree-l3"><a class="reference internal" href="defer_type_errors.html">6.4.19. Deferring type errors to runtime</a></li>
<li class="toctree-l3"><a class="reference internal" href="roles.html">6.4.20. Roles</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="records.html">6.5. Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="deriving.html">6.6. Deriving mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="patterns.html">6.7. Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="typeclasses.html">6.8. Class and instances declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="literals.html">6.9. Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="constraints.html">6.10. Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="type_signatures.html">6.11. Type signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="bindings.html">6.12. Bindings and generalisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="template_haskell.html">6.13. Template Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="strict.html">6.14. Bang patterns and Strict Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel.html">6.15. Parallel and Concurrent</a></li>
<li class="toctree-l2"><a class="reference internal" href="primitives.html">6.16. Unboxed types and primitive operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffi.html">6.17. Foreign function interface (FFI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="safe_haskell.html">6.18. Safe Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc.html">6.19. Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="pragmas.html">6.20. Pragmas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../exts.html"><span class="section-number">6. </span>Language extensions</a> &raquo;</li>
        
          <li><a href="types.html"><span class="section-number">6.4. </span>Types</a> &raquo;</li>
        
      <li><span class="section-number">6.4.10. </span>Datatype promotion</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/exts/data_kinds.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="datatype-promotion">
<span id="promotion"></span><h1><span class="section-number">6.4.10. </span>Datatype promotion<a class="headerlink" href="#datatype-promotion" title="Permalink to this heading">¶</a></h1>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-DataKinds">
<span id="ghc-flag--XDataKinds"></span><span id="extension-NoDataKinds"></span><span class="sig-name descname"><span class="pre">DataKinds</span></span><a class="headerlink" href="#extension-DataKinds" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>7.4.1</p>
</dd>
</dl>
<p>Allow promotion of data types to kind level.</p>
</dd></dl>

<p>This section describes <em>data type promotion</em>, an extension to the kind
system that complements kind polymorphism. It is enabled by
<a class="reference internal" href="#extension-DataKinds"><code class="xref std std-extension docutils literal notranslate"><span class="pre">DataKinds</span></code></a>, and described in more detail in the paper <a class="reference external" href="http://dreixel.net/research/pdf/ghp.pdf">Giving
Haskell a Promotion</a>, which
appeared at TLDI 2012.</p>
<section id="motivation">
<h2><span class="section-number">6.4.10.1. </span>Motivation<a class="headerlink" href="#motivation" title="Permalink to this heading">¶</a></h2>
<p>Standard Haskell has a rich type language. Types classify terms and
serve to avoid many common programming mistakes. The kind language,
however, is relatively simple, distinguishing only regular types (kind
<code class="docutils literal notranslate"><span class="pre">Type</span></code>) and type constructors (e.g. kind <code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">-&gt;</span> <span class="pre">Type</span> <span class="pre">-&gt;</span> <span class="pre">Type</span></code>).
In particular when using advanced type
system features, such as type families (<a class="reference internal" href="type_families.html#type-families"><span class="std std-ref">Type families</span></a>) or GADTs
(<a class="reference internal" href="gadt.html#gadt"><span class="std std-ref">Generalised Algebraic Data Types (GADTs)</span></a>), this simple kind system is insufficient, and fails to
prevent simple errors. Consider the example of type-level natural
numbers, and length-indexed vectors:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Ze</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Su</span><span class="w"> </span><span class="n">n</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Vec</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">Nil</span><span class="w">  </span><span class="ow">::</span><span class="w"> </span><span class="kt">Vec</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kt">Ze</span><span class="w"></span>
<span class="w">  </span><span class="kt">Cons</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Vec</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Vec</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="kt">Su</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>The kind of <code class="docutils literal notranslate"><span class="pre">Vec</span></code> is <code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">-&gt;</span> <span class="pre">Type</span> <span class="pre">-&gt;</span> <span class="pre">Type</span></code>. This means that, e.g.,
<code class="docutils literal notranslate"><span class="pre">Vec</span> <span class="pre">Int</span> <span class="pre">Char</span></code> is a well-kinded type, even though this is not what we
intend when defining length-indexed vectors.</p>
<p>With <a class="reference internal" href="#extension-DataKinds"><code class="xref std std-extension docutils literal notranslate"><span class="pre">DataKinds</span></code></a>, the example above can then be rewritten to:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Nat</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Ze</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Su</span><span class="w"> </span><span class="kt">Nat</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Vec</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Nat</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">Nil</span><span class="w">  </span><span class="ow">::</span><span class="w"> </span><span class="kt">Vec</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kt">&#39;Ze</span><span class="w"></span>
<span class="w">  </span><span class="kt">Cons</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Vec</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Vec</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="kt">&#39;Su</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>With the improved kind of <code class="docutils literal notranslate"><span class="pre">Vec</span></code>, things like <code class="docutils literal notranslate"><span class="pre">Vec</span> <span class="pre">Int</span> <span class="pre">Char</span></code> are now
ill-kinded, and GHC will report an error.</p>
</section>
<section id="overview">
<h2><span class="section-number">6.4.10.2. </span>Overview<a class="headerlink" href="#overview" title="Permalink to this heading">¶</a></h2>
<p>With <a class="reference internal" href="#extension-DataKinds"><code class="xref std std-extension docutils literal notranslate"><span class="pre">DataKinds</span></code></a>, GHC automatically promotes every datatype
to be a kind and its (value) constructors to be type constructors. The
following types</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Nat</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Zero</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Succ</span><span class="w"> </span><span class="kt">Nat</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">List</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Nil</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Cons</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="kt">List</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Pair</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Pair</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Sum</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">L</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">R</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
</pre></div>
</div>
<p>give rise to the following kinds and type constructors (where promoted
constructors are prefixed by a tick <code class="docutils literal notranslate"><span class="pre">'</span></code>):</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Nat</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="kt">&#39;Zero</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Nat</span><span class="w"></span>
<span class="kt">&#39;Succ</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Nat</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Nat</span><span class="w"></span>

<span class="kt">List</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="kt">&#39;Nil</span><span class="w">  </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">k</span><span class="o">.</span><span class="w"> </span><span class="kt">List</span><span class="w"> </span><span class="n">k</span><span class="w"></span>
<span class="kt">&#39;Cons</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">k</span><span class="o">.</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">List</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">List</span><span class="w"> </span><span class="n">k</span><span class="w"></span>

<span class="kt">Pair</span><span class="w">  </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="kt">&#39;Pair</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">k1</span><span class="w"> </span><span class="n">k2</span><span class="o">.</span><span class="w"> </span><span class="n">k1</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k2</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Pair</span><span class="w"> </span><span class="n">k1</span><span class="w"> </span><span class="n">k2</span><span class="w"></span>

<span class="kt">Sum</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="kt">&#39;L</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k1</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Sum</span><span class="w"> </span><span class="n">k1</span><span class="w"> </span><span class="n">k2</span><span class="w"></span>
<span class="kt">&#39;R</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k2</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Sum</span><span class="w"> </span><span class="n">k1</span><span class="w"> </span><span class="n">k2</span><span class="w"></span>
</pre></div>
</div>
<p>Virtually all data constructors, even those with rich kinds, can be promoted.
There are only a couple of exceptions to this rule:</p>
<ul>
<li><p>Data family instance constructors cannot be promoted at the moment. GHC’s
type theory just isn’t up to the task of promoting data families, which
requires full dependent types.</p></li>
<li><p>Data constructors with contexts that contain non-equality constraints cannot
be promoted. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">MkFoo1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="kt">Int</span><span class="w">         </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="n">a</span><span class="w">    </span><span class="c1">-- promotable</span><span class="w"></span>
<span class="w">  </span><span class="kt">MkFoo2</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">~~</span><span class="w"> </span><span class="kt">Int</span><span class="w">        </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="n">a</span><span class="w">    </span><span class="c1">-- promotable</span><span class="w"></span>
<span class="w">  </span><span class="kt">MkFoo3</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Show</span><span class="w"> </span><span class="n">a</span><span class="w">          </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="n">a</span><span class="w">    </span><span class="c1">-- not promotable</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">MkFoo1</span></code> and <code class="docutils literal notranslate"><span class="pre">MkFoo2</span></code> can be promoted, since their contexts
only involve equality-oriented constraints. However, <code class="docutils literal notranslate"><span class="pre">MkFoo3</span></code>’s context
contains a non-equality constraint <code class="docutils literal notranslate"><span class="pre">Show</span> <span class="pre">a</span></code>, and thus cannot be promoted.</p>
</li>
</ul>
</section>
<section id="distinguishing-between-types-and-constructors">
<span id="promotion-syntax"></span><h2><span class="section-number">6.4.10.3. </span>Distinguishing between types and constructors<a class="headerlink" href="#distinguishing-between-types-and-constructors" title="Permalink to this heading">¶</a></h2>
<p>In the examples above, all promoted constructors are prefixed with a single
quote mark <code class="docutils literal notranslate"><span class="pre">'</span></code>. This mark tells GHC to look in the data constructor namespace
for a name, not the type (constructor) namespace. Consider</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">P</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkP</span><span class="w">    </span><span class="c1">-- 1</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Prom</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">P</span><span class="w">   </span><span class="c1">-- 2</span><span class="w"></span>
</pre></div>
</div>
<p>We can thus distinguish the type <code class="docutils literal notranslate"><span class="pre">P</span></code> (which has a constructor <code class="docutils literal notranslate"><span class="pre">MkP</span></code>)
from the promoted data constructor <code class="docutils literal notranslate"><span class="pre">'P</span></code> (of kind <code class="docutils literal notranslate"><span class="pre">Prom</span></code>).</p>
<p>As a convenience, GHC allows you to omit the quote mark when the name is
unambiguous. However, our experience has shown that the quote mark helps
to make code more readable and less error-prone. GHC thus supports
<a class="reference internal" href="../using-warnings.html#ghc-flag-Wunticked-promoted-constructors"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-Wunticked-promoted-constructors</span></code></a> that will warn you if you
use a promoted data constructor without a preceding quote mark.</p>
<p>Just as in the case of Template Haskell (<a class="reference internal" href="template_haskell.html#th-syntax"><span class="std std-ref">Syntax</span></a>), GHC gets
confused if you put a quote mark before a data constructor whose second
character is a quote mark. In this case, just put a space between the
promotion quote and the data constructor:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span>data T = A&#39;
type S = &#39;A&#39;   -- ERROR: looks like a character
type R = &#39; A&#39;  -- OK: promoted `A&#39;`
</pre></div>
</div>
</section>
<section id="type-level-literals">
<h2><span class="section-number">6.4.10.4. </span>Type-level literals<a class="headerlink" href="#type-level-literals" title="Permalink to this heading">¶</a></h2>
<p><a class="reference internal" href="#extension-DataKinds"><code class="xref std std-extension docutils literal notranslate"><span class="pre">DataKinds</span></code></a> enables the use of numeric and string literals at the
type level. For more information, see <a class="reference internal" href="type_literals.html#type-level-literals"><span class="std std-ref">Type-Level Literals</span></a>.</p>
</section>
<section id="promoted-list-and-tuple-types">
<span id="promoted-lists-and-tuples"></span><h2><span class="section-number">6.4.10.5. </span>Promoted list and tuple types<a class="headerlink" href="#promoted-list-and-tuple-types" title="Permalink to this heading">¶</a></h2>
<p>With <a class="reference internal" href="#extension-DataKinds"><code class="xref std std-extension docutils literal notranslate"><span class="pre">DataKinds</span></code></a>, Haskell’s list and tuple types are natively
promoted to kinds, and enjoy the same convenient syntax at the type
level, albeit prefixed with a quote:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">HList</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Type</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">HNil</span><span class="w">  </span><span class="ow">::</span><span class="w"> </span><span class="kt">HList</span><span class="w"> </span><span class="kt">&#39;[]</span><span class="w"></span>
<span class="w">  </span><span class="kt">HCons</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">HList</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">HList</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="kt">&#39;:</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Tuple</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Type</span><span class="p">,</span><span class="kt">Type</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">Tuple</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Tuple</span><span class="w"> </span><span class="kt">&#39;(a,b)</span><span class="w"></span>

<span class="nf">foo0</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">HList</span><span class="w"> </span><span class="kt">&#39;[]</span><span class="w"></span>
<span class="nf">foo0</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">HNil</span><span class="w"></span>

<span class="nf">foo1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">HList</span><span class="w"> </span><span class="kt">&#39;[Int]</span><span class="w"></span>
<span class="nf">foo1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">HCons</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="ow">::</span><span class="kt">Int</span><span class="p">)</span><span class="w"> </span><span class="kt">HNil</span><span class="w"></span>

<span class="nf">foo2</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">HList</span><span class="w"> </span><span class="p">[</span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="kt">Bool</span><span class="p">]</span><span class="w"></span>
<span class="nf">foo2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>For type-level lists of <em>two or more elements</em>, such as the signature of
<code class="docutils literal notranslate"><span class="pre">foo2</span></code> above, the quote may be omitted because the meaning is unambiguous. But
for lists of one or zero elements (as in <code class="docutils literal notranslate"><span class="pre">foo0</span></code> and <code class="docutils literal notranslate"><span class="pre">foo1</span></code>), the quote is
required, because the types <code class="docutils literal notranslate"><span class="pre">[]</span></code> and <code class="docutils literal notranslate"><span class="pre">[Int]</span></code> have existing meanings in
Haskell.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The declaration for <code class="docutils literal notranslate"><span class="pre">HCons</span></code> also requires <a class="reference internal" href="type_operators.html#extension-TypeOperators"><code class="xref std std-extension docutils literal notranslate"><span class="pre">TypeOperators</span></code></a>
because of infix type operator <code class="docutils literal notranslate"><span class="pre">(':)</span></code></p>
</div>
</section>
<section id="promoting-existential-data-constructors">
<span id="promotion-existentials"></span><h2><span class="section-number">6.4.10.6. </span>Promoting existential data constructors<a class="headerlink" href="#promoting-existential-data-constructors" title="Permalink to this heading">¶</a></h2>
<p>Note that we do promote existential data constructors that are otherwise
suitable. For example, consider the following:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Ex</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">MkEx</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Ex</span><span class="w"></span>
</pre></div>
</div>
<p>Both the type <code class="docutils literal notranslate"><span class="pre">Ex</span></code> and the data constructor <code class="docutils literal notranslate"><span class="pre">MkEx</span></code> get promoted,
with the polymorphic kind <code class="docutils literal notranslate"><span class="pre">'MkEx</span> <span class="pre">::</span> <span class="pre">forall</span> <span class="pre">k.</span> <span class="pre">k</span> <span class="pre">-&gt;</span> <span class="pre">Ex</span></code>. Somewhat
surprisingly, you can write a type family to extract the member of a
type-level existential:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">UnEx</span><span class="w"> </span><span class="p">(</span><span class="n">ex</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ex</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">UnEx</span><span class="w"> </span><span class="p">(</span><span class="kt">MkEx</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
</pre></div>
</div>
<p>At first blush, <code class="docutils literal notranslate"><span class="pre">UnEx</span></code> seems poorly-kinded. The return kind <code class="docutils literal notranslate"><span class="pre">k</span></code> is
not mentioned in the arguments, and thus it would seem that an instance
would have to return a member of <code class="docutils literal notranslate"><span class="pre">k</span></code> <em>for any</em> <code class="docutils literal notranslate"><span class="pre">k</span></code>. However, this is
not the case. The type family <code class="docutils literal notranslate"><span class="pre">UnEx</span></code> is a kind-indexed type family.
The return kind <code class="docutils literal notranslate"><span class="pre">k</span></code> is an implicit parameter to <code class="docutils literal notranslate"><span class="pre">UnEx</span></code>. The
elaborated definitions are as follows (where implicit parameters are
denoted by braces):</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">UnEx</span><span class="w"> </span><span class="p">{</span><span class="n">k</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="p">}</span><span class="w"> </span><span class="p">(</span><span class="n">ex</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ex</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">UnEx</span><span class="w"> </span><span class="p">{</span><span class="n">k</span><span class="p">}</span><span class="w"> </span><span class="p">(</span><span class="kt">MkEx</span><span class="w"> </span><span class="o">@</span><span class="n">k</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
</pre></div>
</div>
<p>Thus, the instance triggers only when the implicit parameter to <code class="docutils literal notranslate"><span class="pre">UnEx</span></code>
matches the implicit parameter to <code class="docutils literal notranslate"><span class="pre">MkEx</span></code>. Because <code class="docutils literal notranslate"><span class="pre">k</span></code> is actually a
parameter to <code class="docutils literal notranslate"><span class="pre">UnEx</span></code>, the kind is not escaping the existential, and the
above code is valid.</p>
<p>See also <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/7347">#7347</a>.</p>
</section>
<section id="constraints-in-kinds">
<span id="id1"></span><h2><span class="section-number">6.4.10.7. </span>Constraints in kinds<a class="headerlink" href="#constraints-in-kinds" title="Permalink to this heading">¶</a></h2>
<p>Kinds can (with <a class="reference internal" href="#extension-DataKinds"><code class="xref std std-extension docutils literal notranslate"><span class="pre">DataKinds</span></code></a>) contain type constraints. However,
only equality constraints are supported.</p>
<p>Here is an example of a constrained kind:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">IsTypeLit</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">IsTypeLit</span><span class="w"> </span><span class="kt">Nat</span><span class="w">    </span><span class="ow">=</span><span class="w"> </span><span class="kt">&#39;True</span><span class="w"></span>
<span class="w">  </span><span class="kt">IsTypeLit</span><span class="w"> </span><span class="kt">Symbol</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">&#39;True</span><span class="w"></span>
<span class="w">  </span><span class="kt">IsTypeLit</span><span class="w"> </span><span class="n">a</span><span class="w">      </span><span class="ow">=</span><span class="w"> </span><span class="kt">&#39;False</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="kt">IsTypeLit</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="kt">&#39;True</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">MkNat</span><span class="w">    </span><span class="ow">::</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="mi">42</span><span class="w"></span>
<span class="w">  </span><span class="kt">MkSymbol</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="s">&quot;Don&#39;t panic!&quot;</span><span class="w"></span>
</pre></div>
</div>
<p>The declarations above are accepted. However, if we add <code class="docutils literal notranslate"><span class="pre">MkOther</span> <span class="pre">::</span> <span class="pre">T</span> <span class="pre">Int</span></code>,
we get an error that the equality constraint is not satisfied; <code class="docutils literal notranslate"><span class="pre">Int</span></code> is
not a type literal. Note that explicitly quantifying with <code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">a</span></code> is
necessary in order for <code class="docutils literal notranslate"><span class="pre">T</span></code> to typecheck
(see <a class="reference internal" href="poly_kinds.html#complete-kind-signatures"><span class="std std-ref">Complete user-supplied kind signatures and polymorphic recursion</span></a>).</p>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="poly_kinds.html" class="btn btn-neutral float-right" title="6.4.11. Kind polymorphism" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="type_families.html" class="btn btn-neutral float-left" title="6.4.9. Type families" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>