

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6.2.3. The recursive do-notation &mdash; Glasgow Haskell Compiler 9.2.5 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.5 User&#39;s Guide"
          href="../_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6.2.4. Applicative do-notation" href="applicative_do.html" />
    <link rel="prev" title="6.2.2. The magic hash" href="magic_hash.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="../runghc.html">4. Using runghc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">5. Using GHC</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../exts.html">6. Language extensions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">6.1. Introduction</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="syntax.html">6.2. Syntax</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="unicode_syntax.html">6.2.1. Unicode syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="magic_hash.html">6.2.2. The magic hash</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">6.2.3. The recursive do-notation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#recursive-binding-groups">6.2.3.1. Recursive binding groups</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-mdo-notation">6.2.3.2. The <code class="docutils literal notranslate"><span class="pre">mdo</span></code> notation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="applicative_do.html">6.2.4. Applicative do-notation</a></li>
<li class="toctree-l3"><a class="reference internal" href="qualified_do.html">6.2.5. Qualified do-notation</a></li>
<li class="toctree-l3"><a class="reference internal" href="parallel_list_comprehensions.html">6.2.6. Parallel List Comprehensions</a></li>
<li class="toctree-l3"><a class="reference internal" href="generalised_list_comprehensions.html">6.2.7. Generalised (SQL-like) List Comprehensions</a></li>
<li class="toctree-l3"><a class="reference internal" href="monad_comprehensions.html">6.2.8. Monad comprehensions</a></li>
<li class="toctree-l3"><a class="reference internal" href="overloaded_lists.html">6.2.9. Overloaded lists</a></li>
<li class="toctree-l3"><a class="reference internal" href="rebindable_syntax.html">6.2.10. Rebindable syntax and the implicit Prelude import</a></li>
<li class="toctree-l3"><a class="reference internal" href="rebindable_syntax.html#postfix-operators">6.2.11. Postfix operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="tuple_sections.html">6.2.12. Tuple sections</a></li>
<li class="toctree-l3"><a class="reference internal" href="lambda_case.html">6.2.13. Lambda-case</a></li>
<li class="toctree-l3"><a class="reference internal" href="empty_case.html">6.2.14. Empty case alternatives</a></li>
<li class="toctree-l3"><a class="reference internal" href="multiway_if.html">6.2.15. Multi-way if-expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="local_fixity_decls.html">6.2.16. Local Fixity Declarations</a></li>
<li class="toctree-l3"><a class="reference internal" href="block_arguments.html">6.2.17. More liberal syntax for function arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="typed_holes.html">6.2.18. Typed Holes</a></li>
<li class="toctree-l3"><a class="reference internal" href="arrows.html">6.2.19. Arrow notation</a></li>
<li class="toctree-l3"><a class="reference internal" href="lexical_negation.html">6.2.20. Lexical negation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="import_export.html">6.3. Import and export</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">6.4. Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="records.html">6.5. Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="deriving.html">6.6. Deriving mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="patterns.html">6.7. Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="typeclasses.html">6.8. Class and instances declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="literals.html">6.9. Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="constraints.html">6.10. Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="type_signatures.html">6.11. Type signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="bindings.html">6.12. Bindings and generalisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="template_haskell.html">6.13. Template Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="strict.html">6.14. Bang patterns and Strict Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel.html">6.15. Parallel and Concurrent</a></li>
<li class="toctree-l2"><a class="reference internal" href="primitives.html">6.16. Unboxed types and primitive operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffi.html">6.17. Foreign function interface (FFI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="safe_haskell.html">6.18. Safe Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc.html">6.19. Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="pragmas.html">6.20. Pragmas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../editing-guide.html">16. Care and feeding of your GHC Userâ€™s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../exts.html"><span class="section-number">6. </span>Language extensions</a> &raquo;</li>
        
          <li><a href="syntax.html"><span class="section-number">6.2. </span>Syntax</a> &raquo;</li>
        
      <li><span class="section-number">6.2.3. </span>The recursive do-notation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/exts/recursive_do.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="the-recursive-do-notation">
<span id="recursive-do-notation"></span><h1><span class="section-number">6.2.3. </span>The recursive do-notation<a class="headerlink" href="#the-recursive-do-notation" title="Permalink to this heading">Â¶</a></h1>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-RecursiveDo">
<span id="ghc-flag--XRecursiveDo"></span><span id="extension-NoRecursiveDo"></span><span class="sig-name descname"><span class="pre">RecursiveDo</span></span><a class="headerlink" href="#extension-RecursiveDo" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>6.8.1</p>
</dd>
</dl>
<p>Allow the use of recursive <code class="docutils literal notranslate"><span class="pre">do</span></code> notation.</p>
</dd></dl>

<p>The do-notation of Haskell 98 does not allow <em>recursive bindings</em>, that
is, the variables bound in a do-expression are visible only in the
textually following code block. Compare this to a let-expression, where
bound variables are visible in the entire binding group.</p>
<p>It turns out that such recursive bindings do indeed make sense for a
variety of monads, but not all. In particular, recursion in this sense
requires a fixed-point operator for the underlying monad, captured by
the <code class="docutils literal notranslate"><span class="pre">mfix</span></code> method of the <code class="docutils literal notranslate"><span class="pre">MonadFix</span></code> class, defined in
<code class="docutils literal notranslate"><span class="pre">Control.Monad.Fix</span></code> as follows:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">MonadFix</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">   </span><span class="n">mfix</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>Haskellâ€™s <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>, <code class="docutils literal notranslate"><span class="pre">[]</span></code> (list), <code class="docutils literal notranslate"><span class="pre">ST</span></code> (both strict and lazy
versions), <code class="docutils literal notranslate"><span class="pre">IO</span></code>, and many other monads have <code class="docutils literal notranslate"><span class="pre">MonadFix</span></code> instances. On
the negative side, the continuation monad, with the signature
<code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">r)</span> <span class="pre">-&gt;</span> <span class="pre">r</span></code>, does not.</p>
<p>For monads that do belong to the <code class="docutils literal notranslate"><span class="pre">MonadFix</span></code> class, GHC provides an
extended version of the do-notation that allows recursive bindings. The
<a class="reference internal" href="#extension-RecursiveDo"><code class="xref std std-extension docutils literal notranslate"><span class="pre">RecursiveDo</span></code></a> (language pragma: <code class="docutils literal notranslate"><span class="pre">RecursiveDo</span></code>) provides the
necessary syntactic support, introducing the keywords <code class="docutils literal notranslate"><span class="pre">mdo</span></code> and
<code class="docutils literal notranslate"><span class="pre">rec</span></code> for higher and lower levels of the notation respectively. Unlike
bindings in a <code class="docutils literal notranslate"><span class="pre">do</span></code> expression, those introduced by <code class="docutils literal notranslate"><span class="pre">mdo</span></code> and <code class="docutils literal notranslate"><span class="pre">rec</span></code>
are recursively defined, much like in an ordinary let-expression. Due to
the new keyword <code class="docutils literal notranslate"><span class="pre">mdo</span></code>, we also call this notation the <em>mdo-notation</em>.</p>
<p>Here is a simple (albeit contrived) example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE RecursiveDo #-}</span><span class="w"></span>
<span class="nf">justOnes</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mdo</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"></span>
<span class="w">               </span><span class="p">;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">map</span><span class="w"> </span><span class="n">negate</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>or equivalently</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE RecursiveDo #-}</span><span class="w"></span>
<span class="nf">justOnes</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">rec</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">              </span><span class="p">;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">map</span><span class="w"> </span><span class="n">negate</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>As you can guess <code class="docutils literal notranslate"><span class="pre">justOnes</span></code> will evaluate to <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">[-1,-1,-1,...</span></code>.</p>
<p>GHCâ€™s implementation the mdo-notation closely follows the original
translation as described in the paper <a class="reference external" href="http://leventerkok.github.io/papers/recdo.pdf">A recursive do for
Haskell</a>, which
in turn is based on the work <a class="reference external" href="http://leventerkok.github.io/papers/erkok-thesis.pdf">Value Recursion in Monadic
Computations</a>.
Furthermore, GHC extends the syntax described in the former paper with a
lower level syntax flagged by the <code class="docutils literal notranslate"><span class="pre">rec</span></code> keyword, as we describe next.</p>
<section id="recursive-binding-groups">
<h2><span class="section-number">6.2.3.1. </span>Recursive binding groups<a class="headerlink" href="#recursive-binding-groups" title="Permalink to this heading">Â¶</a></h2>
<p>The extension <a class="reference internal" href="#extension-RecursiveDo"><code class="xref std std-extension docutils literal notranslate"><span class="pre">RecursiveDo</span></code></a> also introduces a new keyword <code class="docutils literal notranslate"><span class="pre">rec</span></code>, which
wraps a mutually-recursive group of monadic statements inside a <code class="docutils literal notranslate"><span class="pre">do</span></code>
expression, producing a single statement. Similar to a <code class="docutils literal notranslate"><span class="pre">let</span></code> statement
inside a <code class="docutils literal notranslate"><span class="pre">do</span></code>, variables bound in the <code class="docutils literal notranslate"><span class="pre">rec</span></code> are visible throughout
the <code class="docutils literal notranslate"><span class="pre">rec</span></code> group, and below it. For example, compare</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">do</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">getChar</span><span class="w">            </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">getChar</span><span class="w"></span>
<span class="w">   </span><span class="p">;</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">r1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">r2</span><span class="w">          </span><span class="p">;</span><span class="w"> </span><span class="n">rec</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">r1</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">r2</span><span class="w"></span>
<span class="w">   </span><span class="p">;</span><span class="w">     </span><span class="p">;</span><span class="w"> </span><span class="n">r2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">r1</span><span class="w"> </span><span class="p">}</span><span class="w">          </span><span class="p">;</span><span class="w">     </span><span class="p">;</span><span class="w"> </span><span class="n">r2</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">r1</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="p">;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">r1</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">r2</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w">        </span><span class="p">;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">r1</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">r2</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In both cases, <code class="docutils literal notranslate"><span class="pre">r1</span></code> and <code class="docutils literal notranslate"><span class="pre">r2</span></code> are available both throughout the
<code class="docutils literal notranslate"><span class="pre">let</span></code> or <code class="docutils literal notranslate"><span class="pre">rec</span></code> block, and in the statements that follow it. The
difference is that <code class="docutils literal notranslate"><span class="pre">let</span></code> is non-monadic, while <code class="docutils literal notranslate"><span class="pre">rec</span></code> is monadic. (In
Haskell <code class="docutils literal notranslate"><span class="pre">let</span></code> is really <code class="docutils literal notranslate"><span class="pre">letrec</span></code>, of course.)</p>
<p>The semantics of <code class="docutils literal notranslate"><span class="pre">rec</span></code> is fairly straightforward. Whenever GHC finds a
<code class="docutils literal notranslate"><span class="pre">rec</span></code> group, it will compute its set of bound variables, and will
introduce an appropriate call to the underlying monadic value-recursion
operator <code class="docutils literal notranslate"><span class="pre">mfix</span></code>, belonging to the <code class="docutils literal notranslate"><span class="pre">MonadFix</span></code> class. Here is an
example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">rec</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">c</span><span class="w">     </span><span class="o">===&gt;</span><span class="w">    </span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mfix</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
<span class="w">    </span><span class="p">;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">}</span><span class="w">                                         </span><span class="p">;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">                                                           </span><span class="p">;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">})</span><span class="w"></span>
</pre></div>
</div>
<p>As usual, the meta-variables <code class="docutils literal notranslate"><span class="pre">b</span></code>, <code class="docutils literal notranslate"><span class="pre">c</span></code> etc., can be arbitrary
patterns. In general, the statement <code class="docutils literal notranslate"><span class="pre">rec</span> <span class="pre">ss</span></code> is desugared to the
statement</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">vs</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mfix</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="o">~</span><span class="n">vs</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ss</span><span class="p">;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="n">vs</span><span class="w"> </span><span class="p">})</span><span class="w"></span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">vs</span></code> is a tuple of the variables bound by <code class="docutils literal notranslate"><span class="pre">ss</span></code>.</p>
<p>Note in particular that the translation for a <code class="docutils literal notranslate"><span class="pre">rec</span></code> block only
involves wrapping a call to <code class="docutils literal notranslate"><span class="pre">mfix</span></code>: it performs no other analysis on
the bindings. The latter is the task for the <code class="docutils literal notranslate"><span class="pre">mdo</span></code> notation, which is
described next.</p>
</section>
<section id="the-mdo-notation">
<h2><span class="section-number">6.2.3.2. </span>The <code class="docutils literal notranslate"><span class="pre">mdo</span></code> notation<a class="headerlink" href="#the-mdo-notation" title="Permalink to this heading">Â¶</a></h2>
<p>A <code class="docutils literal notranslate"><span class="pre">rec</span></code>-block tells the compiler where precisely the recursive knot
should be tied. It turns out that the placement of the recursive knots
can be rather delicate: in particular, we would like the knots to be
wrapped around as minimal groups as possible. This process is known as
<em>segmentation</em>, and is described in detail in Section 3.2 of <a class="reference external" href="http://leventerkok.github.io/papers/recdo.pdf">A
recursive do for
Haskell</a>.
Segmentation improves polymorphism and reduces the size of the recursive
knot. Most importantly, it avoids unnecessary interference caused by a
fundamental issue with the so-called <em>right-shrinking</em> axiom for monadic
recursion. In brief, most monads of interest (IO, strict state, etc.) do
<em>not</em> have recursion operators that satisfy this axiom, and thus not
performing segmentation can cause unnecessary interference, changing the
termination behavior of the resulting translation. (Details can be found
in Sections 3.1 and 7.2.2 of <a class="reference external" href="http://leventerkok.github.io/papers/erkok-thesis.pdf">Value Recursion in Monadic
Computations</a>.)</p>
<p>The <code class="docutils literal notranslate"><span class="pre">mdo</span></code> notation removes the burden of placing explicit <code class="docutils literal notranslate"><span class="pre">rec</span></code>
blocks in the code. Unlike an ordinary <code class="docutils literal notranslate"><span class="pre">do</span></code> expression, in which
variables bound by statements are only in scope for later statements,
variables bound in an <code class="docutils literal notranslate"><span class="pre">mdo</span></code> expression are in scope for all statements
of the expression. The compiler then automatically identifies minimal
mutually recursively dependent segments of statements, treating them as
if the user had wrapped a <code class="docutils literal notranslate"><span class="pre">rec</span></code> qualifier around them.</p>
<p>The definition is syntactic:</p>
<ul class="simple">
<li><p>A generator âŸ¨gâŸ© <em>depends</em> on a textually following generator âŸ¨gâ€™âŸ©, if</p>
<ul>
<li><p>âŸ¨gâ€™âŸ© defines a variable that is used by âŸ¨gâŸ©, or</p></li>
<li><p>âŸ¨gâ€™âŸ© textually appears between âŸ¨gâŸ© and âŸ¨gâ€™â€™âŸ©, where âŸ¨gâŸ© depends on
âŸ¨gâ€™â€™âŸ©.</p></li>
</ul>
</li>
<li><p>A <em>segment</em> of a given <code class="docutils literal notranslate"><span class="pre">mdo</span></code>-expression is a minimal sequence of
generators such that no generator of the sequence depends on an
outside generator. As a special case, although it is not a generator,
the final expression in an <code class="docutils literal notranslate"><span class="pre">mdo</span></code>-expression is considered to form a
segment by itself.</p></li>
</ul>
<p>Segments in this sense are related to <em>strongly-connected components</em>
analysis, with the exception that bindings in a segment cannot be
reordered and must be contiguous.</p>
<p>Here is an example <code class="docutils literal notranslate"><span class="pre">mdo</span></code>-expression, and its translation to <code class="docutils literal notranslate"><span class="pre">rec</span></code>
blocks:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mdo</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">getChar</span><span class="w">      </span><span class="o">===&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">getChar</span><span class="w"></span>
<span class="w">    </span><span class="p">;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">c</span><span class="w">                </span><span class="p">;</span><span class="w"> </span><span class="n">rec</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
<span class="w">    </span><span class="p">;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">a</span><span class="w">                </span><span class="p">;</span><span class="w">     </span><span class="p">;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">;</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w">                </span><span class="p">;</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="w">    </span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">e</span><span class="w">                </span><span class="p">;</span><span class="w"> </span><span class="n">rec</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">e</span><span class="w"></span>
<span class="w">    </span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">z</span><span class="w">                </span><span class="p">;</span><span class="w">     </span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">;</span><span class="w"> </span><span class="n">putChar</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="p">}</span><span class="w">               </span><span class="p">;</span><span class="w"> </span><span class="n">putChar</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Note that a given <code class="docutils literal notranslate"><span class="pre">mdo</span></code> expression can cause the creation of multiple
<code class="docutils literal notranslate"><span class="pre">rec</span></code> blocks. If there are no recursive dependencies, <code class="docutils literal notranslate"><span class="pre">mdo</span></code> will
introduce no <code class="docutils literal notranslate"><span class="pre">rec</span></code> blocks. In this latter case an <code class="docutils literal notranslate"><span class="pre">mdo</span></code> expression
is precisely the same as a <code class="docutils literal notranslate"><span class="pre">do</span></code> expression, as one would expect.</p>
<p>In summary, given an <code class="docutils literal notranslate"><span class="pre">mdo</span></code> expression, GHC first performs
segmentation, introducing <code class="docutils literal notranslate"><span class="pre">rec</span></code> blocks to wrap over minimal recursive
groups. Then, each resulting <code class="docutils literal notranslate"><span class="pre">rec</span></code> is desugared, using a call to
<code class="docutils literal notranslate"><span class="pre">Control.Monad.Fix.mfix</span></code> as described in the previous section. The
original <code class="docutils literal notranslate"><span class="pre">mdo</span></code>-expression typechecks exactly when the desugared
version would do so.</p>
<p>Here are some other important points in using the recursive-do notation:</p>
<ul class="simple">
<li><p>It is enabled with the extension <a class="reference internal" href="#extension-RecursiveDo"><code class="xref std std-extension docutils literal notranslate"><span class="pre">RecursiveDo</span></code></a>, or the
<code class="docutils literal notranslate"><span class="pre">LANGUAGE</span> <span class="pre">RecursiveDo</span></code> pragma. (The same extension enables both
<code class="docutils literal notranslate"><span class="pre">mdo</span></code>-notation, and the use of <code class="docutils literal notranslate"><span class="pre">rec</span></code> blocks inside <code class="docutils literal notranslate"><span class="pre">do</span></code>
expressions.)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rec</span></code> blocks can also be used inside <code class="docutils literal notranslate"><span class="pre">mdo</span></code>-expressions, which
will be treated as a single statement. However, it is good style to
either use <code class="docutils literal notranslate"><span class="pre">mdo</span></code> or <code class="docutils literal notranslate"><span class="pre">rec</span></code> blocks in a single expression.</p></li>
<li><p>If recursive bindings are required for a monad, then that monad must
be declared an instance of the <code class="docutils literal notranslate"><span class="pre">MonadFix</span></code> class.</p></li>
<li><p>The following instances of <code class="docutils literal notranslate"><span class="pre">MonadFix</span></code> are automatically provided:
List, Maybe, IO. Furthermore, the <code class="docutils literal notranslate"><span class="pre">Control.Monad.ST</span></code> and
<code class="docutils literal notranslate"><span class="pre">Control.Monad.ST.Lazy</span></code> modules provide the instances of the
<code class="docutils literal notranslate"><span class="pre">MonadFix</span></code> class for Haskellâ€™s internal state monad (strict and
lazy, respectively).</p></li>
<li><p>Like <code class="docutils literal notranslate"><span class="pre">let</span></code> and <code class="docutils literal notranslate"><span class="pre">where</span></code> bindings, name shadowing is not allowed
within an <code class="docutils literal notranslate"><span class="pre">mdo</span></code>-expression or a <code class="docutils literal notranslate"><span class="pre">rec</span></code>-block; that is, all the
names bound in a single <code class="docutils literal notranslate"><span class="pre">rec</span></code> must be distinct. (GHC will complain
if this is not the case.)</p></li>
</ul>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="applicative_do.html" class="btn btn-neutral float-right" title="6.2.4. Applicative do-notation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="magic_hash.html" class="btn btn-neutral float-left" title="6.2.2. The magic hash" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>