

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6.7.2. View patterns &mdash; Glasgow Haskell Compiler 9.2.5 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.5 User&#39;s Guide"
          href="../_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6.7.3. n+k patterns" href="nk_patterns.html" />
    <link rel="prev" title="6.7.1. Pattern guards" href="pattern_guards.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="../runghc.html">4. Using runghc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">5. Using GHC</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../exts.html">6. Language extensions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">6.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="syntax.html">6.2. Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="import_export.html">6.3. Import and export</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">6.4. Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="records.html">6.5. Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="deriving.html">6.6. Deriving mechanism</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="patterns.html">6.7. Patterns</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="pattern_guards.html">6.7.1. Pattern guards</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">6.7.2. View patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="nk_patterns.html">6.7.3. n+k patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="pattern_synonyms.html">6.7.4. Pattern synonyms</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="typeclasses.html">6.8. Class and instances declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="literals.html">6.9. Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="constraints.html">6.10. Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="type_signatures.html">6.11. Type signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="bindings.html">6.12. Bindings and generalisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="template_haskell.html">6.13. Template Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="strict.html">6.14. Bang patterns and Strict Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel.html">6.15. Parallel and Concurrent</a></li>
<li class="toctree-l2"><a class="reference internal" href="primitives.html">6.16. Unboxed types and primitive operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffi.html">6.17. Foreign function interface (FFI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="safe_haskell.html">6.18. Safe Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc.html">6.19. Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="pragmas.html">6.20. Pragmas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../exts.html"><span class="section-number">6. </span>Language extensions</a> &raquo;</li>
        
          <li><a href="patterns.html"><span class="section-number">6.7. </span>Patterns</a> &raquo;</li>
        
      <li><span class="section-number">6.7.2. </span>View patterns</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/exts/view_patterns.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="view-patterns">
<span id="id1"></span><h1><span class="section-number">6.7.2. </span>View patterns<a class="headerlink" href="#view-patterns" title="Permalink to this heading">¶</a></h1>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-ViewPatterns">
<span id="ghc-flag--XViewPatterns"></span><span id="extension-NoViewPatterns"></span><span class="sig-name descname"><span class="pre">ViewPatterns</span></span><a class="headerlink" href="#extension-ViewPatterns" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>6.10.1</p>
</dd>
</dl>
<p>Allow use of view pattern syntax.</p>
</dd></dl>

<p>View patterns are enabled by the language extension <a class="reference internal" href="#extension-ViewPatterns"><code class="xref std std-extension docutils literal notranslate"><span class="pre">ViewPatterns</span></code></a>. More
information and examples of view patterns can be found on the
<a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/view-patterns">Wiki page</a>.</p>
<p>View patterns are somewhat like pattern guards that can be nested inside
of other patterns. They are a convenient way of pattern-matching against
values of abstract types. For example, in a programming language
implementation, we might represent the syntax of the types of the
language as follows:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kt">Typ</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">TypView</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Unit</span><span class="w"></span>
<span class="w">             </span><span class="o">|</span><span class="w"> </span><span class="kt">Arrow</span><span class="w"> </span><span class="kt">Typ</span><span class="w"> </span><span class="kt">Typ</span><span class="w"></span>

<span class="nf">view</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Typ</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">TypView</span><span class="w"></span>

<span class="c1">-- additional operations for constructing Typ&#39;s ...</span><span class="w"></span>
</pre></div>
</div>
<p>The representation of Typ is held abstract, permitting implementations
to use a fancy representation (e.g., hash-consing to manage sharing).
Without view patterns, using this signature is a little inconvenient:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">size</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Typ</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Integer</span><span class="w"></span>
<span class="nf">size</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">view</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">  </span><span class="kt">Unit</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">  </span><span class="kt">Arrow</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="n">t2</span><span class="w"></span>
</pre></div>
</div>
<p>It is necessary to iterate the case, rather than using an equational
function definition. And the situation is even worse when the matching
against <code class="docutils literal notranslate"><span class="pre">t</span></code> is buried deep inside another pattern.</p>
<p>View patterns permit calling the view function inside the pattern and
matching against the result:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">size</span><span class="w"> </span><span class="p">(</span><span class="n">view</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Unit</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="nf">size</span><span class="w"> </span><span class="p">(</span><span class="n">view</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Arrow</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="n">t2</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="n">t2</span><span class="w"></span>
</pre></div>
</div>
<p>That is, we add a new form of pattern, written ⟨expression⟩ <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code>
⟨pattern⟩ that means “apply the expression to whatever we’re trying to
match against, and then match the result of that application against the
pattern”. The expression can be any Haskell expression of function type,
and view patterns can be used wherever patterns are used.</p>
<p>The semantics of a pattern <code class="docutils literal notranslate"><span class="pre">(</span></code> ⟨exp⟩ <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code> ⟨pat⟩ <code class="docutils literal notranslate"><span class="pre">)</span></code> are as
follows:</p>
<ul>
<li><p>Scoping:
The variables bound by the view pattern are the variables bound by
⟨pat⟩.</p>
<p>Any variables in ⟨exp⟩ are bound occurrences, but variables bound “to
the left” in a pattern are in scope. This feature permits, for
example, one argument to a function to be used in the view of another
argument. For example, the function <code class="docutils literal notranslate"><span class="pre">clunky</span></code> from
<a class="reference internal" href="pattern_guards.html#pattern-guards"><span class="std std-ref">Pattern guards</span></a> can be written using view patterns as follows:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">clunky</span><span class="w"> </span><span class="n">env</span><span class="w"> </span><span class="p">(</span><span class="n">lookup</span><span class="w"> </span><span class="n">env</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="n">val1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">lookup</span><span class="w"> </span><span class="n">env</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="n">val2</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">val1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">val2</span><span class="w"></span>
<span class="o">...</span><span class="n">other</span><span class="w"> </span><span class="n">equations</span><span class="w"> </span><span class="n">for</span><span class="w"> </span><span class="n">clunky</span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>More precisely, the scoping rules are:</p>
<ul>
<li><p>In a single pattern, variables bound by patterns to the left of a
view pattern expression are in scope. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">example</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="p">((</span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Integer</span><span class="p">,</span><span class="kt">Integer</span><span class="p">),</span><span class="w"> </span><span class="kt">String</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="nf">example</span><span class="w"> </span><span class="p">(</span><span class="kt">Just</span><span class="w"> </span><span class="p">((</span><span class="n">f</span><span class="p">,</span><span class="kr">_</span><span class="p">),</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">True</span><span class="w"></span>
</pre></div>
</div>
<p>Additionally, in function definitions, variables bound by matching
earlier curried arguments may be used in view pattern expressions
in later arguments:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">example</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Integer</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="nf">example</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">True</span><span class="w"></span>
</pre></div>
</div>
<p>That is, the scoping is the same as it would be if the curried
arguments were collected into a tuple.</p>
</li>
<li><p>In mutually recursive bindings, such as <code class="docutils literal notranslate"><span class="pre">let</span></code>, <code class="docutils literal notranslate"><span class="pre">where</span></code>, or the
top level, view patterns in one declaration may not mention
variables bound by other declarations. That is, each declaration
must be self-contained. For example, the following program is not
allowed:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="p">{(</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">e1</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">     </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">e2</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
</pre></div>
</div>
</li>
</ul>
<p>(For some amplification on this design choice see <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/4061">#4061</a>.</p>
</li>
<li><p>Typing: If ⟨exp⟩ has type ⟨T1⟩ <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code> ⟨T2⟩ and ⟨pat⟩ matches a ⟨T2⟩,
then the whole view pattern matches a ⟨T1⟩.</p></li>
<li><p>Matching: To the equations in Section 3.17.3 of the <a class="reference external" href="http://www.haskell.org/onlinereport/">Haskell 98
Report</a>, add the following:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">e1</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">e2</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="kr">case</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">e1</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">e2</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>That is, to match a variable ⟨v⟩ against a pattern <code class="docutils literal notranslate"><span class="pre">(</span></code> ⟨exp⟩ <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code>
⟨pat⟩ <code class="docutils literal notranslate"><span class="pre">)</span></code>, evaluate <code class="docutils literal notranslate"><span class="pre">(</span></code> ⟨exp⟩ ⟨v⟩ <code class="docutils literal notranslate"><span class="pre">)</span></code> and match the result
against ⟨pat⟩.</p>
</li>
<li><p>Efficiency: When the same view function is applied in multiple
branches of a function definition or a case expression (e.g., in
<code class="docutils literal notranslate"><span class="pre">size</span></code> above), GHC makes an attempt to collect these applications
into a single nested case expression, so that the view function is
only applied once. Pattern compilation in GHC follows the matrix
algorithm described in Chapter 4 of <a class="reference external" href="http://research.microsoft.com/~simonpj/Papers/slpj-book-1987/">The Implementation of Functional
Programming
Languages</a>.
When the top rows of the first column of a matrix are all view
patterns with the “same” expression, these patterns are transformed
into a single nested case. This includes, for example, adjacent view
patterns that line up in a tuple, as in</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="p">((</span><span class="n">view</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">A</span><span class="p">,</span><span class="w"> </span><span class="n">p1</span><span class="p">),</span><span class="w"> </span><span class="n">p2</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">e1</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="p">((</span><span class="n">view</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">B</span><span class="p">,</span><span class="w"> </span><span class="n">p3</span><span class="p">),</span><span class="w"> </span><span class="n">p4</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">e2</span><span class="w"></span>
</pre></div>
</div>
<p>The current notion of when two view pattern expressions are “the
same” is very restricted: it is not even full syntactic equality.
However, it does include variables, literals, applications, and
tuples; e.g., two instances of <code class="docutils literal notranslate"><span class="pre">view</span> <span class="pre">(&quot;hi&quot;,</span> <span class="pre">&quot;there&quot;)</span></code> will be
collected. However, the current implementation does not compare up to
alpha-equivalence, so two instances of <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">view</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">y)</span></code> will not
be coalesced.</p>
</li>
</ul>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="nk_patterns.html" class="btn btn-neutral float-right" title="6.7.3. n+k patterns" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="pattern_guards.html" class="btn btn-neutral float-left" title="6.7.1. Pattern guards" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>