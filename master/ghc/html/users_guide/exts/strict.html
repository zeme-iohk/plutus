

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6.14. Bang patterns and Strict Haskell &mdash; Glasgow Haskell Compiler 9.2.5 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.5 User&#39;s Guide"
          href="../_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6.15. Parallel and Concurrent" href="parallel.html" />
    <link rel="prev" title="6.13. Template Haskell" href="template_haskell.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="../runghc.html">4. Using runghc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">5. Using GHC</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../exts.html">6. Language extensions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">6.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="syntax.html">6.2. Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="import_export.html">6.3. Import and export</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">6.4. Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="records.html">6.5. Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="deriving.html">6.6. Deriving mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="patterns.html">6.7. Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="typeclasses.html">6.8. Class and instances declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="literals.html">6.9. Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="constraints.html">6.10. Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="type_signatures.html">6.11. Type signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="bindings.html">6.12. Bindings and generalisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="template_haskell.html">6.13. Template Haskell</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">6.14. Bang patterns and Strict Haskell</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#bang-patterns-informal">6.14.1. Bang patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="#strict-by-default-data-types">6.14.2. Strict-by-default data types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#strict-by-default-pattern-bindings">6.14.3. Strict-by-default pattern bindings</a></li>
<li class="toctree-l3"><a class="reference internal" href="#modularity">6.14.4. Modularity</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dynamic-semantics-of-bang-patterns">6.14.5. Dynamic semantics of bang patterns</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="parallel.html">6.15. Parallel and Concurrent</a></li>
<li class="toctree-l2"><a class="reference internal" href="primitives.html">6.16. Unboxed types and primitive operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffi.html">6.17. Foreign function interface (FFI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="safe_haskell.html">6.18. Safe Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc.html">6.19. Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="pragmas.html">6.20. Pragmas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../exts.html"><span class="section-number">6. </span>Language extensions</a> &raquo;</li>
        
      <li><span class="section-number">6.14. </span>Bang patterns and Strict Haskell</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/exts/strict.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="bang-patterns-and-strict-haskell">
<span id="strict-haskell"></span><span id="bang-patterns"></span><h1><span class="section-number">6.14. </span>Bang patterns and Strict Haskell<a class="headerlink" href="#bang-patterns-and-strict-haskell" title="Permalink to this heading">¶</a></h1>
<span class="target" id="index-0"></span><p id="index-1">In high-performance Haskell code (e.g. numeric code) eliminating
thunks from an inner loop can be a huge win.
GHC supports three extensions to allow the programmer to specify
use of strict (call-by-value) evaluation rather than lazy (call-by-need)
evaluation.</p>
<ul class="simple">
<li><p>Bang patterns (<a class="reference internal" href="#extension-BangPatterns"><code class="xref std std-extension docutils literal notranslate"><span class="pre">BangPatterns</span></code></a>) makes pattern matching and
let bindings stricter.</p></li>
<li><p>Strict data types (<a class="reference internal" href="#extension-StrictData"><code class="xref std std-extension docutils literal notranslate"><span class="pre">StrictData</span></code></a>) makes constructor fields
strict by default, on a per-module basis.</p></li>
<li><p>Strict pattern (<a class="reference internal" href="#extension-Strict"><code class="xref std std-extension docutils literal notranslate"><span class="pre">Strict</span></code></a>) makes all patterns and let bindings
strict by default, on a per-module basis.</p></li>
</ul>
<p>The latter two extensions are simply a way to avoid littering high-performance
code with bang patterns, making it harder to read.</p>
<p>Bang patterns and strict matching do not affect the type system in any way.</p>
<section id="bang-patterns-informal">
<span id="id1"></span><h2><span class="section-number">6.14.1. </span>Bang patterns<a class="headerlink" href="#bang-patterns-informal" title="Permalink to this heading">¶</a></h2>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-BangPatterns">
<span id="ghc-flag--XBangPatterns"></span><span id="extension-NoBangPatterns"></span><span class="sig-name descname"><span class="pre">BangPatterns</span></span><a class="headerlink" href="#extension-BangPatterns" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>6.8.1</p>
</dd>
</dl>
<p>Allow use of bang pattern syntax.</p>
</dd></dl>

<p>GHC supports an extension of pattern matching called <em>bang patterns</em>,
written <code class="docutils literal notranslate"><span class="pre">!pat</span></code>. Bang patterns are under consideration for Haskell
Prime. The <a class="reference external" href="https://gitlab.haskell.org/haskell/prime/-/wikis/BangPatterns">Haskell prime feature
description</a>
contains more discussion and examples than the material below.</p>
<p>The main idea is to add a single new production to the syntax of
patterns:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pat</span><span class="w"> </span><span class="kt">::=</span><span class="w"> </span><span class="o">!</span><span class="n">pat</span><span class="w"></span>
</pre></div>
</div>
<p>Matching an expression <code class="docutils literal notranslate"><span class="pre">e</span></code> against a pattern <code class="docutils literal notranslate"><span class="pre">!p</span></code> is done by first
evaluating <code class="docutils literal notranslate"><span class="pre">e</span></code> (to WHNF) and then matching the result against <code class="docutils literal notranslate"><span class="pre">p</span></code>.
Example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f1</span><span class="w"> </span><span class="o">!</span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">True</span><span class="w"></span>
</pre></div>
</div>
<p>This definition makes <code class="docutils literal notranslate"><span class="pre">f1</span></code> is strict in <code class="docutils literal notranslate"><span class="pre">x</span></code>, whereas without the
bang it would be lazy. Bang patterns can be nested of course:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f2</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">f2</span></code> is strict in <code class="docutils literal notranslate"><span class="pre">x</span></code> but not in <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
<p>Note the following points:</p>
<ul>
<li><p>A bang only really has
an effect if it precedes a variable or wild-card pattern:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f3</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">]</span><span class="w"></span>
<span class="nf">f4</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">f3</span></code> and <code class="docutils literal notranslate"><span class="pre">f4</span></code> are identical; putting a bang before a pattern
that forces evaluation anyway does nothing.</p>
</li>
<li><p>A bang pattern is allowed in a let or where clause, and makes the binding
strict.  For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="o">!</span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">body</span><span class="w"></span>
<span class="kr">let</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">body</span><span class="w"></span>
</pre></div>
</div>
<p>In both cases <code class="docutils literal notranslate"><span class="pre">e</span></code> is evaluated before starting to evaluate <code class="docutils literal notranslate"><span class="pre">body</span></code>.</p>
<p>However, <em>nested</em> bangs in a let/where pattern binding behave uniformly with all
other forms of pattern matching. For example</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="p">,[</span><span class="n">y</span><span class="p">])</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
</pre></div>
</div>
<p>is equivalent to this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,[</span><span class="n">y</span><span class="p">])</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">`</span><span class="n">seq</span><span class="p">`</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fst</span><span class="w"> </span><span class="n">t</span><span class="w"></span>
<span class="w">      </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">snd</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="kr">in</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
</pre></div>
</div>
<p>The binding is lazy, but when either <code class="docutils literal notranslate"><span class="pre">x</span></code> or <code class="docutils literal notranslate"><span class="pre">y</span></code> is evaluated by
<code class="docutils literal notranslate"><span class="pre">b</span></code> the entire pattern is matched, including forcing the evaluation of
<code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>See <a class="reference internal" href="#recursive-and-polymorphic-let-bindings"><span class="std std-ref">Semantics of let bindings with bang patterns</span></a> for
the detailed semantics.</p>
</li>
<li><p>A pattern with a bang at the outermost level is not allowed at the top
level of a module.</p></li>
<li><p>Bang patterns work in <code class="docutils literal notranslate"><span class="pre">case</span></code> expressions too, of course:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">g5</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">body</span><span class="w"></span>
<span class="nf">g6</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="nf">g7</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">!</span><span class="n">y</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The functions <code class="docutils literal notranslate"><span class="pre">g5</span></code> and <code class="docutils literal notranslate"><span class="pre">g6</span></code> mean exactly the same thing. But <code class="docutils literal notranslate"><span class="pre">g7</span></code>
evaluates <code class="docutils literal notranslate"><span class="pre">(f</span> <span class="pre">x)</span></code>, binds <code class="docutils literal notranslate"><span class="pre">y</span></code> to the result, and then evaluates
<code class="docutils literal notranslate"><span class="pre">body</span></code>.</p>
</li>
<li><p>There is one problem with syntactic ambiguity. Consider:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="o">!</span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">3</span><span class="w"></span>
</pre></div>
</div>
<p>Is this a definition of the infix function “<code class="docutils literal notranslate"><span class="pre">(!)</span></code>”, or of the “<code class="docutils literal notranslate"><span class="pre">f</span></code>” with
a bang pattern? GHC resolves this ambiguity by looking at the surrounding
whitespace:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w">   </span><span class="c1">-- infix operator</span><span class="w"></span>
<span class="nf">a</span><span class="w"> </span><span class="o">!</span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w">    </span><span class="c1">-- bang pattern</span><span class="w"></span>
</pre></div>
</div>
<p>See <a class="reference external" href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0229-whitespace-bang-patterns.rst">GHC Proposal #229</a>
for the precise rules.</p>
</li>
</ul>
</section>
<section id="strict-by-default-data-types">
<span id="strict-data"></span><h2><span class="section-number">6.14.2. </span>Strict-by-default data types<a class="headerlink" href="#strict-by-default-data-types" title="Permalink to this heading">¶</a></h2>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-StrictData">
<span id="ghc-flag--XStrictData"></span><span id="extension-NoStrictData"></span><span class="sig-name descname"><span class="pre">StrictData</span></span><a class="headerlink" href="#extension-StrictData" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>8.0.1</p>
</dd>
</dl>
<p>Make fields of data types defined in the current module strict by default.</p>
</dd></dl>

<p>Informally the <code class="docutils literal notranslate"><span class="pre">StrictData</span></code> language extension switches data type
declarations to be strict by default allowing fields to be lazy by
adding a <code class="docutils literal notranslate"><span class="pre">~</span></code> in front of the field.</p>
<p>When the user writes</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">T&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">C&#39;</span><span class="w"> </span><span class="o">~</span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>we interpret it as if they had written</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="o">!</span><span class="n">a</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">T&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">C&#39;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>The extension only affects definitions in this module.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">~</span></code> annotation must be written in prefix form:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkT</span><span class="w"> </span><span class="o">~</span><span class="kt">Int</span><span class="w">   </span><span class="c1">-- valid</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkT</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="kt">Int</span><span class="w">  </span><span class="c1">-- invalid</span><span class="w"></span>
</pre></div>
</div>
<p>See <a class="reference external" href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0229-whitespace-bang-patterns.rst">GHC Proposal #229</a>
for the precise rules.</p>
</section>
<section id="strict-by-default-pattern-bindings">
<span id="strict"></span><h2><span class="section-number">6.14.3. </span>Strict-by-default pattern bindings<a class="headerlink" href="#strict-by-default-pattern-bindings" title="Permalink to this heading">¶</a></h2>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-Strict">
<span id="ghc-flag--XStrict"></span><span id="extension-NoStrict"></span><span class="sig-name descname"><span class="pre">Strict</span></span><a class="headerlink" href="#extension-Strict" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Implies<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#extension-StrictData"><code class="xref std std-extension docutils literal notranslate"><span class="pre">StrictData</span></code></a></p>
</dd>
<dt class="field-even">Since<span class="colon">:</span></dt>
<dd class="field-even"><p>8.0.1</p>
</dd>
</dl>
<p>Make bindings in the current module strict by default.</p>
</dd></dl>

<p>Informally the <code class="docutils literal notranslate"><span class="pre">Strict</span></code> language extension switches functions, data
types, and bindings to be strict by default, allowing optional laziness
by adding <code class="docutils literal notranslate"><span class="pre">~</span></code> in front of a variable. This essentially reverses the
present situation where laziness is default and strictness can be
optionally had by adding <code class="docutils literal notranslate"><span class="pre">!</span></code> in front of a variable.</p>
<p><code class="docutils literal notranslate"><span class="pre">Strict</span></code> implies <a class="reference internal" href="#strict-data"><span class="std std-ref">StrictData</span></a>.</p>
<ul>
<li><p><strong>Function definitions</strong></p>
<p>When the user writes</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>we interpret it as if they had written</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="o">!</span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>Adding <code class="docutils literal notranslate"><span class="pre">~</span></code> in front of <code class="docutils literal notranslate"><span class="pre">x</span></code> gives the regular lazy behavior.</p>
<p>Turning patterns into irrefutable ones requires <code class="docutils literal notranslate"><span class="pre">~(~p)</span></code> when <code class="docutils literal notranslate"><span class="pre">Strict</span></code> is enabled.</p>
</li>
<li><p><strong>Let/where bindings</strong></p>
<p>When the user writes</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="kr">let</span><span class="w"> </span><span class="n">pat</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>we interpret it as if they had written</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="o">!</span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="kr">let</span><span class="w"> </span><span class="o">!</span><span class="n">pat</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>Adding <code class="docutils literal notranslate"><span class="pre">~</span></code> in front of <code class="docutils literal notranslate"><span class="pre">x</span></code> gives the regular lazy
behavior.
The general rule is that we add an implicit bang on the outermost pattern,
unless disabled with <code class="docutils literal notranslate"><span class="pre">~</span></code>.</p>
</li>
<li><p><strong>Pattern matching in case expressions, lambdas, do-notation, etc</strong></p>
<p>The outermost pattern of all pattern matches gets an implicit bang,
unless disabled with <code class="docutils literal notranslate"><span class="pre">~</span></code>.
This applies to case expressions, patterns in lambda, do-notation,
list comprehension, and so on.
For example</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">rhs</span><span class="w"></span>
</pre></div>
</div>
<p>is interpreted as</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">rhs</span><span class="w"></span>
</pre></div>
</div>
<p>Since the semantics of pattern matching in case expressions is
strict, this usually has no effect whatsoever. But it does make a
difference in the degenerate case of variables and newtypes. So</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">rhs</span><span class="w"></span>
</pre></div>
</div>
<p>is lazy in Haskell, but with <code class="docutils literal notranslate"><span class="pre">Strict</span></code> is interpreted as</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="o">!</span><span class="n">y</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">rhs</span><span class="w"></span>
</pre></div>
</div>
<p>which evaluates <code class="docutils literal notranslate"><span class="pre">x</span></code>. Similarly, if <code class="docutils literal notranslate"><span class="pre">newtype</span> <span class="pre">Age</span> <span class="pre">=</span> <span class="pre">MkAge</span> <span class="pre">Int</span></code>, then</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="kt">MkAge</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">rhs</span><span class="w"></span>
</pre></div>
</div>
<p>is lazy in Haskell; but with <code class="docutils literal notranslate"><span class="pre">Strict</span></code> the added bang makes it
strict.</p>
<p>Similarly</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">\</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">body</span><span class="w"></span>
<span class="kr">do</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">rhs</span><span class="p">;</span><span class="w"> </span><span class="n">blah</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">[</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">rhs</span><span class="p">;</span><span class="w"> </span><span class="n">blah</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>all get implicit bangs on the <code class="docutils literal notranslate"><span class="pre">x</span></code> pattern.</p>
</li>
<li><p><strong>Nested patterns</strong></p>
<p>Notice that we do <em>not</em> put bangs on nested patterns. For
example</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">flob</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="p">(</span><span class="n">undefined</span><span class="p">,</span><span class="w"> </span><span class="n">undefined</span><span class="p">)</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="p">(</span><span class="kt">True</span><span class="p">,</span><span class="w"> </span><span class="kt">False</span><span class="p">)</span><span class="w"></span>
<span class="kr">in</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>will behave like</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">flob</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="p">(</span><span class="n">undefined</span><span class="p">,</span><span class="w"> </span><span class="n">undefined</span><span class="p">)</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="p">(</span><span class="kt">True</span><span class="p">,</span><span class="kt">False</span><span class="p">)</span><span class="w"></span>
<span class="kr">in</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>which will strictly evaluate the right hand side, and bind <code class="docutils literal notranslate"><span class="pre">p</span></code>
and <code class="docutils literal notranslate"><span class="pre">q</span></code> to the components of the pair. But the pair itself is
lazy (unless we also compile the <code class="docutils literal notranslate"><span class="pre">Prelude</span></code> with <code class="docutils literal notranslate"><span class="pre">Strict</span></code>; see
<a class="reference internal" href="#strict-modularity"><span class="std std-ref">Modularity</span></a> below). So <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code> may end up bound to
undefined. See also <a class="reference internal" href="#recursive-and-polymorphic-let-bindings"><span class="std std-ref">Dynamic semantics of bang patterns</span></a> below.</p>
</li>
<li><p><strong>Top level bindings</strong></p>
<p>are unaffected by <code class="docutils literal notranslate"><span class="pre">Strict</span></code>. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">factorial</span><span class="w"> </span><span class="mi">20</span><span class="w"></span>
<span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="kt">True</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="kt">False</span><span class="w"></span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">x</span></code> and the pattern binding <code class="docutils literal notranslate"><span class="pre">(y,z)</span></code> remain lazy. Reason:
there is no good moment to force them, until first use.</p>
</li>
<li><p><strong>Newtypes</strong></p>
<p>There is no effect on newtypes, which simply rename existing types.
For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="p">(</span><span class="kt">C</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="n">rhs1</span><span class="w"></span>
<span class="nf">g</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">C</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">rhs2</span><span class="w"></span>
</pre></div>
</div>
<p>In ordinary Haskell, <code class="docutils literal notranslate"><span class="pre">f</span></code> is lazy in its argument and hence in
<code class="docutils literal notranslate"><span class="pre">x</span></code>; and <code class="docutils literal notranslate"><span class="pre">g</span></code> is strict in its argument and hence also strict in
<code class="docutils literal notranslate"><span class="pre">x</span></code>. With <code class="docutils literal notranslate"><span class="pre">Strict</span></code>, both become strict because <code class="docutils literal notranslate"><span class="pre">f</span></code>’s argument
gets an implicit bang.</p>
</li>
</ul>
</section>
<section id="modularity">
<span id="strict-modularity"></span><h2><span class="section-number">6.14.4. </span>Modularity<a class="headerlink" href="#modularity" title="Permalink to this heading">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Strict</span></code> and <code class="docutils literal notranslate"><span class="pre">StrictData</span></code> only affects definitions in the module
they are used in. Functions and data types imported from other modules
are unaffected. For example, we won’t evaluate the argument to
<code class="docutils literal notranslate"><span class="pre">Just</span></code> before applying the constructor.  Similarly we won’t evaluate
the first argument to <code class="docutils literal notranslate"><span class="pre">Data.Map.findWithDefault</span></code> before applying the
function.</p>
<p>This is crucial to preserve correctness. Entities defined in other
modules might rely on laziness for correctness (whether functional or
performance).</p>
<p>Tuples, lists, <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>, and all the other types from <code class="docutils literal notranslate"><span class="pre">Prelude</span></code>
continue to have their existing, lazy, semantics.</p>
</section>
<section id="dynamic-semantics-of-bang-patterns">
<span id="recursive-and-polymorphic-let-bindings"></span><span id="bang-patterns-sem"></span><h2><span class="section-number">6.14.5. </span>Dynamic semantics of bang patterns<a class="headerlink" href="#dynamic-semantics-of-bang-patterns" title="Permalink to this heading">¶</a></h2>
<p>The semantics of Haskell pattern matching is described in <a class="reference external" href="http://www.haskell.org/onlinereport/exps.html#sect3.17.2">Section
3.17.2</a> of
the Haskell Report. To this description add one extra item 10, saying:</p>
<ul class="simple">
<li><p>Matching the pattern <code class="docutils literal notranslate"><span class="pre">!pat</span></code> against a value <code class="docutils literal notranslate"><span class="pre">v</span></code> behaves as
follows:</p>
<ul>
<li><p>if <code class="docutils literal notranslate"><span class="pre">v</span></code> is bottom, the match diverges</p></li>
<li><p>otherwise, <code class="docutils literal notranslate"><span class="pre">pat</span></code> is matched against <code class="docutils literal notranslate"><span class="pre">v</span></code></p></li>
</ul>
</li>
</ul>
<p>Similarly, in Figure 4 of <a class="reference external" href="http://www.haskell.org/onlinereport/exps.html#sect3.17.3">Section
3.17.3</a>,
add a new case (t):</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">!</span><span class="n">pat</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">e</span><span class="p">;</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">e&#39;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="ow">=</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">`</span><span class="n">seq</span><span class="p">`</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">pat</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">e</span><span class="p">;</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">e&#39;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>That leaves let expressions, whose translation is given in <a class="reference external" href="http://www.haskell.org/onlinereport/exps.html#sect3.12">Section
3.12</a> of the
Haskell Report.
Replace the “Translation” there with the following one.  Given
<code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">{</span> <span class="pre">bind1</span> <span class="pre">...</span> <span class="pre">bindn</span> <span class="pre">}</span> <span class="pre">in</span> <span class="pre">body</span></code>:</p>
<div class="admonition-force admonition">
<p class="admonition-title">FORCE</p>
<p>Replace any binding <code class="docutils literal notranslate"><span class="pre">!p</span> <span class="pre">=</span> <span class="pre">e</span></code> with <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">case</span> <span class="pre">e</span> <span class="pre">of</span> <span class="pre">p</span> <span class="pre">-&gt;</span> <span class="pre">(x1,</span> <span class="pre">...,</span> <span class="pre">xn);</span> <span class="pre">(x1,</span> <span class="pre">...,</span> <span class="pre">xn)</span> <span class="pre">=</span> <span class="pre">v</span></code> and replace
<code class="docutils literal notranslate"><span class="pre">body</span></code> with <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">seq</span> <span class="pre">body</span></code>, where <code class="docutils literal notranslate"><span class="pre">v</span></code> is fresh. This translation works fine if
<code class="docutils literal notranslate"><span class="pre">p</span></code> is already a variable <code class="docutils literal notranslate"><span class="pre">x</span></code>, but can obviously be optimised by not
introducing a fresh variable <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
</div>
<div class="admonition-split admonition">
<p class="admonition-title">SPLIT</p>
<p>Replace any binding <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">e</span></code>, where <code class="docutils literal notranslate"><span class="pre">p</span></code> is not a variable, with
<code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">e;</span> <span class="pre">x1</span> <span class="pre">=</span> <span class="pre">case</span> <span class="pre">v</span> <span class="pre">of</span> <span class="pre">p</span> <span class="pre">-&gt;</span> <span class="pre">x1;</span> <span class="pre">...;</span> <span class="pre">xn</span> <span class="pre">=</span> <span class="pre">case</span> <span class="pre">v</span> <span class="pre">of</span> <span class="pre">p</span> <span class="pre">-&gt;</span> <span class="pre">xn</span></code>, where
<code class="docutils literal notranslate"><span class="pre">v</span></code> is fresh and <code class="docutils literal notranslate"><span class="pre">x1</span></code>.. <code class="docutils literal notranslate"><span class="pre">xn</span></code> are the bound variables of <code class="docutils literal notranslate"><span class="pre">p</span></code>.
Again if <code class="docutils literal notranslate"><span class="pre">e</span></code> is a variable, this can be optimised by not introducing a
fresh variable.</p>
</div>
<p>The result will be a (possibly) recursive set of bindings, binding
only simple variables on the left hand side. (One could go one step
further, as in the Haskell Report and make the recursive bindings
non-recursive using <code class="docutils literal notranslate"><span class="pre">fix</span></code>, but we do not do so in Core, and it only
obfuscates matters, so we do not do so here.)</p>
<p>The translation is carefully crafted to make bang patterns meaningful
for recursive and polymorphic bindings as well as straightforward
non-recursive bindings.</p>
<p>Here are some examples of how this translation works. The first
expression of each sequence is Haskell source; the subsequent ones are
Core.</p>
<p>Here is a simple non-recursive case:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w">     </span><span class="c1">-- Non-recursive</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">factorial</span><span class="w"> </span><span class="n">y</span><span class="w"></span>
<span class="kr">in</span><span class="w"> </span><span class="n">body</span><span class="w"></span>

<span class="o">===&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">FORCE</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kr">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">factorial</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">`</span><span class="n">seq</span><span class="p">`</span><span class="w"> </span><span class="n">body</span><span class="w"></span>

<span class="o">===&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">inline</span><span class="w"> </span><span class="n">seq</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kr">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">factorial</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">body</span><span class="w"></span>

<span class="o">===&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">inline</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kr">case</span><span class="w"> </span><span class="n">factorial</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">body</span><span class="w"></span>
</pre></div>
</div>
<p>Same again, only with a pattern binding:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Just</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">Left</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">body</span><span class="w"></span>

<span class="o">===&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">FORCE</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kr">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">(</span><span class="kt">Just</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">Left</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">v</span><span class="w"></span>
<span class="w">    </span><span class="kr">in</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">`</span><span class="n">seq</span><span class="p">`</span><span class="w"> </span><span class="n">body</span><span class="w"></span>

<span class="o">===&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">SPLIT</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kr">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">(</span><span class="kt">Just</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">Left</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="w">        </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">y</span><span class="w"></span>
<span class="w">    </span><span class="kr">in</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">`</span><span class="n">seq</span><span class="p">`</span><span class="w"> </span><span class="n">body</span><span class="w"></span>

<span class="o">===&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">inline</span><span class="w"> </span><span class="n">seq</span><span class="p">,</span><span class="w"> </span><span class="n">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="w"> </span><span class="n">bindings</span><span class="w"> </span><span class="n">inwards</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kr">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">(</span><span class="kt">Just</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">Left</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kr">in</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="w">                          </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">y</span><span class="w"></span>
<span class="w">                      </span><span class="kr">in</span><span class="w"> </span><span class="n">body</span><span class="w"></span>

<span class="o">===&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">fluff</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="n">v&#39;s</span><span class="w"> </span><span class="n">pattern</span><span class="p">;</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">standard</span><span class="w"> </span><span class="kt">Core</span><span class="w"> </span><span class="n">optimisation</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kr">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">(</span><span class="kt">Just</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">Left</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kr">in</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="n">v</span><span class="o">@</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="w">                                </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">y</span><span class="w"></span>
<span class="w">                            </span><span class="kr">in</span><span class="w"> </span><span class="n">body</span><span class="w"></span>

<span class="o">===&gt;</span><span class="w"> </span><span class="p">(</span><span class="kr">case</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="n">known</span><span class="w"> </span><span class="n">constructor</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kr">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">(</span><span class="kt">Just</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">Left</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kr">in</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="n">v</span><span class="o">@</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">p</span><span class="w"></span>
<span class="w">                                </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">q</span><span class="w"></span>
<span class="w">                            </span><span class="kr">in</span><span class="w"> </span><span class="n">body</span><span class="w"></span>

<span class="o">===&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">inline</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kr">case</span><span class="w"> </span><span class="p">(</span><span class="kr">case</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">(</span><span class="kt">Just</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">Left</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">body</span><span class="p">[</span><span class="n">p</span><span class="o">/</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="o">/</span><span class="n">y</span><span class="p">]</span><span class="w"></span>

<span class="o">===&gt;</span><span class="w"> </span><span class="p">(</span><span class="kr">case</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="kr">case</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kr">case</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">(</span><span class="kt">Just</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">Left</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">body</span><span class="p">[</span><span class="n">p</span><span class="o">/</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="o">/</span><span class="n">y</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>The final form is just what we want: a simple case expression.</p>
<p>Here is a recursive case</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">letrec</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="w">  </span><span class="c1">-- Recursive</span><span class="w"></span>
<span class="w">        </span><span class="o">!</span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">factorial</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">xs</span><span class="w"></span>
<span class="kr">in</span><span class="w"> </span><span class="n">body</span><span class="w"></span>

<span class="o">===&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">FORCE</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">letrec</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">factorial</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="p">`</span><span class="n">seq</span><span class="p">`</span><span class="w"> </span><span class="n">body</span><span class="w"></span>

<span class="o">===&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">inline</span><span class="w"> </span><span class="n">seq</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">letrec</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">factorial</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">body</span><span class="w"></span>

<span class="o">===&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">eliminate</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">letrec</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">factorial</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">body</span><span class="w"></span>
</pre></div>
</div>
<p>and a polymorphic one:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w">    </span><span class="c1">-- Polymorphic</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fst</span><span class="w"> </span><span class="p">(</span><span class="n">reverse</span><span class="p">,</span><span class="w"> </span><span class="kt">True</span><span class="p">)</span><span class="w"></span>
<span class="kr">in</span><span class="w"> </span><span class="n">body</span><span class="w"></span>

<span class="o">===&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">FORCE</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kr">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">/\</span><span class="n">a</span><span class="o">.</span><span class="w"> </span><span class="n">fst</span><span class="w"> </span><span class="p">(</span><span class="n">reverse</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">True</span><span class="p">)</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">`</span><span class="n">seq</span><span class="p">`</span><span class="w"> </span><span class="n">body</span><span class="w"></span>
<span class="o">===&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">inline</span><span class="w"> </span><span class="n">seq</span><span class="p">,</span><span class="w"> </span><span class="n">inline</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kr">case</span><span class="w"> </span><span class="p">(</span><span class="o">/\</span><span class="n">a</span><span class="o">.</span><span class="w"> </span><span class="n">fst</span><span class="w"> </span><span class="p">(</span><span class="n">reverse</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">True</span><span class="p">))</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">body</span><span class="w"></span>
</pre></div>
</div>
<p>Notice that the <code class="docutils literal notranslate"><span class="pre">seq</span></code> is added only in the translation to Core
If we did it in Haskell source, thus</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">`</span><span class="n">seq</span><span class="p">`</span><span class="w"> </span><span class="n">body</span><span class="w"></span>
</pre></div>
</div>
<p>then <code class="docutils literal notranslate"><span class="pre">f</span></code>‘s polymorphic type would get instantiated, so the Core
translation would be</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="kt">Any</span><span class="w"> </span><span class="p">`</span><span class="n">seq</span><span class="p">`</span><span class="w"> </span><span class="n">body</span><span class="w"></span>
</pre></div>
</div>
<p>When overloading is involved, the results might be slightly counter
intuitive:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w">    </span><span class="c1">-- Overloaded</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fst</span><span class="w"> </span><span class="p">(</span><span class="n">member</span><span class="p">,</span><span class="w"> </span><span class="kt">True</span><span class="p">)</span><span class="w"></span>
<span class="kr">in</span><span class="w"> </span><span class="n">body</span><span class="w"></span>

<span class="o">===&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">FORCE</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kr">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">/\</span><span class="n">a</span><span class="w"> </span><span class="nf">\</span><span class="p">(</span><span class="n">d</span><span class="ow">::</span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="w"> </span><span class="n">fst</span><span class="w"> </span><span class="p">(</span><span class="n">member</span><span class="p">,</span><span class="w"> </span><span class="kt">True</span><span class="p">)</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">`</span><span class="n">seq</span><span class="p">`</span><span class="w"> </span><span class="n">body</span><span class="w"></span>

<span class="o">===&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">inline</span><span class="w"> </span><span class="n">seq</span><span class="p">,</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kr">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">/\</span><span class="n">a</span><span class="w"> </span><span class="nf">\</span><span class="p">(</span><span class="n">d</span><span class="ow">::</span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="w"> </span><span class="n">fst</span><span class="w"> </span><span class="p">(</span><span class="n">member</span><span class="p">,</span><span class="w"> </span><span class="kt">True</span><span class="p">)</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">body</span><span class="w"></span>
</pre></div>
</div>
<p>Note that the bang has no effect at all in this case</p>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="parallel.html" class="btn btn-neutral float-right" title="6.15. Parallel and Concurrent" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="template_haskell.html" class="btn btn-neutral float-left" title="6.13. Template Haskell" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>