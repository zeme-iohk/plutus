-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Random access lists
--   
--   This package provides ordinary random access list, <a>RAList</a>, and
--   also a length indexed variant, <a>RAVec</a>.
--   
--   The data structure allows fast cons-operation (like ordinary list) but
--   also fast random access (like non-functional arrays).
--   
--   For <tt>lens</tt> or <tt>optics</tt> support see <a>ral-lens</a> and
--   <a>ral-optics</a> packages respectively.
--   
--   <h3>Similar packages</h3>
--   
--   These packages don't provide length-indexed variants, and their
--   <a>RAList</a> has opaque structure.
--   
--   <ul>
--   <li><a>https://hackage.haskell.org/package/ralist</a></li>
--   <li><a>https://hackage.haskell.org/package/random-access-list</a></li>
--   </ul>
@package ral
@version 0.2.1

module Data.RAList.Tree

-- | A <a>Leaf</a> is isomorphic to <tt>Identity</tt>, but we reimplement
--   it here to have domain specific type. The short constructor name is a
--   bonus.
newtype Leaf a
Lf :: a -> Leaf a

-- | <a>Node</a> is a product of two <tt>f</tt>. This way we can form a
--   perfect binary tree.
data Node f a
Nd :: f a -> f a -> Node f a

-- | Direction in <a>Node</a>.
data Dir a
L :: a -> Dir a
R :: a -> Dir a


-- | Non-empty random access list.
--   
--   This module is designed to imported qualifed.
module Data.RAList.NonEmpty

-- | Non-empty random access list.
newtype NERAList a
NE :: NERAList' Leaf a -> NERAList a

-- | Non-empty random access list, underlying representation.
--   
--   The structure doesn't need to be hidden, as polymorphic recursion of
--   <a>Node</a>s starting from <a>Leaf</a> keeps the <a>NERAList</a>
--   values well-formed.
data NERAList' f a
Last :: f a -> NERAList' f a
Cons0 :: NERAList' (Node f) a -> NERAList' f a
Cons1 :: f a -> NERAList' (Node f) a -> NERAList' f a
explicitShow :: Show a => NERAList a -> String
explicitShowsPrec :: Show a => Int -> NERAList a -> ShowS

-- | Single element <a>NERAList</a>.
singleton :: a -> NERAList a

-- | <a>cons</a> for non-empty rals.
cons :: a -> NERAList a -> NERAList a

-- | List index.
--   
--   <pre>
--   &gt;&gt;&gt; fromNonEmpty ('a' :| ['b'..'f']) ! 0
--   'a'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromNonEmpty ('a' :| ['b'..'f']) ! 5
--   'f'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromNonEmpty ('a' :| ['b'..'f']) ! 6
--   *** Exception: array index out of range: NERAList
--   ...
--   </pre>
(!) :: NERAList a -> Int -> a

-- | safe list index.
--   
--   <pre>
--   &gt;&gt;&gt; fromNonEmpty ('a' :| ['b'..'f']) !? 0
--   Just 'a'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromNonEmpty ('a' :| ['b'..'f']) !? 5
--   Just 'f'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromNonEmpty ('a' :| ['b'..'f']) !? 6
--   Nothing
--   </pre>
(!?) :: NERAList a -> Int -> Maybe a

-- | First value, head of the list.
--   
--   <pre>
--   &gt;&gt;&gt; head $ fromNonEmpty $ 'a' :| ['b'..'f']
--   'a'
--   </pre>
head :: NERAList a -> a

-- | Last value of the list
--   
--   <pre>
--   &gt;&gt;&gt; last $ fromNonEmpty $  'a' :| ['b'..'f']
--   'f'
--   </pre>
last :: NERAList a -> a

-- | <pre>
--   &gt;&gt;&gt; uncons $ fromNonEmpty $ 'a' :| "bcdef"
--   ('a',fromList "bcdef")
--   </pre>
uncons :: NERAList a -> (a, RAList a)

-- | Tail of non-empty list can be empty.
--   
--   <pre>
--   &gt;&gt;&gt; tail $ fromNonEmpty $ 'a' :| "bcdef"
--   fromList "bcdef"
--   </pre>
tail :: NERAList a -> RAList a
length :: NERAList a -> Int
null :: NERAList a -> Bool
toNonEmpty :: NERAList a -> NonEmpty a

-- | <pre>
--   &gt;&gt;&gt; fromNonEmpty ('a' :| ['b'..'f'])
--   fromNonEmpty ('a' :| "bcdef")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; explicitShow (fromNonEmpty ('a' :| ['b'..'f']))
--   "NE (Cons0 (Cons1 (Nd (Lf 'a') (Lf 'b')) (Last (Nd (Nd (Lf 'c') (Lf 'd')) (Nd (Lf 'e') (Lf 'f'))))))"
--   </pre>
fromNonEmpty :: NonEmpty a -> NERAList a
foldMap1 :: forall a s. Semigroup s => (a -> s) -> NERAList a -> s
foldr1Map :: (a -> b -> b) -> (a -> b) -> NERAList a -> b
ifoldMap :: Monoid m => (Int -> a -> m) -> NERAList a -> m

-- | <pre>
--   &gt;&gt;&gt; import Data.Semigroup (Min (..))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ifoldMap1 (\_ x -&gt; Min x) $ fromNonEmpty $ 5 :| [3,1,2,4]
--   Min {getMin = 1}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ifoldMap1 (\i x -&gt; Min (i + x)) $ fromNonEmpty $ 5 :| [3,1,2,4]
--   Min {getMin = 3}
--   </pre>
ifoldMap1 :: forall a s. Semigroup s => (Int -> a -> s) -> NERAList a -> s
ifoldr1Map :: forall a b. (Int -> a -> b -> b) -> (Int -> a -> b) -> NERAList a -> b

-- | Adjust a value in the list.
--   
--   <pre>
--   &gt;&gt;&gt; adjust 3 toUpper $ fromNonEmpty $ 'a' :| "bcdef"
--   fromNonEmpty ('a' :| "bcDef")
--   </pre>
--   
--   If index is out of bounds, the list is returned unmodified.
--   
--   <pre>
--   &gt;&gt;&gt; adjust 10 toUpper $ fromNonEmpty $ 'a' :| "bcdef"
--   fromNonEmpty ('a' :| "bcdef")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; adjust (-1) toUpper $ fromNonEmpty $ 'a' :| "bcdef"
--   fromNonEmpty ('a' :| "bcdef")
--   </pre>
adjust :: forall a. Int -> (a -> a) -> NERAList a -> NERAList a

-- | <pre>
--   &gt;&gt;&gt; map toUpper (fromNonEmpty ('a' :| ['b'..'f']))
--   fromNonEmpty ('A' :| "BCDEF")
--   </pre>
map :: (a -> b) -> NERAList a -> NERAList b

-- | <pre>
--   &gt;&gt;&gt; imap (,) (fromNonEmpty ('a' :| ['b'..'f']))
--   fromNonEmpty ((0,'a') :| [(1,'b'),(2,'c'),(3,'d'),(4,'e'),(5,'f')])
--   </pre>
imap :: (Int -> a -> b) -> NERAList a -> NERAList b
itraverse :: forall f a b. Applicative f => (Int -> a -> f b) -> NERAList a -> f (NERAList b)
itraverse1 :: forall f a b. Apply f => (Int -> a -> f b) -> NERAList a -> f (NERAList b)


-- | Random access list.
--   
--   This module is designed to imported qualifed.
module Data.RAList

-- | Random access list.
data RAList a
Empty :: RAList a
NonEmpty :: NERAList a -> RAList a
explicitShow :: Show a => RAList a -> String
explicitShowsPrec :: Show a => Int -> RAList a -> ShowS

-- | Empty <a>RAList</a>.
--   
--   <pre>
--   &gt;&gt;&gt; empty :: RAList Int
--   fromList []
--   </pre>
empty :: RAList a

-- | Single element <a>RAList</a>.
singleton :: a -> RAList a

-- | <a>cons</a> for non-empty rals.
cons :: a -> RAList a -> RAList a
(!) :: RAList a -> Int -> a

-- | safe list index.
--   
--   <pre>
--   &gt;&gt;&gt; fromList ['a'..'f'] !? 0
--   Just 'a'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromList ['a'..'f'] !? 5
--   Just 'f'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromList ['a'..'f'] !? 6
--   Nothing
--   </pre>
(!?) :: RAList a -> Int -> Maybe a

-- | <pre>
--   &gt;&gt;&gt; uncons $ fromList []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncons $ fromList "abcdef"
--   Just ('a',fromList "bcdef")
--   </pre>
uncons :: RAList a -> Maybe (a, RAList a)
length :: RAList a -> Int
null :: RAList a -> Bool
toList :: RAList a -> [a]

-- | <pre>
--   &gt;&gt;&gt; fromList ['a' .. 'f']
--   fromList "abcdef"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; explicitShow $ fromList ['a' .. 'f']
--   "NonEmpty (NE (Cons0 (Cons1 (Nd (Lf 'a') (Lf 'b')) (Last (Nd (Nd (Lf 'c') (Lf 'd')) (Nd (Lf 'e') (Lf 'f')))))))"
--   </pre>
fromList :: [a] -> RAList a
ifoldMap :: Monoid m => (Int -> a -> m) -> RAList a -> m

-- | Adjust a value in the list.
--   
--   <pre>
--   &gt;&gt;&gt; adjust 3 toUpper $ fromList "bcdef"
--   fromList "bcdEf"
--   </pre>
--   
--   If index is out of bounds, the list is returned unmodified.
--   
--   <pre>
--   &gt;&gt;&gt; adjust 10 toUpper $ fromList "bcdef"
--   fromList "bcdef"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; adjust (-1) toUpper $ fromList "bcdef"
--   fromList "bcdef"
--   </pre>
adjust :: forall a. Int -> (a -> a) -> RAList a -> RAList a

-- | <pre>
--   &gt;&gt;&gt; map toUpper (fromList ['a'..'f'])
--   fromList "ABCDEF"
--   </pre>
map :: (a -> b) -> RAList a -> RAList b

-- | <pre>
--   &gt;&gt;&gt; imap (,) $ fromList ['a' .. 'f']
--   fromList [(0,'a'),(1,'b'),(2,'c'),(3,'d'),(4,'e'),(5,'f')]
--   </pre>
imap :: (Int -> a -> b) -> RAList a -> RAList b
itraverse :: forall f a b. Applicative f => (Int -> a -> f b) -> RAList a -> f (RAList b)


-- | Depth indexed perfect binary tree.
module Data.RAVec.Tree

-- | Perfectly balanced binary tree of depth <tt>n</tt>, with <tt>2 ^
--   n</tt> elements.
data Tree (n :: Nat) a
[Leaf] :: a -> Tree 'Z a
[Node] :: Tree n a -> Tree n a -> Tree ('S n) a

-- | <a>Tree</a> of zero depth, with single element.
--   
--   <pre>
--   &gt;&gt;&gt; singleton True
--   Leaf True
--   </pre>
singleton :: a -> Tree 'Z a

-- | Convert <a>Tree</a> to list.
--   
--   <pre>
--   &gt;&gt;&gt; toList $ Node (Node (Leaf 'a') (Leaf 'b')) (Node (Leaf 'c') (Leaf 'd'))
--   "abcd"
--   </pre>
toList :: Tree n a -> [a]

-- | Reverse <a>Tree</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let t = Node (Node (Leaf 'a') (Leaf 'b')) (Node (Leaf 'c') (Leaf 'd'))
--   
--   &gt;&gt;&gt; reverse t
--   Node (Node (Leaf 'd') (Leaf 'c')) (Node (Leaf 'b') (Leaf 'a'))
--   </pre>
reverse :: Tree n a -> Tree n a

-- | Indexing.
(!) :: Tree n a -> Wrd n -> a
tabulate :: forall n a. SNatI n => (Wrd n -> a) -> Tree n a
leftmost :: Tree n a -> a
rightmost :: Tree n a -> a
foldMap :: Monoid m => (a -> m) -> Tree n a -> m
foldMap1 :: Semigroup s => (a -> s) -> Tree n a -> s
ifoldMap :: Monoid m => (Wrd n -> a -> m) -> Tree n a -> m
ifoldMap1 :: Semigroup s => (Wrd n -> a -> s) -> Tree n a -> s

-- | <pre>
--   &gt;&gt;&gt; foldr (:) [] $ Node (Leaf True) (Leaf False)
--   [True,False]
--   </pre>
foldr :: (a -> b -> b) -> b -> Tree n a -> b
ifoldr :: (Wrd n -> a -> b -> b) -> b -> Tree n a -> b
foldr1Map :: (a -> b -> b) -> (a -> b) -> Tree n a -> b
ifoldr1Map :: (Wrd n -> a -> b -> b) -> (Wrd n -> a -> b) -> Tree n a -> b

-- | <pre>
--   &gt;&gt;&gt; foldl (flip (:)) [] $ Node (Leaf True) (Leaf False)
--   [False,True]
--   </pre>
foldl :: (b -> a -> b) -> b -> Tree n a -> b
ifoldl :: (Wrd n -> b -> a -> b) -> b -> Tree n a -> b

-- | <pre>
--   &gt;&gt;&gt; length (universe :: Tree N.Nat3 (Wrd N.Nat3))
--   8
--   </pre>
length :: Tree n a -> Int

null :: Tree n a -> Bool

-- | Non-strict <a>sum</a>.
sum :: Num a => Tree n a -> a

-- | Non-strict <a>product</a>.
product :: Num a => Tree n a -> a

-- | <pre>
--   &gt;&gt;&gt; map not $ Node (Leaf True) (Leaf False)
--   Node (Leaf False) (Leaf True)
--   </pre>
map :: (a -> b) -> Tree n a -> Tree n b

-- | <pre>
--   &gt;&gt;&gt; imap (,) $ Node (Leaf True) (Leaf False)
--   Node (Leaf (0b0,True)) (Leaf (0b1,False))
--   </pre>
imap :: (Wrd n -> a -> b) -> Tree n a -> Tree n b
traverse :: Applicative f => (a -> f b) -> Tree n a -> f (Tree n b)
itraverse :: Applicative f => (Wrd n -> a -> f b) -> Tree n a -> f (Tree n b)
traverse1 :: Apply f => (a -> f b) -> Tree n a -> f (Tree n b)
itraverse1 :: Apply f => (Wrd n -> a -> f b) -> Tree n a -> f (Tree n b)

itraverse_ :: forall n f a b. Applicative f => (Wrd n -> a -> f b) -> Tree n a -> f ()

-- | Zip two <tt>Vec</tt>s with a function.
zipWith :: (a -> b -> c) -> Tree n a -> Tree n b -> Tree n c

-- | Zip two <a>Tree</a>s. with a function that also takes the elements'
--   indices.
izipWith :: (Wrd n -> a -> b -> c) -> Tree n a -> Tree n b -> Tree n c

-- | Repeat a value.
--   
--   <pre>
--   &gt;&gt;&gt; repeat 'x' :: Tree N.Nat2 Char
--   Node (Node (Leaf 'x') (Leaf 'x')) (Node (Leaf 'x') (Leaf 'x'))
--   </pre>
repeat :: SNatI n => a -> Tree n a

-- | Get all <tt><tt>Vec</tt> n <a>Bool</a></tt> indices in <tt><a>Tree</a>
--   n</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; universe :: Tree N.Nat2 (Wrd N.Nat2)
--   Node (Node (Leaf 0b00) (Leaf 0b01)) (Node (Leaf 0b10) (Leaf 0b11))
--   </pre>
universe :: SNatI n => Tree n (Wrd n)
liftArbitrary :: forall n a. SNatI n => Gen a -> Gen (Tree n a)
liftShrink :: forall n a. (a -> [a]) -> Tree n a -> [Tree n a]
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.RAVec.Tree.Tree n a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.RAVec.Tree.Tree n a)
instance GHC.Show.Show a => GHC.Show.Show (Data.RAVec.Tree.Tree n a)
instance GHC.Base.Functor (Data.RAVec.Tree.Tree n)
instance Data.Foldable.Foldable (Data.RAVec.Tree.Tree n)
instance Data.Traversable.Traversable (Data.RAVec.Tree.Tree n)
instance WithIndex.FunctorWithIndex (Data.Wrd.Wrd n) (Data.RAVec.Tree.Tree n)
instance WithIndex.FoldableWithIndex (Data.Wrd.Wrd n) (Data.RAVec.Tree.Tree n)
instance WithIndex.TraversableWithIndex (Data.Wrd.Wrd n) (Data.RAVec.Tree.Tree n)
instance Data.Semigroup.Foldable.Class.Foldable1 (Data.RAVec.Tree.Tree n)
instance Data.Semigroup.Traversable.Class.Traversable1 (Data.RAVec.Tree.Tree n)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.RAVec.Tree.Tree n a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Data.RAVec.Tree.Tree n a)
instance Data.Type.Nat.SNatI n => GHC.Base.Applicative (Data.RAVec.Tree.Tree n)
instance Data.Type.Nat.SNatI n => Data.Distributive.Distributive (Data.RAVec.Tree.Tree n)
instance Data.Type.Nat.SNatI n => Data.Functor.Rep.Representable (Data.RAVec.Tree.Tree n)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.RAVec.Tree.Tree n a)
instance Data.Functor.Bind.Class.Apply (Data.RAVec.Tree.Tree n)
instance Data.Type.Nat.SNatI n => Test.QuickCheck.Arbitrary.Arbitrary1 (Data.RAVec.Tree.Tree n)
instance (Data.Type.Nat.SNatI n, Test.QuickCheck.Arbitrary.Arbitrary a) => Test.QuickCheck.Arbitrary.Arbitrary (Data.RAVec.Tree.Tree n a)
instance Test.QuickCheck.Arbitrary.CoArbitrary a => Test.QuickCheck.Arbitrary.CoArbitrary (Data.RAVec.Tree.Tree n a)
instance (Data.Type.Nat.SNatI n, Test.QuickCheck.Function.Function a) => Test.QuickCheck.Function.Function (Data.RAVec.Tree.Tree n a)


-- | Depth indexed perfect tree as data family.
module Data.RAVec.Tree.DF
data family Tree (n :: Nat) a

-- | <a>Tree</a> with exactly one element.
--   
--   <pre>
--   &gt;&gt;&gt; singleton True
--   Leaf True
--   </pre>
singleton :: a -> Tree 'Z a

-- | Convert <a>Tree</a> to list.
--   
--   <pre>
--   &gt;&gt;&gt; toList $ Node (Node (Leaf 'f') (Leaf 'o')) (Node (Leaf 'o') (Leaf 'd'))
--   "food"
--   </pre>
toList :: forall n a. SNatI n => Tree n a -> [a]

-- | Reverse <a>Tree</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let t = Node (Node (Leaf 'a') (Leaf 'b')) (Node (Leaf 'c') (Leaf 'd'))
--   
--   &gt;&gt;&gt; reverse t
--   Node (Node (Leaf 'd') (Leaf 'c')) (Node (Leaf 'b') (Leaf 'a'))
--   </pre>
reverse :: forall n a. SNatI n => Tree n a -> Tree n a

-- | Indexing.
--   
--   <pre>
--   &gt;&gt;&gt; let t = Node (Node (Leaf 'a') (Leaf 'b')) (Node (Leaf 'c') (Leaf 'd'))
--   
--   &gt;&gt;&gt; t ! W1 (W0 WE)
--   'c'
--   </pre>
(!) :: SNatI n => Tree n a -> Wrd n -> a

-- | Tabulating, inverse of <a>!</a>.
--   
--   <pre>
--   &gt;&gt;&gt; tabulate id :: Tree N.Nat2 (Wrd N.Nat2)
--   Node (Node (Leaf 0b00) (Leaf 0b01)) (Node (Leaf 0b10) (Leaf 0b11))
--   </pre>
tabulate :: SNatI n => (Wrd n -> a) -> Tree n a
leftmost :: SNatI n => Tree n a -> a
rightmost :: SNatI n => Tree n a -> a

-- | See <a>Foldable</a>.
foldMap :: forall a n m. (Monoid m, SNatI n) => (a -> m) -> Tree n a -> m

-- | See <a>Foldable1</a>.
foldMap1 :: forall s a n. (Semigroup s, SNatI n) => (a -> s) -> Tree n a -> s

-- | See <a>FoldableWithIndex</a>.
ifoldMap :: forall a n m. (Monoid m, SNatI n) => (Wrd n -> a -> m) -> Tree n a -> m

-- | There is no type-class for this :(
ifoldMap1 :: forall a n s. (Semigroup s, SNatI n) => (Wrd ('S n) -> a -> s) -> Tree ('S n) a -> s

-- | Right fold.
foldr :: forall a b n. SNatI n => (a -> b -> b) -> b -> Tree n a -> b

-- | Right fold with an index.
ifoldr :: forall a b n. SNatI n => (Wrd n -> a -> b -> b) -> b -> Tree n a -> b
foldr1Map :: forall a b n. SNatI n => (a -> b -> b) -> (a -> b) -> Tree n a -> b
ifoldr1Map :: (Wrd n -> a -> b -> b) -> (Wrd n -> a -> b) -> Tree n a -> b

-- | Left fold.
foldl :: forall a b n. SNatI n => (b -> a -> b) -> b -> Tree n a -> b

-- | Left fold with an index.
ifoldl :: forall a b n. SNatI n => (Wrd n -> b -> a -> b) -> b -> Tree n a -> b

-- | Yield the length of a <a>Tree</a>. <i>O(n)</i>
length :: forall n a. SNatI n => Tree n a -> Int

-- | Test whether a <a>Tree</a> is empty. It never is. <i>O(1)</i>
null :: Tree n a -> Bool

-- | Non-strict <a>sum</a>.
sum :: (Num a, SNatI n) => Tree n a -> a

-- | Non-strict <a>product</a>.
product :: (Num a, SNatI n) => Tree n a -> a

-- | <pre>
--   &gt;&gt;&gt; map not $ Node (Leaf True) (Leaf False)
--   Node (Leaf False) (Leaf True)
--   </pre>
map :: forall a b n. SNatI n => (a -> b) -> Tree n a -> Tree n b

-- | <pre>
--   &gt;&gt;&gt; let t = Node (Node (Leaf 'a') (Leaf 'b')) (Node (Leaf 'c') (Leaf 'd'))
--   
--   &gt;&gt;&gt; imap (,) t
--   Node (Node (Leaf (0b00,'a')) (Leaf (0b01,'b'))) (Node (Leaf (0b10,'c')) (Leaf (0b11,'d')))
--   </pre>
imap :: SNatI n => (Wrd n -> a -> b) -> Tree n a -> Tree n b

-- | Apply an action to every element of a <a>Tree</a>, yielding a
--   <a>Tree</a> of results.
traverse :: forall n f a b. (Applicative f, SNatI n) => (a -> f b) -> Tree n a -> f (Tree n b)

-- | Apply an action to every element of a <a>Tree</a> and its index,
--   yielding a <a>Tree</a> of results.
itraverse :: forall n f a b. (Applicative f, SNatI n) => (Wrd n -> a -> f b) -> Tree n a -> f (Tree n b)

-- | Apply an action to non-empty <a>Tree</a>, yielding a <a>Tree</a> of
--   results.
traverse1 :: forall n f a b. (Apply f, SNatI n) => (a -> f b) -> Tree n a -> f (Tree n b)
itraverse1 :: forall n f a b. (Apply f, SNatI n) => (Wrd n -> a -> f b) -> Tree n a -> f (Tree n b)

-- | Apply an action to every element of a <a>Tree</a> and its index,
--   ignoring the results.
itraverse_ :: forall n f a b. (Applicative f, SNatI n) => (Wrd n -> a -> f b) -> Tree n a -> f ()

-- | Zip two <a>Tree</a>s with a function.
zipWith :: forall a b c n. SNatI n => (a -> b -> c) -> Tree n a -> Tree n b -> Tree n c

-- | Zip two <a>Tree</a>s. with a function that also takes the elements'
--   indices.
izipWith :: SNatI n => (Wrd n -> a -> b -> c) -> Tree n a -> Tree n b -> Tree n c

-- | Repeat value
--   
--   <pre>
--   &gt;&gt;&gt; repeat 'x' :: Tree N.Nat2 Char
--   Node (Node (Leaf 'x') (Leaf 'x')) (Node (Leaf 'x') (Leaf 'x'))
--   </pre>
repeat :: SNatI n => x -> Tree n x

-- | Get all <tt><a>Wrd</a> n</tt> in a <tt><a>Tree</a> n</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; universe :: Tree N.Nat2 (Wrd N.Nat2)
--   Node (Node (Leaf 0b00) (Leaf 0b01)) (Node (Leaf 0b10) (Leaf 0b11))
--   </pre>
universe :: SNatI n => Tree n (Wrd n)
liftArbitrary :: forall n a. SNatI n => Gen a -> Gen (Tree n a)
liftShrink :: forall n a. SNatI n => (a -> [a]) -> Tree n a -> [Tree n a]

-- | Ensure spine.
--   
--   If we have an undefined <a>Tree</a>,
--   
--   <pre>
--   &gt;&gt;&gt; let v = error "err" :: Tree N.Nat2 Char
--   </pre>
--   
--   And insert data into it later:
--   
--   <pre>
--   &gt;&gt;&gt; let setHead :: a -&gt; Tree N.Nat2 a -&gt; Tree N.Nat2 a; setHead x (Node (Node _ u) v) = Node (Node (Leaf x) u) v
--   </pre>
--   
--   Then without a spine, it will fail:
--   
--   <pre>
--   &gt;&gt;&gt; leftmost $ setHead 'x' v
--   *** Exception: err
--   ...
--   </pre>
--   
--   But with the spine, it won't:
--   
--   <pre>
--   &gt;&gt;&gt; leftmost $ setHead 'x' $ ensureSpine v
--   'x'
--   </pre>
ensureSpine :: SNatI n => Tree n a -> Tree n a
instance (Data.Hashable.Class.Hashable a, Data.Type.Nat.SNatI n) => Data.Hashable.Class.Hashable (Data.RAVec.Tree.DF.Tree n a)
instance (Control.DeepSeq.NFData a, Data.Type.Nat.SNatI n) => Control.DeepSeq.NFData (Data.RAVec.Tree.DF.Tree n a)
instance (GHC.Show.Show a, Data.Type.Nat.SNatI n) => GHC.Show.Show (Data.RAVec.Tree.DF.Tree n a)
instance (GHC.Classes.Ord a, Data.Type.Nat.SNatI n) => GHC.Classes.Ord (Data.RAVec.Tree.DF.Tree n a)
instance (GHC.Classes.Eq a, Data.Type.Nat.SNatI n) => GHC.Classes.Eq (Data.RAVec.Tree.DF.Tree n a)
instance Data.Type.Nat.SNatI n => GHC.Base.Functor (Data.RAVec.Tree.DF.Tree n)
instance Data.Type.Nat.SNatI n => Data.Foldable.Foldable (Data.RAVec.Tree.DF.Tree n)
instance Data.Type.Nat.SNatI n => Data.Semigroup.Foldable.Class.Foldable1 (Data.RAVec.Tree.DF.Tree n)
instance Data.Type.Nat.SNatI n => Data.Semigroup.Traversable.Class.Traversable1 (Data.RAVec.Tree.DF.Tree n)
instance Data.Type.Nat.SNatI n => Data.Traversable.Traversable (Data.RAVec.Tree.DF.Tree n)
instance Data.Type.Nat.SNatI n => WithIndex.FunctorWithIndex (Data.Wrd.Wrd n) (Data.RAVec.Tree.DF.Tree n)
instance Data.Type.Nat.SNatI n => WithIndex.FoldableWithIndex (Data.Wrd.Wrd n) (Data.RAVec.Tree.DF.Tree n)
instance Data.Type.Nat.SNatI n => WithIndex.TraversableWithIndex (Data.Wrd.Wrd n) (Data.RAVec.Tree.DF.Tree n)
instance Data.Type.Nat.SNatI n => GHC.Base.Applicative (Data.RAVec.Tree.DF.Tree n)
instance Data.Type.Nat.SNatI n => Data.Distributive.Distributive (Data.RAVec.Tree.DF.Tree n)
instance Data.Type.Nat.SNatI n => Data.Functor.Rep.Representable (Data.RAVec.Tree.DF.Tree n)
instance (GHC.Base.Semigroup a, Data.Type.Nat.SNatI n) => GHC.Base.Semigroup (Data.RAVec.Tree.DF.Tree n a)
instance (GHC.Base.Monoid a, Data.Type.Nat.SNatI n) => GHC.Base.Monoid (Data.RAVec.Tree.DF.Tree n a)
instance Data.Type.Nat.SNatI n => Data.Functor.Bind.Class.Apply (Data.RAVec.Tree.DF.Tree n)
instance Data.Type.Nat.SNatI n => Test.QuickCheck.Arbitrary.Arbitrary1 (Data.RAVec.Tree.DF.Tree n)
instance (Data.Type.Nat.SNatI n, Test.QuickCheck.Arbitrary.Arbitrary a) => Test.QuickCheck.Arbitrary.Arbitrary (Data.RAVec.Tree.DF.Tree n a)
instance (Data.Type.Nat.SNatI n, Test.QuickCheck.Arbitrary.CoArbitrary a) => Test.QuickCheck.Arbitrary.CoArbitrary (Data.RAVec.Tree.DF.Tree n a)
instance (Data.Type.Nat.SNatI n, Test.QuickCheck.Function.Function a) => Test.QuickCheck.Function.Function (Data.RAVec.Tree.DF.Tree n a)


-- | Non-empty length-indexed random access list.
module Data.RAVec.NonEmpty

-- | Non-empty random access list.
newtype NERAVec (b :: BinP) a
NE :: NERAVec' 'Z b a -> NERAVec (b :: BinP) a

-- | Non-empty random access list, undelying representation.
data NERAVec' (n :: Nat) (b :: BinP) a
[Last] :: Tree n a -> NERAVec' n 'BE a
[Cons0] :: NERAVec' ('S n) b a -> NERAVec' n ('B0 b) a
[Cons1] :: Tree n a -> NERAVec' ('S n) b a -> NERAVec' n ('B1 b) a
singleton :: forall a. a -> NERAVec BinP1 a
singleton' :: a -> NERAVec' 'Z BinP1 a

-- | <a>cons</a> for non-empty rals.
cons :: forall a b. a -> NERAVec b a -> NERAVec (Succ b) a
consTree :: Tree n a -> NERAVec' n b a -> NERAVec' n (Succ b) a

-- | <a>withCons</a> for non-empty rals.
withCons :: SBinPI b => a -> NERAVec b a -> (SBinPI (Succ b) => NERAVec (Succ b) a -> r) -> r
withConsTree :: SBinP b -> Tree n a -> NERAVec' n b a -> (SBinPI (Succ b) => NERAVec' n (Succ b) a -> r) -> r
toList :: NERAVec b a -> [a]
toList' :: NERAVec' n b a -> [a]
toNonEmpty :: NERAVec b a -> NonEmpty a
toNonEmpty' :: NERAVec' n b a -> NonEmpty a
reifyNonEmpty :: NonEmpty a -> (forall b. SBinPI b => NERAVec b a -> r) -> r
reifyNonEmpty' :: forall a r. NonEmpty a -> (forall b. SBinPI b => NERAVec' 'Z b a -> r) -> r
(!) :: NERAVec b a -> PosP b -> a
index' :: NERAVec' n b a -> PosP' n b -> a
tabulate :: SBinPI b => (PosP b -> a) -> NERAVec b a
tabulate' :: forall b n a. (SBinPI b, SNatI n) => (PosP' n b -> a) -> NERAVec' n b a
unsingleton :: NERAVec 'BE a -> a
head :: NERAVec b a -> a
head' :: NERAVec' n b a -> a
last :: NERAVec b a -> a
last' :: NERAVec' n b a -> a
foldMap :: Monoid m => (a -> m) -> NERAVec b a -> m
foldMap' :: Monoid m => (a -> m) -> NERAVec' n b a -> m
foldMap1 :: Semigroup m => (a -> m) -> NERAVec b a -> m
foldMap1' :: Semigroup m => (a -> m) -> NERAVec' n b a -> m
ifoldMap :: Monoid m => (PosP b -> a -> m) -> NERAVec b a -> m
ifoldMap' :: Monoid m => (PosP' n b -> a -> m) -> NERAVec' n b a -> m
ifoldMap1 :: Semigroup m => (PosP b -> a -> m) -> NERAVec b a -> m
ifoldMap1' :: Semigroup m => (PosP' n b -> a -> m) -> NERAVec' n b a -> m
foldr :: (a -> b -> b) -> b -> NERAVec m a -> b
foldr' :: (a -> b -> b) -> b -> NERAVec' n m a -> b
ifoldr :: (PosP m -> a -> b -> b) -> b -> NERAVec m a -> b
ifoldr' :: (PosP' n m -> a -> b -> b) -> b -> NERAVec' n m a -> b
foldr1Map :: (a -> b -> b) -> (a -> b) -> NERAVec m a -> b
foldr1Map' :: (a -> b -> b) -> (a -> b) -> NERAVec' n m a -> b
ifoldr1Map :: (PosP m -> a -> b -> b) -> (PosP m -> a -> b) -> NERAVec m a -> b
ifoldr1Map' :: (PosP' n m -> a -> b -> b) -> (PosP' n m -> a -> b) -> NERAVec' n m a -> b
map :: (a -> b) -> NERAVec m a -> NERAVec m b
map' :: (a -> b) -> NERAVec' n m a -> NERAVec' n m b
imap :: (PosP m -> a -> b) -> NERAVec m a -> NERAVec m b
imap' :: (PosP' n m -> a -> b) -> NERAVec' n m a -> NERAVec' n m b
traverse :: Applicative f => (a -> f b) -> NERAVec m a -> f (NERAVec m b)
traverse' :: Applicative f => (a -> f b) -> NERAVec' n m a -> f (NERAVec' n m b)
itraverse :: Applicative f => (PosP m -> a -> f b) -> NERAVec m a -> f (NERAVec m b)
itraverse' :: Applicative f => (PosP' n m -> a -> f b) -> NERAVec' n m a -> f (NERAVec' n m b)
traverse1 :: Apply f => (a -> f b) -> NERAVec m a -> f (NERAVec m b)
traverse1' :: Apply f => (a -> f b) -> NERAVec' n m a -> f (NERAVec' n m b)
itraverse1 :: Apply f => (PosP m -> a -> f b) -> NERAVec m a -> f (NERAVec m b)
itraverse1' :: Apply f => (PosP' n m -> a -> f b) -> NERAVec' n m a -> f (NERAVec' n m b)
zipWith :: (a -> b -> c) -> NERAVec m a -> NERAVec m b -> NERAVec m c

-- | Zip two <a>NERAVec'</a>s with a function.
zipWith' :: (a -> b -> c) -> NERAVec' n m a -> NERAVec' n m b -> NERAVec' n m c
izipWith :: (PosP m -> a -> b -> c) -> NERAVec m a -> NERAVec m b -> NERAVec m c

-- | Zip two <a>NERAVec'</a>s with a function which also takes <a>PosP'</a>
--   index.
izipWith' :: (PosP' n m -> a -> b -> c) -> NERAVec' n m a -> NERAVec' n m b -> NERAVec' n m c
repeat :: SBinPI b => a -> NERAVec b a
repeat' :: forall b n a. (SNatI n, SBinPI b) => a -> NERAVec' n b a
universe :: forall b. SBinPI b => NERAVec b (PosP b)
universe' :: forall n b. (SNatI n, SBinPI b) => NERAVec' n b (PosP' n b)
liftArbitrary :: SBinPI b => Gen a -> Gen (NERAVec b a)
liftArbitrary' :: forall b n a. (SBinPI b, SNatI n) => Gen a -> Gen (NERAVec' n b a)
liftShrink :: (a -> [a]) -> NERAVec b a -> [NERAVec b a]
liftShrink' :: forall b n a. (a -> [a]) -> NERAVec' n b a -> [NERAVec' n b a]
instance GHC.Show.Show a => GHC.Show.Show (Data.RAVec.NonEmpty.NERAVec b a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.RAVec.NonEmpty.NERAVec b a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.RAVec.NonEmpty.NERAVec b a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.RAVec.NonEmpty.NERAVec' n b a)
instance GHC.Show.Show a => GHC.Show.Show (Data.RAVec.NonEmpty.NERAVec' n b a)
instance GHC.Base.Functor (Data.RAVec.NonEmpty.NERAVec b)
instance Data.Foldable.Foldable (Data.RAVec.NonEmpty.NERAVec b)
instance Data.Traversable.Traversable (Data.RAVec.NonEmpty.NERAVec b)
instance WithIndex.FunctorWithIndex (Data.BinP.PosP.PosP n) (Data.RAVec.NonEmpty.NERAVec n)
instance WithIndex.FoldableWithIndex (Data.BinP.PosP.PosP n) (Data.RAVec.NonEmpty.NERAVec n)
instance WithIndex.TraversableWithIndex (Data.BinP.PosP.PosP n) (Data.RAVec.NonEmpty.NERAVec n)
instance Data.Semigroup.Foldable.Class.Foldable1 (Data.RAVec.NonEmpty.NERAVec b)
instance Data.Semigroup.Traversable.Class.Traversable1 (Data.RAVec.NonEmpty.NERAVec b)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.RAVec.NonEmpty.NERAVec b a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Data.RAVec.NonEmpty.NERAVec b a)
instance Data.Type.BinP.SBinPI b => GHC.Base.Applicative (Data.RAVec.NonEmpty.NERAVec b)
instance Data.Type.BinP.SBinPI b => Data.Distributive.Distributive (Data.RAVec.NonEmpty.NERAVec b)
instance Data.Type.BinP.SBinPI b => Data.Functor.Rep.Representable (Data.RAVec.NonEmpty.NERAVec b)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.RAVec.NonEmpty.NERAVec b a)
instance (GHC.Base.Monoid a, Data.Type.BinP.SBinPI b) => GHC.Base.Monoid (Data.RAVec.NonEmpty.NERAVec b a)
instance Data.Functor.Bind.Class.Apply (Data.RAVec.NonEmpty.NERAVec b)
instance Data.Type.BinP.SBinPI b => Test.QuickCheck.Arbitrary.Arbitrary1 (Data.RAVec.NonEmpty.NERAVec b)
instance (Data.Type.BinP.SBinPI b, Test.QuickCheck.Arbitrary.Arbitrary a) => Test.QuickCheck.Arbitrary.Arbitrary (Data.RAVec.NonEmpty.NERAVec b a)
instance Test.QuickCheck.Arbitrary.CoArbitrary a => Test.QuickCheck.Arbitrary.CoArbitrary (Data.RAVec.NonEmpty.NERAVec b a)
instance (Data.Type.BinP.SBinPI b, Test.QuickCheck.Function.Function a) => Test.QuickCheck.Function.Function (Data.RAVec.NonEmpty.NERAVec b a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.RAVec.NonEmpty.NERAVec' n b a)
instance GHC.Base.Functor (Data.RAVec.NonEmpty.NERAVec' n b)
instance Data.Foldable.Foldable (Data.RAVec.NonEmpty.NERAVec' n b)
instance Data.Traversable.Traversable (Data.RAVec.NonEmpty.NERAVec' n b)
instance WithIndex.FunctorWithIndex (Data.BinP.PosP.PosP' n m) (Data.RAVec.NonEmpty.NERAVec' n m)
instance WithIndex.FoldableWithIndex (Data.BinP.PosP.PosP' n m) (Data.RAVec.NonEmpty.NERAVec' n m)
instance WithIndex.TraversableWithIndex (Data.BinP.PosP.PosP' n m) (Data.RAVec.NonEmpty.NERAVec' n m)
instance Data.Semigroup.Foldable.Class.Foldable1 (Data.RAVec.NonEmpty.NERAVec' n b)
instance Data.Semigroup.Traversable.Class.Traversable1 (Data.RAVec.NonEmpty.NERAVec' n b)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.RAVec.NonEmpty.NERAVec' n b a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Data.RAVec.NonEmpty.NERAVec' n b a)
instance (Data.Type.BinP.SBinPI b, Data.Type.Nat.SNatI n) => GHC.Base.Applicative (Data.RAVec.NonEmpty.NERAVec' n b)
instance (Data.Type.BinP.SBinPI b, Data.Type.Nat.SNatI n) => Data.Distributive.Distributive (Data.RAVec.NonEmpty.NERAVec' n b)
instance (Data.Type.BinP.SBinPI b, Data.Type.Nat.SNatI n) => Data.Functor.Rep.Representable (Data.RAVec.NonEmpty.NERAVec' n b)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.RAVec.NonEmpty.NERAVec' n b a)
instance (GHC.Base.Monoid a, Data.Type.BinP.SBinPI b, Data.Type.Nat.SNatI n) => GHC.Base.Monoid (Data.RAVec.NonEmpty.NERAVec' n b a)
instance Data.Functor.Bind.Class.Apply (Data.RAVec.NonEmpty.NERAVec' n b)
instance (Data.Type.BinP.SBinPI b, Data.Type.Nat.SNatI n) => Test.QuickCheck.Arbitrary.Arbitrary1 (Data.RAVec.NonEmpty.NERAVec' n b)
instance Test.QuickCheck.Arbitrary.CoArbitrary a => Test.QuickCheck.Arbitrary.CoArbitrary (Data.RAVec.NonEmpty.NERAVec' n b a)
instance (Data.Type.Nat.SNatI n, Data.Type.BinP.SBinPI b, Test.QuickCheck.Function.Function a) => Test.QuickCheck.Function.Function (Data.RAVec.NonEmpty.NERAVec' n b a)


-- | Length-indexed random access list.
--   
--   See
--   <a>http://www.staff.science.uu.nl/~swier004/publications/2019-jfp-submission.pdf</a>
module Data.RAVec

-- | Length indexed random access lists.
data RAVec (b :: Bin) a
[Empty] :: RAVec 'BZ a
[NonEmpty] :: NERAVec b a -> RAVec ('BP b) a
empty :: RAVec Bin0 a
singleton :: a -> RAVec Bin1 a

-- | Cons an element in front of <a>RAVec</a>.
--   
--   <pre>
--   &gt;&gt;&gt; reifyList "xyz" (print . toList . cons 'a')
--   "axyz"
--   </pre>
cons :: a -> RAVec b a -> RAVec (Succ b) a

-- | Variant of <a>cons</a> which computes the <a>SBinI</a> dictionary at
--   the same time.
withCons :: SBinI b => a -> RAVec b a -> (SBinPI (Succ' b) => RAVec (Succ b) a -> r) -> r

-- | The first element of a non-empty <a>RAVec</a>.
--   
--   <pre>
--   &gt;&gt;&gt; reifyNonEmpty ('x' :| "yz") head
--   'x'
--   </pre>
head :: RAVec ('BP b) a -> a

-- | The last element of a non-empty <a>RAVec</a>.
--   
--   <pre>
--   &gt;&gt;&gt; reifyNonEmpty ('x' :| "yz") last
--   'z'
--   </pre>
last :: RAVec ('BP b) a -> a
toList :: RAVec b a -> [a]
toNonEmpty :: RAVec ('BP b) a -> NonEmpty a

-- | Convert a list <tt>[a]</tt> to <tt><a>RAVec</a> b a</tt>. Returns
--   <a>Nothing</a> if lengths don't match.
--   
--   <pre>
--   &gt;&gt;&gt; fromList "foo" :: Maybe (RAVec B.Bin3 Char)
--   Just (NonEmpty (NE (Cons1 (Leaf 'f') (Last (Node (Leaf 'o') (Leaf 'o'))))))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromList "quux" :: Maybe (RAVec B.Bin3 Char)
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromList "xy" :: Maybe (RAVec B.Bin3 Char)
--   Nothing
--   </pre>
fromList :: forall b a. SBinI b => [a] -> Maybe (RAVec b a)

-- | <pre>
--   &gt;&gt;&gt; reifyList "foo" print
--   NonEmpty (NE (Cons1 (Leaf 'f') (Last (Node (Leaf 'o') (Leaf 'o')))))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; reifyList "xyzzy" toList
--   "xyzzy"
--   </pre>
reifyList :: [a] -> (forall b. SBinI b => RAVec b a -> r) -> r
reifyNonEmpty :: NonEmpty a -> (forall b. SBinPI b => RAVec ('BP b) a -> r) -> r

-- | Indexing.
--   
--   <pre>
--   &gt;&gt;&gt; let ral :: RAVec B.Bin4 Char; Just ral = fromList "abcd"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ral ! minBound
--   'a'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ral ! maxBound
--   'd'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ral ! pop top
--   'b'
--   </pre>
(!) :: RAVec b a -> Pos b -> a
tabulate :: forall b a. SBinI b => (Pos b -> a) -> RAVec b a
foldMap :: Monoid m => (a -> m) -> RAVec n a -> m
foldMap1 :: Semigroup m => (a -> m) -> RAVec ('BP b) a -> m
ifoldMap :: Monoid m => (Pos b -> a -> m) -> RAVec b a -> m
ifoldMap1 :: Semigroup m => (Pos ('BP b) -> a -> m) -> RAVec ('BP b) a -> m
foldr :: (a -> b -> b) -> b -> RAVec n a -> b
ifoldr :: (Pos n -> a -> b -> b) -> b -> RAVec n a -> b
null :: RAVec n a -> Bool
map :: (a -> b) -> RAVec n a -> RAVec n b
imap :: (Pos n -> a -> b) -> RAVec n a -> RAVec n b
traverse :: Applicative f => (a -> f b) -> RAVec n a -> f (RAVec n b)
itraverse :: Applicative f => (Pos n -> a -> f b) -> RAVec n a -> f (RAVec n b)
traverse1 :: Apply f => (a -> f b) -> RAVec ('BP n) a -> f (RAVec ('BP n) b)
itraverse1 :: Apply f => (Pos ('BP n) -> a -> f b) -> RAVec ('BP n) a -> f (RAVec ('BP n) b)

-- | Zip two <a>RAVec</a>s with a function.
zipWith :: (a -> b -> c) -> RAVec n a -> RAVec n b -> RAVec n c

-- | Zip two <a>RAVec</a>s with a function which also takes <a>Pos</a>
--   index.
izipWith :: (Pos n -> a -> b -> c) -> RAVec n a -> RAVec n b -> RAVec n c

-- | <pre>
--   &gt;&gt;&gt; universe :: RAVec B.Bin2 (Pos B.Bin2)
--   NonEmpty (NE (Cons0 (Last (Node (Leaf 0) (Leaf 1)))))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let u = universe :: RAVec B.Bin3 (Pos B.Bin3)
--   
--   &gt;&gt;&gt; u
--   NonEmpty (NE (Cons1 (Leaf 0) (Last (Node (Leaf 1) (Leaf 2)))))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; P.explicitShow $ u ! Pos (PosP (Here WE))
--   "Pos (PosP (Here WE))"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let u' = universe :: RAVec B.Bin5 (Pos B.Bin5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toList u' == sort (toList u')
--   True
--   </pre>
universe :: forall b. SBinI b => RAVec b (Pos b)

-- | Repeat a value.
--   
--   <pre>
--   &gt;&gt;&gt; repeat 'x' :: RAVec B.Bin5 Char
--   NonEmpty (NE (Cons1 (Leaf 'x') (Cons0 (Last (Node (Node (Leaf 'x') (Leaf 'x')) (Node (Leaf 'x') (Leaf 'x')))))))
--   </pre>
repeat :: forall b a. SBinI b => a -> RAVec b a
liftArbitrary :: SBinI b => Gen a -> Gen (RAVec b a)
liftShrink :: (a -> [a]) -> RAVec b a -> [RAVec b a]
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.RAVec.RAVec b a)
instance GHC.Show.Show a => GHC.Show.Show (Data.RAVec.RAVec b a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.RAVec.RAVec b a)
instance GHC.Base.Functor (Data.RAVec.RAVec b)
instance Data.Foldable.Foldable (Data.RAVec.RAVec b)
instance Data.Traversable.Traversable (Data.RAVec.RAVec b)
instance WithIndex.FunctorWithIndex (Data.Bin.Pos.Pos n) (Data.RAVec.RAVec n)
instance WithIndex.FoldableWithIndex (Data.Bin.Pos.Pos n) (Data.RAVec.RAVec n)
instance WithIndex.TraversableWithIndex (Data.Bin.Pos.Pos n) (Data.RAVec.RAVec n)
instance ((b :: Data.Bin.Bin) GHC.Types.~ ('Data.Bin.BP n :: Data.Bin.Bin)) => Data.Semigroup.Foldable.Class.Foldable1 (Data.RAVec.RAVec b)
instance ((b :: Data.Bin.Bin) GHC.Types.~ ('Data.Bin.BP n :: Data.Bin.Bin)) => Data.Semigroup.Traversable.Class.Traversable1 (Data.RAVec.RAVec b)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.RAVec.RAVec b a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Data.RAVec.RAVec b a)
instance Data.Type.Bin.SBinI b => GHC.Base.Applicative (Data.RAVec.RAVec b)
instance Data.Type.Bin.SBinI b => Data.Distributive.Distributive (Data.RAVec.RAVec b)
instance Data.Type.Bin.SBinI b => Data.Functor.Rep.Representable (Data.RAVec.RAVec b)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.RAVec.RAVec b a)
instance (GHC.Base.Monoid a, Data.Type.Bin.SBinI b) => GHC.Base.Monoid (Data.RAVec.RAVec b a)
instance Data.Functor.Bind.Class.Apply (Data.RAVec.RAVec b)
instance ((b :: Data.Bin.Bin) GHC.Types.~ ('Data.Bin.BZ :: Data.Bin.Bin)) => Data.Boring.Boring (Data.RAVec.RAVec b a)
instance Data.Type.Bin.SBinI b => Test.QuickCheck.Arbitrary.Arbitrary1 (Data.RAVec.RAVec b)
instance (Data.Type.Bin.SBinI b, Test.QuickCheck.Arbitrary.Arbitrary a) => Test.QuickCheck.Arbitrary.Arbitrary (Data.RAVec.RAVec b a)
instance Test.QuickCheck.Arbitrary.CoArbitrary a => Test.QuickCheck.Arbitrary.CoArbitrary (Data.RAVec.RAVec b a)
instance (Data.Type.Bin.SBinI b, Test.QuickCheck.Function.Function a) => Test.QuickCheck.Function.Function (Data.RAVec.RAVec b a)
