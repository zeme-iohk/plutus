-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package prettyprinter-configurable
@version 1.1.0.0


-- | Precedence-general machinery for deciding whether an expression needs
--   to be wrapped in parentheses or not. Source code has comments on the
--   approach used and how it compares to some other known approaches.
module Text.Fixity.Internal

-- | Associativity of an operator.
data Associativity
LeftAssociative :: Associativity
RightAssociative :: Associativity
NonAssociative :: Associativity

-- | Fixity of an operator.
--   
--   We allow unary operators to have associativity, because it's useful to
--   distinguish between an expression like <tt>-(-x)</tt> (unary minus,
--   left-associative) and <tt>~~b</tt> (boolean NOT, right-associative).
--   
--   Associativity of unary operators also matters when pretty-printing
--   expressions like <tt>(-x) + y</tt>, which is pretty-printed as <tt>-x
--   + y</tt>, assuming unary minus has the same fixity as <tt>+</tt> (and
--   both the operators are left-associative). I.e. unary minus is handled
--   just like the binary one: <tt>(0 - x) + y</tt> is pretty-printed as
--   <tt>0 - x + y</tt>.
--   
--   Postfix operators are handled similarly. E.g. if <tt>!</tt> is
--   left-associative, then <tt>(x!)!</tt> is pretty-printed as
--   <tt>x!!</tt> and if it's right-associative -- <tt>(x!)!</tt>.
--   
--   The data type is parameterized, so that the user can choose precedence
--   to be integer/fractional, bounded/unbounded, etc (we could also allows
--   operators to be partially or totally ordered, but at the moment
--   <tt>prec</tt> is required to implement <a>Ord</a>, i.e. it has to be
--   totally ordered). By default we go with bounded fractional precedence,
--   see the main <a>Text.Fixity</a> module.
data FixityOver prec
Fixity :: !Associativity -> !prec -> FixityOver prec
[_fixityAssociativity] :: FixityOver prec -> !Associativity
[_fixityPrecedence] :: FixityOver prec -> !prec

-- | Direction in which pretty-printing goes. For example in <tt>x + y</tt>
--   <tt>x</tt> is pretty-printed to the left of <tt>+</tt> and <tt>y</tt>
--   is pretty-printed to the right of <tt>+</tt>.
data Direction
ToTheLeft :: Direction
ToTheRight :: Direction

-- | A context that an expression is being rendered in.
data RenderContextOver prec
RenderContext :: !Direction -> !FixityOver prec -> RenderContextOver prec
[_renderContextDirection] :: RenderContextOver prec -> !Direction
[_renderContextFixity] :: RenderContextOver prec -> !FixityOver prec

-- | Enclose an <tt>a</tt> (using the provided function) if required or
--   leave it as is. The need for enclosing is determined from an outer
--   <a>RenderContext</a> and the inner fixity.
encloseIn :: Ord prec => (a -> a) -> RenderContextOver prec -> FixityOver prec -> a -> a
instance GHC.Classes.Eq Text.Fixity.Internal.Associativity
instance GHC.Show.Show Text.Fixity.Internal.Associativity
instance GHC.Classes.Eq prec => GHC.Classes.Eq (Text.Fixity.Internal.FixityOver prec)
instance GHC.Show.Show prec => GHC.Show.Show (Text.Fixity.Internal.FixityOver prec)
instance GHC.Classes.Eq Text.Fixity.Internal.Direction
instance GHC.Show.Show Text.Fixity.Internal.Direction
instance GHC.Classes.Eq prec => GHC.Classes.Eq (Text.Fixity.Internal.RenderContextOver prec)
instance GHC.Show.Show prec => GHC.Show.Show (Text.Fixity.Internal.RenderContextOver prec)


-- | Machinery for deciding whether an expression needs to be wrapped in
--   parentheses or not.
module Text.Fixity

-- | Fractional precedence, so that it's always possible to squeeze an
--   operator precedence between two existing precedences. Ranges over
--   <tt>[-20, 120]</tt>. A normal operator should have a precedence within
--   <tt>[0, 100)</tt>. It might be useful to have a negative precedence if
--   you're trying to model some already existing system, for example in
--   Haskell <tt>($)</tt> has precedence <tt>0</tt>, but clearly <tt>if b
--   then y else f $ x</tt> should be rendered without any parens, hence
--   the precedence of <tt>if_then_else_</tt> is less than 0, i.e.
--   negative.
--   
--   The precedence of juxtaposition is <tt>100</tt>. Normally you want
--   juxtaposition to have the highest precedence, but some languages have
--   operators that bind tighter than juxtaposition, e.g. Haskell's postfix
--   <tt>_{_}</tt>: <tt>f z { x = y }</tt> means <tt>f (z {x = y})</tt>.
type Precedence = Double

-- | Associativity of an operator.
data Associativity
LeftAssociative :: Associativity
RightAssociative :: Associativity
NonAssociative :: Associativity

-- | Fixity of an operator.
--   
--   We allow unary operators to have associativity, because it's useful to
--   distinguish between an expression like <tt>-(-x)</tt> (unary minus,
--   left-associative) and <tt>~~b</tt> (boolean NOT, right-associative).
--   
--   Associativity of unary operators also matters when pretty-printing
--   expressions like <tt>(-x) + y</tt>, which is pretty-printed as <tt>-x
--   + y</tt>, assuming unary minus has the same fixity as <tt>+</tt> (and
--   both the operators are left-associative). I.e. unary minus is handled
--   just like the binary one: <tt>(0 - x) + y</tt> is pretty-printed as
--   <tt>0 - x + y</tt>.
--   
--   Postfix operators are handled similarly. E.g. if <tt>!</tt> is
--   left-associative, then <tt>(x!)!</tt> is pretty-printed as
--   <tt>x!!</tt> and if it's right-associative -- <tt>(x!)!</tt>.
--   
--   The data type is parameterized, so that the user can choose precedence
--   to be integer/fractional, bounded/unbounded, etc (we could also allows
--   operators to be partially or totally ordered, but at the moment
--   <tt>prec</tt> is required to implement <a>Ord</a>, i.e. it has to be
--   totally ordered). By default we go with bounded fractional precedence,
--   see the main <a>Text.Fixity</a> module.
data FixityOver prec
Fixity :: !Associativity -> !prec -> FixityOver prec
[_fixityAssociativity] :: FixityOver prec -> !Associativity
[_fixityPrecedence] :: FixityOver prec -> !prec

-- | <a>FixityOver</a> instantiated at <a>Precedence</a>.
type Fixity = FixityOver Precedence

-- | Direction in which pretty-printing goes. For example in <tt>x + y</tt>
--   <tt>x</tt> is pretty-printed to the left of <tt>+</tt> and <tt>y</tt>
--   is pretty-printed to the right of <tt>+</tt>.
data Direction
ToTheLeft :: Direction
ToTheRight :: Direction

-- | A context that an expression is being rendered in.
data RenderContextOver prec
RenderContext :: !Direction -> !FixityOver prec -> RenderContextOver prec
[_renderContextDirection] :: RenderContextOver prec -> !Direction
[_renderContextFixity] :: RenderContextOver prec -> !FixityOver prec

-- | <a>FixityOver</a> instantiated at <a>Precedence</a>.
type RenderContext = RenderContextOver Precedence

-- | Enclose an <tt>a</tt> (using the provided function) if required or
--   leave it as is. The need for enclosing is determined from an outer
--   <a>RenderContext</a> and the inner fixity.
encloseIn :: Ord prec => (a -> a) -> RenderContextOver prec -> FixityOver prec -> a -> a

-- | A fixity with the lowest precedence. When used as a part of an outer
--   context, never causes addition of parens.
botFixity :: Fixity

-- | The fixity of juxtaposition.
juxtFixity :: Fixity

-- | The fixity of a unitary expression which is safe to render without
--   parens in any context.
unitFixity :: Fixity

-- | A fixity with the highest precedence. When used as a part of an outer
--   context, always causes addition of parens.
topFixity :: Fixity

-- | An initial <a>RenderContext</a>. An expression printed in this context
--   never gets enclosed in parens.
botRenderContext :: RenderContext

-- | An initial <a>RenderContext</a>. An expression printed in this context
--   always gets enclosed in parens.
topRenderContext :: RenderContext


-- | A module alias for way too verbose <a>Prettyprinter</a>.
module Text.Pretty


-- | Internal module defining the core machinery of configurable
--   pretty-printing.
--   
--   We introduce an internal module, because most users won't need stuff
--   like <a>DefaultPrettyBy</a>, so it doesn't make much sense to export
--   that from the top-level module. But <a>DefaultPrettyBy</a> can still
--   can be useful occasionally and there are some docs explaining details
--   of the implementation (see e.g. <a>DispatchPrettyDefaultBy</a>), hence
--   it's exported from here.
--   
--   Versioning is not affected by the fact that the module is called
--   "Internal", i.e. we track changes using the usual PVP.
module Text.PrettyBy.Internal

-- | A class for pretty-printing values in a configurable manner.
--   
--   A basic example:
--   
--   <pre>
--   &gt;&gt;&gt; data Case = UpperCase | LowerCase
--   
--   &gt;&gt;&gt; data D = D
--   
--   &gt;&gt;&gt; instance PrettyBy Case D where prettyBy UpperCase D = "D"; prettyBy LowerCase D = "d"
--   
--   &gt;&gt;&gt; prettyBy UpperCase D
--   D
--   
--   &gt;&gt;&gt; prettyBy LowerCase D
--   d
--   </pre>
--   
--   The library provides instances for common types like <a>Integer</a> or
--   <a>Bool</a>, so you can't define your own <tt>PrettyBy SomeConfig
--   Integer</tt> instance. And for the same reason you should not define
--   instances like <tt>PrettyBy SomeAnotherConfig a</tt> for universally
--   quantified <tt>a</tt>, because such an instance would overlap with the
--   existing ones. Take for example
--   
--   <pre>
--   &gt;&gt;&gt; data ViaShow = ViaShow
--   
--   &gt;&gt;&gt; instance Show a =&gt; PrettyBy ViaShow a where prettyBy ViaShow = pretty . show
--   </pre>
--   
--   with such an instance <tt>prettyBy ViaShow (1 :: Int)</tt> throws an
--   error about overlapping instances:
--   
--   <pre>
--   • Overlapping instances for PrettyBy ViaShow Int
--       arising from a use of ‘prettyBy’
--     Matching instances:
--       instance PrettyDefaultBy config Int =&gt; PrettyBy config Int
--       instance [safe] Show a =&gt; PrettyBy ViaShow a
--   </pre>
--   
--   There's a <tt>newtype</tt> provided specifically for the purpose of
--   defining a <a>PrettyBy</a> instance for any <tt>a</tt>:
--   <a>PrettyAny</a>. Read its docs for details on when you might want to
--   use it.
--   
--   The <a>PrettyBy</a> instance for common types is defined in a way that
--   allows to override default pretty-printing behaviour, read the docs of
--   <a>HasPrettyDefaults</a> for details.
class PrettyBy config a

-- | Pretty-print a value of type <tt>a</tt> the way a <tt>config</tt>
--   specifies it. The default implementation of <a>prettyBy</a> is in
--   terms of <a>pretty</a>, <a>defaultPrettyFunctorBy</a> or
--   <a>defaultPrettyBifunctorBy</a> depending on the kind of the data type
--   that you're providing an instance for. For example, the default
--   implementation of <a>prettyBy</a> for a monomorphic type is going to
--   be "ignore the config and call <a>pretty</a> over the value":
--   
--   <pre>
--   &gt;&gt;&gt; newtype N = N Int deriving newtype (Pretty)
--   
--   &gt;&gt;&gt; instance PrettyBy () N
--   
--   &gt;&gt;&gt; prettyBy () (N 42)
--   42
--   </pre>
--   
--   The default implementation of <a>prettyBy</a> for a <a>Functor</a> is
--   going to be in terms of <a>defaultPrettyFunctorBy</a>:
--   
--   <pre>
--   &gt;&gt;&gt; newtype N a = N a deriving stock (Functor) deriving newtype (Pretty)
--   
--   &gt;&gt;&gt; instance PrettyBy () a =&gt; PrettyBy () (N a)
--   
--   &gt;&gt;&gt; prettyBy () (N (42 :: Int))
--   42
--   </pre>
--   
--   It's fine for the data type to have a phantom parameter as long as the
--   data type is still a <a>Functor</a> (i.e. the parameter has to be of
--   kind <tt>Type</tt>). Then <a>defaultPrettyFunctorBy</a> is used again:
--   
--   <pre>
--   &gt;&gt;&gt; newtype N a = N Int deriving stock (Functor) deriving newtype (Pretty)
--   
--   &gt;&gt;&gt; instance PrettyBy () (N b)
--   
--   &gt;&gt;&gt; prettyBy () (N 42)
--   42
--   </pre>
--   
--   If the data type has a single parameter of any other kind, then it's
--   not a functor and so like in the monomorphic case <a>pretty</a> is
--   used:
--   
--   <pre>
--   &gt;&gt;&gt; newtype N (b :: Bool) = N Int deriving newtype (Pretty)
--   
--   &gt;&gt;&gt; instance PrettyBy () (N b)
--   
--   &gt;&gt;&gt; prettyBy () (N 42)
--   42
--   </pre>
--   
--   Same applies to a data type with two parameters: if both the
--   parameters are of kind <tt>Type</tt>, then the data type is assumed to
--   be a <a>Bifunctor</a> and hence <a>defaultPrettyBifunctorBy</a> is
--   used. If the right parameter is of kind <tt>Type</tt> and the left
--   parameter is of any other kind, then we fallback to assuming the data
--   type is a <a>Functor</a> and defining <a>prettyBy</a> as
--   <a>defaultPrettyFunctorBy</a>. If both the parameters are not of kind
--   <tt>Type</tt>, we fallback to implementing <a>prettyBy</a> in terms of
--   <a>pretty</a> like in the monomorphic case.
--   
--   Note that in all those cases a <a>Pretty</a> instance for the data
--   type has to already exist, so that we can derive a <a>PrettyBy</a> one
--   in terms of it. If it doesn't exist or if your data type is not
--   supported (for example, if it has three or more parameters of kind
--   <tt>Type</tt>), then you'll need to provide the implementation
--   manually.
prettyBy :: PrettyBy config a => config -> a -> Doc ann

-- | Pretty-print a value of type <tt>a</tt> the way a <tt>config</tt>
--   specifies it. The default implementation of <a>prettyBy</a> is in
--   terms of <a>pretty</a>, <a>defaultPrettyFunctorBy</a> or
--   <a>defaultPrettyBifunctorBy</a> depending on the kind of the data type
--   that you're providing an instance for. For example, the default
--   implementation of <a>prettyBy</a> for a monomorphic type is going to
--   be "ignore the config and call <a>pretty</a> over the value":
--   
--   <pre>
--   &gt;&gt;&gt; newtype N = N Int deriving newtype (Pretty)
--   
--   &gt;&gt;&gt; instance PrettyBy () N
--   
--   &gt;&gt;&gt; prettyBy () (N 42)
--   42
--   </pre>
--   
--   The default implementation of <a>prettyBy</a> for a <a>Functor</a> is
--   going to be in terms of <a>defaultPrettyFunctorBy</a>:
--   
--   <pre>
--   &gt;&gt;&gt; newtype N a = N a deriving stock (Functor) deriving newtype (Pretty)
--   
--   &gt;&gt;&gt; instance PrettyBy () a =&gt; PrettyBy () (N a)
--   
--   &gt;&gt;&gt; prettyBy () (N (42 :: Int))
--   42
--   </pre>
--   
--   It's fine for the data type to have a phantom parameter as long as the
--   data type is still a <a>Functor</a> (i.e. the parameter has to be of
--   kind <tt>Type</tt>). Then <a>defaultPrettyFunctorBy</a> is used again:
--   
--   <pre>
--   &gt;&gt;&gt; newtype N a = N Int deriving stock (Functor) deriving newtype (Pretty)
--   
--   &gt;&gt;&gt; instance PrettyBy () (N b)
--   
--   &gt;&gt;&gt; prettyBy () (N 42)
--   42
--   </pre>
--   
--   If the data type has a single parameter of any other kind, then it's
--   not a functor and so like in the monomorphic case <a>pretty</a> is
--   used:
--   
--   <pre>
--   &gt;&gt;&gt; newtype N (b :: Bool) = N Int deriving newtype (Pretty)
--   
--   &gt;&gt;&gt; instance PrettyBy () (N b)
--   
--   &gt;&gt;&gt; prettyBy () (N 42)
--   42
--   </pre>
--   
--   Same applies to a data type with two parameters: if both the
--   parameters are of kind <tt>Type</tt>, then the data type is assumed to
--   be a <a>Bifunctor</a> and hence <a>defaultPrettyBifunctorBy</a> is
--   used. If the right parameter is of kind <tt>Type</tt> and the left
--   parameter is of any other kind, then we fallback to assuming the data
--   type is a <a>Functor</a> and defining <a>prettyBy</a> as
--   <a>defaultPrettyFunctorBy</a>. If both the parameters are not of kind
--   <tt>Type</tt>, we fallback to implementing <a>prettyBy</a> in terms of
--   <a>pretty</a> like in the monomorphic case.
--   
--   Note that in all those cases a <a>Pretty</a> instance for the data
--   type has to already exist, so that we can derive a <a>PrettyBy</a> one
--   in terms of it. If it doesn't exist or if your data type is not
--   supported (for example, if it has three or more parameters of kind
--   <tt>Type</tt>), then you'll need to provide the implementation
--   manually.
prettyBy :: (PrettyBy config a, DefaultFor "prettyBy" config a) => config -> a -> Doc ann

-- | <a>prettyListBy</a> is used to define the default <a>PrettyBy</a>
--   instance for <tt>[a]</tt> and <tt>NonEmpty a</tt>. In normal
--   circumstances only the <a>prettyBy</a> function is used. The default
--   implementation of <a>prettyListBy</a> is in terms of
--   <a>defaultPrettyFunctorBy</a>.
prettyListBy :: PrettyBy config a => config -> [a] -> Doc ann

-- | <a>prettyListBy</a> is used to define the default <a>PrettyBy</a>
--   instance for <tt>[a]</tt> and <tt>NonEmpty a</tt>. In normal
--   circumstances only the <a>prettyBy</a> function is used. The default
--   implementation of <a>prettyListBy</a> is in terms of
--   <a>defaultPrettyFunctorBy</a>.
prettyListBy :: PrettyBy config a => config -> [a] -> Doc ann

-- | Determines whether a pretty-printing config allows default
--   pretty-printing for types that support it. I.e. it's possible to
--   create a new config and get access to pretty-printing for all types
--   supporting default pretty-printing just by providing the right type
--   instance. Example:
--   
--   <pre>
--   &gt;&gt;&gt; data DefCfg = DefCfg
--   
--   &gt;&gt;&gt; type instance HasPrettyDefaults DefCfg = 'True
--   
--   &gt;&gt;&gt; prettyBy DefCfg (['a', 'b', 'c'], (1 :: Int), Just True)
--   (abc, 1, True)
--   </pre>
--   
--   The set of types supporting default pretty-printing is determined by
--   the <tt>prettyprinter</tt> library: whatever <b>there</b> has a
--   <a>Pretty</a> instance also supports default pretty-printing in this
--   library and the behavior of <tt>pretty x</tt> and <tt>prettyBy
--   config_with_defaults x</tt> must be identical when <tt>x</tt> is one
--   of such types.
--   
--   It is possible to override default pretty-printing. For this you need
--   to specify that <a>HasPrettyDefaults</a> is <tt>'False</tt> for your
--   config and then define a <tt>NonDefaultPrettyBy config</tt> instance
--   for each of the types supporting default pretty-printing that you want
--   to pretty-print values of. Note that once <a>HasPrettyDefaults</a> is
--   specified to be <tt>'False</tt>, <b>all defaults are lost</b> for your
--   config, so you can't override default pretty-printing for one type and
--   keep the defaults for all the others. I.e. if you have
--   
--   <pre>
--   &gt;&gt;&gt; data NonDefCfg = NonDefCfg
--   
--   &gt;&gt;&gt; type instance HasPrettyDefaults NonDefCfg = 'False
--   </pre>
--   
--   then you have no defaults available and an attempt to pretty-print a
--   value of a type supporting default pretty-printing
--   
--   <pre>
--   prettyBy NonDefCfg True
--   </pre>
--   
--   results in a type error:
--   
--   <pre>
--   • No instance for (NonDefaultPrettyBy NonDef Bool)
--        arising from a use of ‘prettyBy’
--   </pre>
--   
--   As the error suggests you need to provide a <a>NonDefaultPrettyBy</a>
--   instance explicitly:
--   
--   <pre>
--   &gt;&gt;&gt; instance NonDefaultPrettyBy NonDefCfg Bool where nonDefaultPrettyBy _ b = if b then "t" else "f"
--   
--   &gt;&gt;&gt; prettyBy NonDefCfg True
--   t
--   </pre>
--   
--   It is also possible not to provide any implementation for
--   <a>nonDefaultPrettyBy</a>, in which case it defaults to being the
--   default pretty-printing for the given type. This can be useful to
--   recover default pretty-printing for types pretty-printing of which you
--   don't want to override:
--   
--   <pre>
--   &gt;&gt;&gt; instance NonDefaultPrettyBy NonDefCfg Int
--   
--   &gt;&gt;&gt; prettyBy NonDefCfg (42 :: Int)
--   42
--   </pre>
--   
--   Look into <tt>test/NonDefault.hs</tt> for an extended example.
--   
--   We could give the user more fine-grained control over what defaults to
--   override instead of requiring to explicitly provide all the instances
--   whenever there's a need to override any default behavior, but that
--   would complicate the library even more, so we opted for not doing that
--   at the moment.
--   
--   Note that you can always override default behavior by wrapping a type
--   in <tt>newtype</tt> and providing a <tt>PrettyBy config_name</tt>
--   instance for that <tt>newtype</tt>.
--   
--   Also note that if you want to extend the set of types supporting
--   default pretty-printing it's not enough to provide a <a>Pretty</a>
--   instance for your type (such logic is hardly expressible in present
--   day Haskell). Read the docs of <a>DefaultPrettyBy</a> for how to
--   extend the set of types supporting default pretty-printing.
type family HasPrettyDefaults config :: Bool

-- | A newtype wrapper around <tt>a</tt> whose point is to provide a
--   <tt>PrettyBy config</tt> instance for anything that has a
--   <a>Pretty</a> instance.
newtype IgnorePrettyConfig a
IgnorePrettyConfig :: a -> IgnorePrettyConfig a
[unIgnorePrettyConfig] :: IgnorePrettyConfig a -> a

-- | A config together with some value. The point is to provide a
--   <a>Pretty</a> instance for anything that has a <tt>PrettyBy
--   config</tt> instance.
data AttachPrettyConfig config a
AttachPrettyConfig :: !config -> !a -> AttachPrettyConfig config a

-- | Pass <tt>AttachPrettyConfig config</tt> to the continuation.
withAttachPrettyConfig :: config -> ((forall a. a -> AttachPrettyConfig config a) -> r) -> r

-- | Default configurable pretty-printing for a <a>Functor</a> in terms of
--   <a>Pretty</a>. Attaches the config to each value in the functor and
--   calls <a>pretty</a> over the result, i.e. the spine of the functor is
--   pretty-printed the way the <a>Pretty</a> class specifies it, while the
--   elements are printed by <a>prettyBy</a>.
defaultPrettyFunctorBy :: (Functor f, Pretty (f (AttachPrettyConfig config a))) => config -> f a -> Doc ann

-- | Default configurable pretty-printing for a <a>Bifunctor</a> in terms
--   of <a>Pretty</a> Attaches the config to each value in the bifunctor
--   and calls <a>pretty</a> over the result, i.e. the spine of the
--   bifunctor is pretty-printed the way the <a>Pretty</a> class specifies
--   it, while the elements are printed by <a>prettyBy</a>.
defaultPrettyBifunctorBy :: (Bifunctor f, Pretty (f (AttachPrettyConfig config a) (AttachPrettyConfig config b))) => config -> f a b -> Doc ann

-- | Return the longest sequence of <tt>Type</tt> in the kind
--   (right-to-left) of the head of an application. (but no longer than
--   <tt>Type -&gt; Type -&gt; Type</tt>, because we can't support longer
--   ones in <a>DispatchDefaultFor</a>).
type family StarsOfHead (target :: Symbol) (a :: Type) :: Type

-- | This allows us to have different default implementations for
--   <a>prettyBy</a> and <a>defaultPrettyBy</a> depending on whether
--   <tt>a</tt> is a monomorphic type or a <a>Functor</a> or a
--   <a>Bifunctor</a>. Read the docs of <a>prettyBy</a> for details.
class StarsOfHead target a ~ k => DispatchDefaultFor target k config a
dispatchDefaultFor :: DispatchDefaultFor target k config a => config -> a -> Doc ann

-- | Introducing a class just for the nice name of the method and in case
--   the defaulting machinery somehow blows up in the user's face.
class DispatchDefaultFor target (StarsOfHead target a) config a => DefaultFor target config a
defaultFor :: DefaultFor target config a => config -> a -> Doc ann

-- | Same as <a>AttachPrettyConfig</a>, but for providing a <a>Pretty</a>
--   instance for anything that has a <a>DefaultPrettyBy</a> instance.
--   Needed for the default implementation of <a>defaultPrettyListBy</a>.
data AttachDefaultPrettyConfig config a
AttachDefaultPrettyConfig :: !config -> !a -> AttachDefaultPrettyConfig config a

-- | A class for pretty-printing values is some default manner. Basic
--   example:
--   
--   <pre>
--   &gt;&gt;&gt; data D = D
--   
--   &gt;&gt;&gt; instance PrettyBy () D where prettyBy () D = "D"
--   
--   &gt;&gt;&gt; defaultPrettyBy () (Just D)
--   D
--   </pre>
--   
--   <a>DefaultPrettyBy</a> and <a>PrettyBy</a> are mutually recursive in a
--   sense: <a>PrettyBy</a> delegates to <a>DefaultPrettyBy</a> (provided
--   the config supports defaults) when given a value of a type supporting
--   default pretty-printing and <a>DefaultPrettyBy</a> delegates back to
--   <a>PrettyBy</a> for elements of a polymorphic container.
--   
--   It is possible to extend the set of types supporting default
--   pretty-printing. If you have a <tt>newtype</tt> wrapping a type that
--   already supports default pretty-printing, then "registering" that
--   <tt>newtype</tt> amounts to making a standalone newtype-deriving
--   declaration:
--   
--   <pre>
--   &gt;&gt;&gt; newtype AlsoInt = AlsoInt Int
--   
--   &gt;&gt;&gt; deriving newtype instance PrettyDefaultBy config Int =&gt; PrettyBy config AlsoInt
--   
--   &gt;&gt;&gt; prettyBy () (AlsoInt 42)
--   42
--   </pre>
--   
--   Note that you have to use standalone deriving as
--   
--   <pre>
--   newtype AlsoInt = AlsoInt Int deriving newtype (PrettyBy config)
--   </pre>
--   
--   doesn't please GHC.
--   
--   It's also good practice to preserve coherence of <a>Pretty</a> and
--   <a>PrettyBy</a>, so I'd also add <tt>deriving newtype (Pretty)</tt> to
--   the definition of <tt>AlsoInt</tt>, even though it's not necessary.
--   
--   When you want to extend the set of types supporting default
--   pretty-printing with a data type that is a <tt>data</tt> rather than a
--   <tt>newtype</tt>, you can directly implement <a>DefaultPrettyBy</a>
--   and and via-derive <a>PrettyBy</a>:
--   
--   <pre>
--   &gt;&gt;&gt; data D = D
--   
--   &gt;&gt;&gt; instance DefaultPrettyBy config D where defaultPrettyBy _ D = "D"
--   
--   &gt;&gt;&gt; deriving via PrettyCommon D instance PrettyDefaultBy config D =&gt; PrettyBy config D
--   
--   &gt;&gt;&gt; prettyBy () D
--   D
--   </pre>
--   
--   But since it's best to preserve coherence of <a>Pretty</a> and
--   <a>PrettyBy</a> for types supporting default pretty-printing, it's
--   recommended (not mandatory) to define a <a>Pretty</a> instance and
--   anyclass-derive <a>DefaultPrettyBy</a> in terms of it:
--   
--   <pre>
--   &gt;&gt;&gt; data D = D
--   
--   &gt;&gt;&gt; instance Pretty D where pretty D = "D"
--   
--   &gt;&gt;&gt; instance DefaultPrettyBy config D
--   
--   &gt;&gt;&gt; deriving via PrettyCommon D instance PrettyDefaultBy config D =&gt; PrettyBy config D
--   
--   &gt;&gt;&gt; prettyBy () [D, D, D]
--   [D, D, D]
--   </pre>
--   
--   Note that <a>DefaultPrettyBy</a> is specifically designed to handle
--   <b>all</b> configs in its instances, i.e. you only specify a data type
--   in a <a>DefaultPrettyBy</a> instance and leave <tt>config</tt>
--   universally quantified. This is because default pretty-printing
--   behavior should be the same for all configs supporting default
--   pretty-printing (it's the default after all). If you want to override
--   the defaults, read the docs of <a>HasPrettyDefaults</a>.
--   
--   Since <tt>config</tt> in a <a>DefaultPrettyBy</a> instance is meant to
--   be universally quantified, <a>defaultPrettyBy</a> (the main method of
--   <a>DefaultPrettyBy</a>) has to ignore the config in the monomorphic
--   case as it can't use it in any way anyway, i.e. in the monomorphic
--   case <a>defaultPrettyBy</a> has the exact same info as simple
--   <a>pretty</a>, which is another reason to anyclass-derive
--   <a>DefaultPrettyBy</a> in terms of <a>Pretty</a>.
--   
--   Like in the case of <a>prettyBy</a>, the default implementation of
--   <a>defaultPrettyBy</a> for a <a>Functor</a> is
--   <a>defaultPrettyFunctorBy</a> (and for a <a>Bifunctor</a> --
--   <a>defaultPrettyBifunctorBy</a>):
--   
--   <pre>
--   &gt;&gt;&gt; data Twice a = Twice a a deriving stock (Functor)
--   
--   &gt;&gt;&gt; instance Pretty a =&gt; Pretty (Twice a) where pretty (Twice x y) = pretty x &lt;+&gt; "&amp;" &lt;+&gt; pretty y
--   
--   &gt;&gt;&gt; instance PrettyBy config a =&gt; DefaultPrettyBy config (Twice a)
--   
--   &gt;&gt;&gt; deriving via PrettyCommon (Twice a) instance PrettyDefaultBy config (Twice a) =&gt; PrettyBy config (Twice a)
--   
--   &gt;&gt;&gt; prettyBy () (Twice True False)
--   True &amp; False
--   </pre>
--   
--   Since preserving coherence of <a>Pretty</a> and <a>PrettyBy</a> is
--   only a good practice and not mandatory, it's fine not to provide an
--   instance for <a>Pretty</a>. Then a <a>DefaultPrettyBy</a> can be
--   implemented directly:
--   
--   <pre>
--   &gt;&gt;&gt; data Twice a = Twice a a
--   
--   &gt;&gt;&gt; instance PrettyBy config a =&gt; DefaultPrettyBy config (Twice a) where defaultPrettyBy config (Twice x y) = prettyBy config x &lt;+&gt; "&amp;" &lt;+&gt; prettyBy config y
--   
--   &gt;&gt;&gt; deriving via PrettyCommon (Twice a) instance PrettyDefaultBy config (Twice a) =&gt; PrettyBy config (Twice a)
--   
--   &gt;&gt;&gt; prettyBy () (Twice True False)
--   True &amp; False
--   </pre>
--   
--   But make sure that if both a <a>Pretty</a> and a
--   <a>DefaultPrettyBy</a> instances exist, then they're in sync.
class DefaultPrettyBy config a

-- | Pretty-print a value of type <tt>a</tt> in some default manner. The
--   default implementation works equally to the one of <a>prettyBy</a>.
defaultPrettyBy :: DefaultPrettyBy config a => config -> a -> Doc ann

-- | Pretty-print a value of type <tt>a</tt> in some default manner. The
--   default implementation works equally to the one of <a>prettyBy</a>.
defaultPrettyBy :: (DefaultPrettyBy config a, DefaultFor "defaultPrettyBy" config a) => config -> a -> Doc ann

-- | <a>defaultPrettyListBy</a> to <a>prettyListBy</a> is what
--   <a>defaultPrettyBy</a> to <a>prettyBy</a>. The default implementation
--   is "pretty-print the spine of a list the way <a>pretty</a> does that
--   and pretty-print the elements using <a>defaultPrettyBy</a>".
defaultPrettyListBy :: DefaultPrettyBy config a => config -> [a] -> Doc ann

-- | <a>defaultPrettyListBy</a> to <a>prettyListBy</a> is what
--   <a>defaultPrettyBy</a> to <a>prettyBy</a>. The default implementation
--   is "pretty-print the spine of a list the way <a>pretty</a> does that
--   and pretty-print the elements using <a>defaultPrettyBy</a>".
defaultPrettyListBy :: DefaultPrettyBy config a => config -> [a] -> Doc ann

-- | A class for overriding default pretty-printing behavior for types
--   having it. Read the docs of <a>HasPrettyDefaults</a> for how to use
--   the class.
class NonDefaultPrettyBy config a

-- | Pretty-print a value of a type supporting default pretty-printing in a
--   possibly non-default way. The "possibly" is due to
--   <a>nonDefaultPrettyBy</a> having a default implementation as
--   <a>defaultPrettyBy</a>. See docs for <a>HasPrettyDefaults</a> for
--   details.
nonDefaultPrettyBy :: NonDefaultPrettyBy config a => config -> a -> Doc ann

-- | Pretty-print a value of a type supporting default pretty-printing in a
--   possibly non-default way. The "possibly" is due to
--   <a>nonDefaultPrettyBy</a> having a default implementation as
--   <a>defaultPrettyBy</a>. See docs for <a>HasPrettyDefaults</a> for
--   details.
nonDefaultPrettyBy :: (NonDefaultPrettyBy config a, DefaultPrettyBy config a) => config -> a -> Doc ann

-- | <a>nonDefaultPrettyListBy</a> to <a>prettyListBy</a> is what
--   <a>nonDefaultPrettyBy</a> to <a>prettyBy</a>. Analogously, the default
--   implementation is <a>defaultPrettyListBy</a>.
nonDefaultPrettyListBy :: NonDefaultPrettyBy config a => config -> [a] -> Doc ann

-- | <a>nonDefaultPrettyListBy</a> to <a>prettyListBy</a> is what
--   <a>nonDefaultPrettyBy</a> to <a>prettyBy</a>. Analogously, the default
--   implementation is <a>defaultPrettyListBy</a>.
nonDefaultPrettyListBy :: (NonDefaultPrettyBy config a, DefaultPrettyBy config a) => config -> [a] -> Doc ann

-- | <tt>PrettyDefaultBy config a</tt> is the same thing as <tt>PrettyBy
--   config a</tt>, when <tt>a</tt> supports default pretty-printing. Thus
--   <tt>PrettyDefaultBy config a</tt> and <tt>PrettyBy config a</tt> are
--   interchangeable constraints for such types, but the latter throws an
--   annoying "this makes type inference for inner bindings fragile"
--   warning, unlike the former. <tt>PrettyDefaultBy config a</tt> reads as
--   "<tt>a</tt> supports default pretty-printing and can be pretty-printed
--   via <tt>config</tt> in either default or non-default manner depending
--   on whether <tt>config</tt> supports default pretty-printing".
type PrettyDefaultBy config = DispatchPrettyDefaultBy (NonStuckHasPrettyDefaults config) config

-- | A newtype wrapper defined for its <a>PrettyBy</a> instance that allows
--   to via-derive a <a>PrettyBy</a> instance for a type supporting default
--   pretty-printing.
newtype PrettyCommon a
PrettyCommon :: a -> PrettyCommon a
[unPrettyCommon] :: PrettyCommon a -> a

-- | Throw <tt>err</tt> when <tt>b</tt> is stuck.
type family ThrowOnStuck err (b :: Bool) :: Bool

-- | The error thrown when <tt>HasPrettyDefaults config</tt> is stuck.
type family HasPrettyDefaultsStuckError config :: Bool

-- | A version of <a>HasPrettyDefaults</a> that is never stuck: it either
--   immediately evaluates to a <a>Bool</a> or fails with a
--   <a>TypeError</a>.
type NonStuckHasPrettyDefaults config = ThrowOnStuck (HasPrettyDefaultsStuckError config) (HasPrettyDefaults config)

-- | <a>DispatchPrettyDefaultBy</a> is a class for dispatching on
--   <tt>HasPrettyDefaults config</tt>: if it's <tt>'True</tt>, then
--   <a>dispatchPrettyDefaultBy</a> is instantiated as
--   <a>defaultPrettyBy</a>, otherwise as <a>nonDefaultPrettyBy</a> (and
--   similarly for <a>dispatchPrettyDefaultListBy</a>). I.e. depending on
--   whether a config allows to pretty-print values using default
--   pretty-printing, either the default or non-default pretty-printing
--   strategy is used.
class HasPrettyDefaults config ~ b => DispatchPrettyDefaultBy (b :: Bool) config a
dispatchPrettyDefaultBy :: DispatchPrettyDefaultBy b config a => config -> a -> Doc ann
dispatchPrettyDefaultListBy :: DispatchPrettyDefaultBy b config a => config -> [a] -> Doc ann

-- | A <tt>newtype</tt> wrapper around <tt>a</tt> provided for the purporse
--   of defining <a>PrettyBy</a> instances handling any <tt>a</tt>. For
--   example you can wrap values with the <tt>PrettyAny</tt> constructor
--   directly like in this last line of
--   
--   <pre>
--   &gt;&gt;&gt; data ViaShow = ViaShow
--   
--   &gt;&gt;&gt; instance Show a =&gt; PrettyBy ViaShow (PrettyAny a) where prettyBy ViaShow = pretty . show . unPrettyAny
--   
--   &gt;&gt;&gt; prettyBy ViaShow $ PrettyAny True
--   True
--   </pre>
--   
--   or you can use the type to via-derive instances:
--   
--   <pre>
--   &gt;&gt;&gt; data D = D deriving stock (Show)
--   
--   &gt;&gt;&gt; deriving via PrettyAny D instance PrettyBy ViaShow D
--   
--   &gt;&gt;&gt; prettyBy ViaShow D
--   D
--   </pre>
--   
--   One important use case is handling sum-type configs. For example
--   having two configs you can define their sum and derive <a>PrettyBy</a>
--   for the unified config in terms of its components:
--   
--   <pre>
--   &gt;&gt;&gt; data UpperCase = UpperCase
--   
--   &gt;&gt;&gt; data LowerCase = LowerCase
--   
--   &gt;&gt;&gt; data Case = CaseUpperCase UpperCase | CaseLowerCase LowerCase
--   
--   &gt;&gt;&gt; instance (PrettyBy UpperCase a, PrettyBy LowerCase a) =&gt; PrettyBy Case (PrettyAny a) where prettyBy (CaseUpperCase upper) = prettyBy upper . unPrettyAny; prettyBy (CaseLowerCase lower) = prettyBy lower . unPrettyAny
--   </pre>
--   
--   Then having a data type implementing both <tt>PrettyBy UpperCase</tt>
--   and <tt>PrettyBy LowerCase</tt> you can derive <tt>PrettyBy Case</tt>
--   for that data type:
--   
--   <pre>
--   &gt;&gt;&gt; data D = D
--   
--   &gt;&gt;&gt; instance PrettyBy UpperCase D where prettyBy UpperCase D = "D"
--   
--   &gt;&gt;&gt; instance PrettyBy LowerCase D where prettyBy LowerCase D = "d"
--   
--   &gt;&gt;&gt; deriving via PrettyAny D instance PrettyBy Case D
--   
--   &gt;&gt;&gt; prettyBy UpperCase D
--   D
--   
--   &gt;&gt;&gt; prettyBy LowerCase D
--   d
--   </pre>
--   
--   Look into <tt>test/Universal.hs</tt> for an extended example.
newtype PrettyAny a
PrettyAny :: a -> PrettyAny a
[unPrettyAny] :: PrettyAny a -> a
instance Text.PrettyBy.Internal.PrettyDefaultBy config Data.Void.Void => Text.PrettyBy.Internal.PrettyBy config Data.Void.Void
instance Text.PrettyBy.Internal.PrettyDefaultBy config () => Text.PrettyBy.Internal.PrettyBy config ()
instance Text.PrettyBy.Internal.PrettyDefaultBy config GHC.Types.Bool => Text.PrettyBy.Internal.PrettyBy config GHC.Types.Bool
instance Text.PrettyBy.Internal.PrettyDefaultBy config GHC.Num.Natural.Natural => Text.PrettyBy.Internal.PrettyBy config GHC.Num.Natural.Natural
instance Text.PrettyBy.Internal.PrettyDefaultBy config GHC.Num.Integer.Integer => Text.PrettyBy.Internal.PrettyBy config GHC.Num.Integer.Integer
instance Text.PrettyBy.Internal.PrettyDefaultBy config GHC.Types.Int => Text.PrettyBy.Internal.PrettyBy config GHC.Types.Int
instance Text.PrettyBy.Internal.PrettyDefaultBy config GHC.Int.Int8 => Text.PrettyBy.Internal.PrettyBy config GHC.Int.Int8
instance Text.PrettyBy.Internal.PrettyDefaultBy config GHC.Int.Int16 => Text.PrettyBy.Internal.PrettyBy config GHC.Int.Int16
instance Text.PrettyBy.Internal.PrettyDefaultBy config GHC.Int.Int32 => Text.PrettyBy.Internal.PrettyBy config GHC.Int.Int32
instance Text.PrettyBy.Internal.PrettyDefaultBy config GHC.Int.Int64 => Text.PrettyBy.Internal.PrettyBy config GHC.Int.Int64
instance Text.PrettyBy.Internal.PrettyDefaultBy config GHC.Types.Word => Text.PrettyBy.Internal.PrettyBy config GHC.Types.Word
instance Text.PrettyBy.Internal.PrettyDefaultBy config GHC.Word.Word8 => Text.PrettyBy.Internal.PrettyBy config GHC.Word.Word8
instance Text.PrettyBy.Internal.PrettyDefaultBy config GHC.Word.Word16 => Text.PrettyBy.Internal.PrettyBy config GHC.Word.Word16
instance Text.PrettyBy.Internal.PrettyDefaultBy config GHC.Word.Word32 => Text.PrettyBy.Internal.PrettyBy config GHC.Word.Word32
instance Text.PrettyBy.Internal.PrettyDefaultBy config GHC.Word.Word64 => Text.PrettyBy.Internal.PrettyBy config GHC.Word.Word64
instance Text.PrettyBy.Internal.PrettyDefaultBy config GHC.Types.Float => Text.PrettyBy.Internal.PrettyBy config GHC.Types.Float
instance Text.PrettyBy.Internal.PrettyDefaultBy config GHC.Types.Double => Text.PrettyBy.Internal.PrettyBy config GHC.Types.Double
instance Text.PrettyBy.Internal.PrettyDefaultBy config Data.Text.Internal.Text => Text.PrettyBy.Internal.PrettyBy config Data.Text.Internal.Text
instance Text.PrettyBy.Internal.PrettyDefaultBy config Data.Text.Internal.Lazy.Text => Text.PrettyBy.Internal.PrettyBy config Data.Text.Internal.Lazy.Text
instance Text.PrettyBy.Internal.PrettyDefaultBy config (Data.Functor.Identity.Identity a) => Text.PrettyBy.Internal.PrettyBy config (Data.Functor.Identity.Identity a)
instance Text.PrettyBy.Internal.PrettyDefaultBy config (a, b) => Text.PrettyBy.Internal.PrettyBy config (a, b)
instance Text.PrettyBy.Internal.PrettyDefaultBy config (a, b, c) => Text.PrettyBy.Internal.PrettyBy config (a, b, c)
instance forall config a k (b :: k). Text.PrettyBy.Internal.PrettyDefaultBy config (Data.Functor.Const.Const a b) => Text.PrettyBy.Internal.PrettyBy config (Data.Functor.Const.Const a b)
instance Text.PrettyBy.Internal.PrettyDefaultBy config [a] => Text.PrettyBy.Internal.PrettyBy config [a]
instance Text.PrettyBy.Internal.PrettyDefaultBy config (GHC.Base.NonEmpty a) => Text.PrettyBy.Internal.PrettyBy config (GHC.Base.NonEmpty a)
instance Text.PrettyBy.Internal.PrettyDefaultBy config GHC.Types.Char => Text.PrettyBy.Internal.PrettyBy config GHC.Types.Char
instance Text.PrettyBy.Internal.PrettyDefaultBy config (GHC.Maybe.Maybe a) => Text.PrettyBy.Internal.PrettyBy config (GHC.Maybe.Maybe a)
instance Text.PrettyBy.Internal.PrettyDefaultBy config a => Text.PrettyBy.Internal.PrettyBy config (Text.PrettyBy.Internal.PrettyCommon a)
instance (Text.PrettyBy.Internal.HasPrettyDefaults config GHC.Types.~ 'GHC.Types.True, Text.PrettyBy.Internal.DefaultPrettyBy config a) => Text.PrettyBy.Internal.DispatchPrettyDefaultBy 'GHC.Types.True config a
instance (Text.PrettyBy.Internal.HasPrettyDefaults config GHC.Types.~ 'GHC.Types.False, Text.PrettyBy.Internal.NonDefaultPrettyBy config a) => Text.PrettyBy.Internal.DispatchPrettyDefaultBy 'GHC.Types.False config a
instance Text.PrettyBy.Internal.DefaultPrettyBy config a => Prettyprinter.Internal.Pretty (Text.PrettyBy.Internal.AttachDefaultPrettyConfig config a)
instance Text.PrettyBy.Internal.DefaultPrettyBy config Data.Void.Void
instance Text.PrettyBy.Internal.DefaultPrettyBy config ()
instance Text.PrettyBy.Internal.DefaultPrettyBy config GHC.Types.Bool
instance Text.PrettyBy.Internal.DefaultPrettyBy config GHC.Num.Natural.Natural
instance Text.PrettyBy.Internal.DefaultPrettyBy config GHC.Num.Integer.Integer
instance Text.PrettyBy.Internal.DefaultPrettyBy config GHC.Types.Int
instance Text.PrettyBy.Internal.DefaultPrettyBy config GHC.Int.Int8
instance Text.PrettyBy.Internal.DefaultPrettyBy config GHC.Int.Int16
instance Text.PrettyBy.Internal.DefaultPrettyBy config GHC.Int.Int32
instance Text.PrettyBy.Internal.DefaultPrettyBy config GHC.Int.Int64
instance Text.PrettyBy.Internal.DefaultPrettyBy config GHC.Types.Word
instance Text.PrettyBy.Internal.DefaultPrettyBy config GHC.Word.Word8
instance Text.PrettyBy.Internal.DefaultPrettyBy config GHC.Word.Word16
instance Text.PrettyBy.Internal.DefaultPrettyBy config GHC.Word.Word32
instance Text.PrettyBy.Internal.DefaultPrettyBy config GHC.Word.Word64
instance Text.PrettyBy.Internal.DefaultPrettyBy config GHC.Types.Float
instance Text.PrettyBy.Internal.DefaultPrettyBy config GHC.Types.Double
instance Text.PrettyBy.Internal.DefaultPrettyBy config Data.Text.Internal.Text
instance Text.PrettyBy.Internal.DefaultPrettyBy config Data.Text.Internal.Lazy.Text
instance Text.PrettyBy.Internal.PrettyBy config a => Text.PrettyBy.Internal.DefaultPrettyBy config (Data.Functor.Identity.Identity a)
instance Text.PrettyBy.Internal.PrettyBy config a => Text.PrettyBy.Internal.DefaultPrettyBy config (Data.Functor.Const.Const a b)
instance (Text.PrettyBy.Internal.PrettyBy config a, Text.PrettyBy.Internal.PrettyBy config b) => Text.PrettyBy.Internal.DefaultPrettyBy config (a, b)
instance (Text.PrettyBy.Internal.PrettyBy config a, Text.PrettyBy.Internal.PrettyBy config b, Text.PrettyBy.Internal.PrettyBy config c) => Text.PrettyBy.Internal.DefaultPrettyBy config (a, b, c)
instance Text.PrettyBy.Internal.PrettyBy config Data.Text.Internal.Text => Text.PrettyBy.Internal.DefaultPrettyBy config GHC.Types.Char
instance Text.PrettyBy.Internal.PrettyBy config a => Text.PrettyBy.Internal.DefaultPrettyBy config (GHC.Maybe.Maybe a)
instance Text.PrettyBy.Internal.PrettyBy config a => Text.PrettyBy.Internal.DefaultPrettyBy config [a]
instance Text.PrettyBy.Internal.PrettyBy config a => Text.PrettyBy.Internal.DefaultPrettyBy config (GHC.Base.NonEmpty a)
instance Prettyprinter.Internal.Pretty a => Text.PrettyBy.Internal.PrettyBy config (Text.PrettyBy.Internal.IgnorePrettyConfig a)
instance Text.PrettyBy.Internal.PrettyBy config a => Prettyprinter.Internal.Pretty (Text.PrettyBy.Internal.AttachPrettyConfig config a)
instance Text.PrettyBy.Internal.DispatchDefaultFor target (Text.PrettyBy.Internal.StarsOfHead target a) config a => Text.PrettyBy.Internal.DefaultFor target config a
instance (Text.PrettyBy.Internal.StarsOfHead target a GHC.Types.~ *, Prettyprinter.Internal.Pretty a) => Text.PrettyBy.Internal.DispatchDefaultFor target (*) config a
instance (Text.PrettyBy.Internal.StarsOfHead target fa GHC.Types.~ (k -> *), fa GHC.Types.~ f a, GHC.Base.Functor f, Prettyprinter.Internal.Pretty (f (Text.PrettyBy.Internal.AttachPrettyConfig config a))) => Text.PrettyBy.Internal.DispatchDefaultFor target (k -> *) config fa
instance (Text.PrettyBy.Internal.StarsOfHead target fab GHC.Types.~ (k1 -> k2 -> *), fab GHC.Types.~ f a b, Data.Bifunctor.Bifunctor f, Prettyprinter.Internal.Pretty (f (Text.PrettyBy.Internal.AttachPrettyConfig config a) (Text.PrettyBy.Internal.AttachPrettyConfig config b))) => Text.PrettyBy.Internal.DispatchDefaultFor target (k1 -> k2 -> *) config fab


-- | Default rendering to string types.
module Text.PrettyBy.Default

-- | A default layout for default rendering.
layoutDef :: Doc ann -> SimpleDocStream ann

-- | A class for rendering <a>Doc</a>s as string types.
class Render str

-- | Render a <a>Doc</a> as a string type.
render :: Render str => Doc ann -> str

-- | Pretty-print and render a value as a string type.
display :: forall str a. (Pretty a, Render str) => a -> str

-- | Pretty-print and render a value as a string type in a configurable
--   way.
displayBy :: forall str a config. (PrettyBy config a, Render str) => config -> a -> str
instance (a GHC.Types.~ GHC.Types.Char) => Text.PrettyBy.Default.Render [a]
instance Text.PrettyBy.Default.Render Data.Text.Internal.Text
instance Text.PrettyBy.Default.Render Data.Text.Internal.Lazy.Text


-- | The main module of the library.
module Text.PrettyBy

-- | A class for pretty-printing values in a configurable manner.
--   
--   A basic example:
--   
--   <pre>
--   &gt;&gt;&gt; data Case = UpperCase | LowerCase
--   
--   &gt;&gt;&gt; data D = D
--   
--   &gt;&gt;&gt; instance PrettyBy Case D where prettyBy UpperCase D = "D"; prettyBy LowerCase D = "d"
--   
--   &gt;&gt;&gt; prettyBy UpperCase D
--   D
--   
--   &gt;&gt;&gt; prettyBy LowerCase D
--   d
--   </pre>
--   
--   The library provides instances for common types like <a>Integer</a> or
--   <a>Bool</a>, so you can't define your own <tt>PrettyBy SomeConfig
--   Integer</tt> instance. And for the same reason you should not define
--   instances like <tt>PrettyBy SomeAnotherConfig a</tt> for universally
--   quantified <tt>a</tt>, because such an instance would overlap with the
--   existing ones. Take for example
--   
--   <pre>
--   &gt;&gt;&gt; data ViaShow = ViaShow
--   
--   &gt;&gt;&gt; instance Show a =&gt; PrettyBy ViaShow a where prettyBy ViaShow = pretty . show
--   </pre>
--   
--   with such an instance <tt>prettyBy ViaShow (1 :: Int)</tt> throws an
--   error about overlapping instances:
--   
--   <pre>
--   • Overlapping instances for PrettyBy ViaShow Int
--       arising from a use of ‘prettyBy’
--     Matching instances:
--       instance PrettyDefaultBy config Int =&gt; PrettyBy config Int
--       instance [safe] Show a =&gt; PrettyBy ViaShow a
--   </pre>
--   
--   There's a <tt>newtype</tt> provided specifically for the purpose of
--   defining a <a>PrettyBy</a> instance for any <tt>a</tt>:
--   <a>PrettyAny</a>. Read its docs for details on when you might want to
--   use it.
--   
--   The <a>PrettyBy</a> instance for common types is defined in a way that
--   allows to override default pretty-printing behaviour, read the docs of
--   <a>HasPrettyDefaults</a> for details.
class PrettyBy config a

-- | Pretty-print a value of type <tt>a</tt> the way a <tt>config</tt>
--   specifies it. The default implementation of <a>prettyBy</a> is in
--   terms of <a>pretty</a>, <a>defaultPrettyFunctorBy</a> or
--   <a>defaultPrettyBifunctorBy</a> depending on the kind of the data type
--   that you're providing an instance for. For example, the default
--   implementation of <a>prettyBy</a> for a monomorphic type is going to
--   be "ignore the config and call <a>pretty</a> over the value":
--   
--   <pre>
--   &gt;&gt;&gt; newtype N = N Int deriving newtype (Pretty)
--   
--   &gt;&gt;&gt; instance PrettyBy () N
--   
--   &gt;&gt;&gt; prettyBy () (N 42)
--   42
--   </pre>
--   
--   The default implementation of <a>prettyBy</a> for a <a>Functor</a> is
--   going to be in terms of <a>defaultPrettyFunctorBy</a>:
--   
--   <pre>
--   &gt;&gt;&gt; newtype N a = N a deriving stock (Functor) deriving newtype (Pretty)
--   
--   &gt;&gt;&gt; instance PrettyBy () a =&gt; PrettyBy () (N a)
--   
--   &gt;&gt;&gt; prettyBy () (N (42 :: Int))
--   42
--   </pre>
--   
--   It's fine for the data type to have a phantom parameter as long as the
--   data type is still a <a>Functor</a> (i.e. the parameter has to be of
--   kind <tt>Type</tt>). Then <a>defaultPrettyFunctorBy</a> is used again:
--   
--   <pre>
--   &gt;&gt;&gt; newtype N a = N Int deriving stock (Functor) deriving newtype (Pretty)
--   
--   &gt;&gt;&gt; instance PrettyBy () (N b)
--   
--   &gt;&gt;&gt; prettyBy () (N 42)
--   42
--   </pre>
--   
--   If the data type has a single parameter of any other kind, then it's
--   not a functor and so like in the monomorphic case <a>pretty</a> is
--   used:
--   
--   <pre>
--   &gt;&gt;&gt; newtype N (b :: Bool) = N Int deriving newtype (Pretty)
--   
--   &gt;&gt;&gt; instance PrettyBy () (N b)
--   
--   &gt;&gt;&gt; prettyBy () (N 42)
--   42
--   </pre>
--   
--   Same applies to a data type with two parameters: if both the
--   parameters are of kind <tt>Type</tt>, then the data type is assumed to
--   be a <a>Bifunctor</a> and hence <a>defaultPrettyBifunctorBy</a> is
--   used. If the right parameter is of kind <tt>Type</tt> and the left
--   parameter is of any other kind, then we fallback to assuming the data
--   type is a <a>Functor</a> and defining <a>prettyBy</a> as
--   <a>defaultPrettyFunctorBy</a>. If both the parameters are not of kind
--   <tt>Type</tt>, we fallback to implementing <a>prettyBy</a> in terms of
--   <a>pretty</a> like in the monomorphic case.
--   
--   Note that in all those cases a <a>Pretty</a> instance for the data
--   type has to already exist, so that we can derive a <a>PrettyBy</a> one
--   in terms of it. If it doesn't exist or if your data type is not
--   supported (for example, if it has three or more parameters of kind
--   <tt>Type</tt>), then you'll need to provide the implementation
--   manually.
prettyBy :: PrettyBy config a => config -> a -> Doc ann

-- | Pretty-print a value of type <tt>a</tt> the way a <tt>config</tt>
--   specifies it. The default implementation of <a>prettyBy</a> is in
--   terms of <a>pretty</a>, <a>defaultPrettyFunctorBy</a> or
--   <a>defaultPrettyBifunctorBy</a> depending on the kind of the data type
--   that you're providing an instance for. For example, the default
--   implementation of <a>prettyBy</a> for a monomorphic type is going to
--   be "ignore the config and call <a>pretty</a> over the value":
--   
--   <pre>
--   &gt;&gt;&gt; newtype N = N Int deriving newtype (Pretty)
--   
--   &gt;&gt;&gt; instance PrettyBy () N
--   
--   &gt;&gt;&gt; prettyBy () (N 42)
--   42
--   </pre>
--   
--   The default implementation of <a>prettyBy</a> for a <a>Functor</a> is
--   going to be in terms of <a>defaultPrettyFunctorBy</a>:
--   
--   <pre>
--   &gt;&gt;&gt; newtype N a = N a deriving stock (Functor) deriving newtype (Pretty)
--   
--   &gt;&gt;&gt; instance PrettyBy () a =&gt; PrettyBy () (N a)
--   
--   &gt;&gt;&gt; prettyBy () (N (42 :: Int))
--   42
--   </pre>
--   
--   It's fine for the data type to have a phantom parameter as long as the
--   data type is still a <a>Functor</a> (i.e. the parameter has to be of
--   kind <tt>Type</tt>). Then <a>defaultPrettyFunctorBy</a> is used again:
--   
--   <pre>
--   &gt;&gt;&gt; newtype N a = N Int deriving stock (Functor) deriving newtype (Pretty)
--   
--   &gt;&gt;&gt; instance PrettyBy () (N b)
--   
--   &gt;&gt;&gt; prettyBy () (N 42)
--   42
--   </pre>
--   
--   If the data type has a single parameter of any other kind, then it's
--   not a functor and so like in the monomorphic case <a>pretty</a> is
--   used:
--   
--   <pre>
--   &gt;&gt;&gt; newtype N (b :: Bool) = N Int deriving newtype (Pretty)
--   
--   &gt;&gt;&gt; instance PrettyBy () (N b)
--   
--   &gt;&gt;&gt; prettyBy () (N 42)
--   42
--   </pre>
--   
--   Same applies to a data type with two parameters: if both the
--   parameters are of kind <tt>Type</tt>, then the data type is assumed to
--   be a <a>Bifunctor</a> and hence <a>defaultPrettyBifunctorBy</a> is
--   used. If the right parameter is of kind <tt>Type</tt> and the left
--   parameter is of any other kind, then we fallback to assuming the data
--   type is a <a>Functor</a> and defining <a>prettyBy</a> as
--   <a>defaultPrettyFunctorBy</a>. If both the parameters are not of kind
--   <tt>Type</tt>, we fallback to implementing <a>prettyBy</a> in terms of
--   <a>pretty</a> like in the monomorphic case.
--   
--   Note that in all those cases a <a>Pretty</a> instance for the data
--   type has to already exist, so that we can derive a <a>PrettyBy</a> one
--   in terms of it. If it doesn't exist or if your data type is not
--   supported (for example, if it has three or more parameters of kind
--   <tt>Type</tt>), then you'll need to provide the implementation
--   manually.
prettyBy :: (PrettyBy config a, DefaultFor "prettyBy" config a) => config -> a -> Doc ann

-- | <a>prettyListBy</a> is used to define the default <a>PrettyBy</a>
--   instance for <tt>[a]</tt> and <tt>NonEmpty a</tt>. In normal
--   circumstances only the <a>prettyBy</a> function is used. The default
--   implementation of <a>prettyListBy</a> is in terms of
--   <a>defaultPrettyFunctorBy</a>.
prettyListBy :: PrettyBy config a => config -> [a] -> Doc ann

-- | <a>prettyListBy</a> is used to define the default <a>PrettyBy</a>
--   instance for <tt>[a]</tt> and <tt>NonEmpty a</tt>. In normal
--   circumstances only the <a>prettyBy</a> function is used. The default
--   implementation of <a>prettyListBy</a> is in terms of
--   <a>defaultPrettyFunctorBy</a>.
prettyListBy :: PrettyBy config a => config -> [a] -> Doc ann

-- | A newtype wrapper around <tt>a</tt> whose point is to provide a
--   <tt>PrettyBy config</tt> instance for anything that has a
--   <a>Pretty</a> instance.
newtype IgnorePrettyConfig a
IgnorePrettyConfig :: a -> IgnorePrettyConfig a
[unIgnorePrettyConfig] :: IgnorePrettyConfig a -> a

-- | A config together with some value. The point is to provide a
--   <a>Pretty</a> instance for anything that has a <tt>PrettyBy
--   config</tt> instance.
data AttachPrettyConfig config a
AttachPrettyConfig :: !config -> !a -> AttachPrettyConfig config a

-- | A <tt>newtype</tt> wrapper around <tt>a</tt> provided for the purporse
--   of defining <a>PrettyBy</a> instances handling any <tt>a</tt>. For
--   example you can wrap values with the <tt>PrettyAny</tt> constructor
--   directly like in this last line of
--   
--   <pre>
--   &gt;&gt;&gt; data ViaShow = ViaShow
--   
--   &gt;&gt;&gt; instance Show a =&gt; PrettyBy ViaShow (PrettyAny a) where prettyBy ViaShow = pretty . show . unPrettyAny
--   
--   &gt;&gt;&gt; prettyBy ViaShow $ PrettyAny True
--   True
--   </pre>
--   
--   or you can use the type to via-derive instances:
--   
--   <pre>
--   &gt;&gt;&gt; data D = D deriving stock (Show)
--   
--   &gt;&gt;&gt; deriving via PrettyAny D instance PrettyBy ViaShow D
--   
--   &gt;&gt;&gt; prettyBy ViaShow D
--   D
--   </pre>
--   
--   One important use case is handling sum-type configs. For example
--   having two configs you can define their sum and derive <a>PrettyBy</a>
--   for the unified config in terms of its components:
--   
--   <pre>
--   &gt;&gt;&gt; data UpperCase = UpperCase
--   
--   &gt;&gt;&gt; data LowerCase = LowerCase
--   
--   &gt;&gt;&gt; data Case = CaseUpperCase UpperCase | CaseLowerCase LowerCase
--   
--   &gt;&gt;&gt; instance (PrettyBy UpperCase a, PrettyBy LowerCase a) =&gt; PrettyBy Case (PrettyAny a) where prettyBy (CaseUpperCase upper) = prettyBy upper . unPrettyAny; prettyBy (CaseLowerCase lower) = prettyBy lower . unPrettyAny
--   </pre>
--   
--   Then having a data type implementing both <tt>PrettyBy UpperCase</tt>
--   and <tt>PrettyBy LowerCase</tt> you can derive <tt>PrettyBy Case</tt>
--   for that data type:
--   
--   <pre>
--   &gt;&gt;&gt; data D = D
--   
--   &gt;&gt;&gt; instance PrettyBy UpperCase D where prettyBy UpperCase D = "D"
--   
--   &gt;&gt;&gt; instance PrettyBy LowerCase D where prettyBy LowerCase D = "d"
--   
--   &gt;&gt;&gt; deriving via PrettyAny D instance PrettyBy Case D
--   
--   &gt;&gt;&gt; prettyBy UpperCase D
--   D
--   
--   &gt;&gt;&gt; prettyBy LowerCase D
--   d
--   </pre>
--   
--   Look into <tt>test/Universal.hs</tt> for an extended example.
newtype PrettyAny a
PrettyAny :: a -> PrettyAny a
[unPrettyAny] :: PrettyAny a -> a

-- | Pass <tt>AttachPrettyConfig config</tt> to the continuation.
withAttachPrettyConfig :: config -> ((forall a. a -> AttachPrettyConfig config a) -> r) -> r

-- | Default configurable pretty-printing for a <a>Functor</a> in terms of
--   <a>Pretty</a>. Attaches the config to each value in the functor and
--   calls <a>pretty</a> over the result, i.e. the spine of the functor is
--   pretty-printed the way the <a>Pretty</a> class specifies it, while the
--   elements are printed by <a>prettyBy</a>.
defaultPrettyFunctorBy :: (Functor f, Pretty (f (AttachPrettyConfig config a))) => config -> f a -> Doc ann

-- | Default configurable pretty-printing for a <a>Bifunctor</a> in terms
--   of <a>Pretty</a> Attaches the config to each value in the bifunctor
--   and calls <a>pretty</a> over the result, i.e. the spine of the
--   bifunctor is pretty-printed the way the <a>Pretty</a> class specifies
--   it, while the elements are printed by <a>prettyBy</a>.
defaultPrettyBifunctorBy :: (Bifunctor f, Pretty (f (AttachPrettyConfig config a) (AttachPrettyConfig config b))) => config -> f a b -> Doc ann

-- | A class for overriding default pretty-printing behavior for types
--   having it. Read the docs of <a>HasPrettyDefaults</a> for how to use
--   the class.
class NonDefaultPrettyBy config a

-- | Pretty-print a value of a type supporting default pretty-printing in a
--   possibly non-default way. The "possibly" is due to
--   <a>nonDefaultPrettyBy</a> having a default implementation as
--   <a>defaultPrettyBy</a>. See docs for <a>HasPrettyDefaults</a> for
--   details.
nonDefaultPrettyBy :: NonDefaultPrettyBy config a => config -> a -> Doc ann

-- | Pretty-print a value of a type supporting default pretty-printing in a
--   possibly non-default way. The "possibly" is due to
--   <a>nonDefaultPrettyBy</a> having a default implementation as
--   <a>defaultPrettyBy</a>. See docs for <a>HasPrettyDefaults</a> for
--   details.
nonDefaultPrettyBy :: (NonDefaultPrettyBy config a, DefaultPrettyBy config a) => config -> a -> Doc ann

-- | <a>nonDefaultPrettyListBy</a> to <a>prettyListBy</a> is what
--   <a>nonDefaultPrettyBy</a> to <a>prettyBy</a>. Analogously, the default
--   implementation is <a>defaultPrettyListBy</a>.
nonDefaultPrettyListBy :: NonDefaultPrettyBy config a => config -> [a] -> Doc ann

-- | <a>nonDefaultPrettyListBy</a> to <a>prettyListBy</a> is what
--   <a>nonDefaultPrettyBy</a> to <a>prettyBy</a>. Analogously, the default
--   implementation is <a>defaultPrettyListBy</a>.
nonDefaultPrettyListBy :: (NonDefaultPrettyBy config a, DefaultPrettyBy config a) => config -> [a] -> Doc ann

-- | Determines whether a pretty-printing config allows default
--   pretty-printing for types that support it. I.e. it's possible to
--   create a new config and get access to pretty-printing for all types
--   supporting default pretty-printing just by providing the right type
--   instance. Example:
--   
--   <pre>
--   &gt;&gt;&gt; data DefCfg = DefCfg
--   
--   &gt;&gt;&gt; type instance HasPrettyDefaults DefCfg = 'True
--   
--   &gt;&gt;&gt; prettyBy DefCfg (['a', 'b', 'c'], (1 :: Int), Just True)
--   (abc, 1, True)
--   </pre>
--   
--   The set of types supporting default pretty-printing is determined by
--   the <tt>prettyprinter</tt> library: whatever <b>there</b> has a
--   <a>Pretty</a> instance also supports default pretty-printing in this
--   library and the behavior of <tt>pretty x</tt> and <tt>prettyBy
--   config_with_defaults x</tt> must be identical when <tt>x</tt> is one
--   of such types.
--   
--   It is possible to override default pretty-printing. For this you need
--   to specify that <a>HasPrettyDefaults</a> is <tt>'False</tt> for your
--   config and then define a <tt>NonDefaultPrettyBy config</tt> instance
--   for each of the types supporting default pretty-printing that you want
--   to pretty-print values of. Note that once <a>HasPrettyDefaults</a> is
--   specified to be <tt>'False</tt>, <b>all defaults are lost</b> for your
--   config, so you can't override default pretty-printing for one type and
--   keep the defaults for all the others. I.e. if you have
--   
--   <pre>
--   &gt;&gt;&gt; data NonDefCfg = NonDefCfg
--   
--   &gt;&gt;&gt; type instance HasPrettyDefaults NonDefCfg = 'False
--   </pre>
--   
--   then you have no defaults available and an attempt to pretty-print a
--   value of a type supporting default pretty-printing
--   
--   <pre>
--   prettyBy NonDefCfg True
--   </pre>
--   
--   results in a type error:
--   
--   <pre>
--   • No instance for (NonDefaultPrettyBy NonDef Bool)
--        arising from a use of ‘prettyBy’
--   </pre>
--   
--   As the error suggests you need to provide a <a>NonDefaultPrettyBy</a>
--   instance explicitly:
--   
--   <pre>
--   &gt;&gt;&gt; instance NonDefaultPrettyBy NonDefCfg Bool where nonDefaultPrettyBy _ b = if b then "t" else "f"
--   
--   &gt;&gt;&gt; prettyBy NonDefCfg True
--   t
--   </pre>
--   
--   It is also possible not to provide any implementation for
--   <a>nonDefaultPrettyBy</a>, in which case it defaults to being the
--   default pretty-printing for the given type. This can be useful to
--   recover default pretty-printing for types pretty-printing of which you
--   don't want to override:
--   
--   <pre>
--   &gt;&gt;&gt; instance NonDefaultPrettyBy NonDefCfg Int
--   
--   &gt;&gt;&gt; prettyBy NonDefCfg (42 :: Int)
--   42
--   </pre>
--   
--   Look into <tt>test/NonDefault.hs</tt> for an extended example.
--   
--   We could give the user more fine-grained control over what defaults to
--   override instead of requiring to explicitly provide all the instances
--   whenever there's a need to override any default behavior, but that
--   would complicate the library even more, so we opted for not doing that
--   at the moment.
--   
--   Note that you can always override default behavior by wrapping a type
--   in <tt>newtype</tt> and providing a <tt>PrettyBy config_name</tt>
--   instance for that <tt>newtype</tt>.
--   
--   Also note that if you want to extend the set of types supporting
--   default pretty-printing it's not enough to provide a <a>Pretty</a>
--   instance for your type (such logic is hardly expressible in present
--   day Haskell). Read the docs of <a>DefaultPrettyBy</a> for how to
--   extend the set of types supporting default pretty-printing.
type family HasPrettyDefaults config :: Bool

-- | <tt>PrettyDefaultBy config a</tt> is the same thing as <tt>PrettyBy
--   config a</tt>, when <tt>a</tt> supports default pretty-printing. Thus
--   <tt>PrettyDefaultBy config a</tt> and <tt>PrettyBy config a</tt> are
--   interchangeable constraints for such types, but the latter throws an
--   annoying "this makes type inference for inner bindings fragile"
--   warning, unlike the former. <tt>PrettyDefaultBy config a</tt> reads as
--   "<tt>a</tt> supports default pretty-printing and can be pretty-printed
--   via <tt>config</tt> in either default or non-default manner depending
--   on whether <tt>config</tt> supports default pretty-printing".
type PrettyDefaultBy config = DispatchPrettyDefaultBy (NonStuckHasPrettyDefaults config) config

-- | A class for rendering <a>Doc</a>s as string types.
class Render str

-- | Render a <a>Doc</a> as a string type.
render :: Render str => Doc ann -> str

-- | Pretty-print and render a value as a string type.
display :: forall str a. (Pretty a, Render str) => a -> str

-- | Pretty-print and render a value as a string type in a configurable
--   way.
displayBy :: forall str a config. (PrettyBy config a, Render str) => config -> a -> str


-- | Utils used internally.
module Text.PrettyBy.Internal.Utils

-- | An inlined
--   <a>https://hackage.haskell.org/package/microlens-mtl-0.2.0.1/docs/Lens-Micro-Mtl.html#v:view</a>
--   (just not to depend on this package).
view :: MonadReader s m => Getting a s a -> m a


-- | A monadic interface to configurable pretty-printing.
module Text.PrettyBy.Monad

-- | A constraint for "<tt>config</tt> is a part of <tt>env</tt>".
class HasPrettyConfig env config | env -> config
prettyConfig :: HasPrettyConfig env config => Lens' env config

-- | A constraint for "<tt>m</tt> is a monad that allows to pretty-print
--   values in it by a <tt>config</tt>".
type MonadPretty config env m = (MonadReader env m, HasPrettyConfig env config)

-- | Pretty-print a value in a configurable way in a monad holding a
--   config.
prettyM :: (MonadPretty config env m, PrettyBy config a) => a -> m (Doc ann)

-- | Pretty-print and render a value as a string type in a configurable way
--   in a monad holding a config.
displayM :: forall str a m env config. (MonadPretty config env m, PrettyBy config a, Render str) => a -> m str


-- | Configurable precedence-aware pretty-printing.
--   
--   Look into <tt>test/Expr.hs</tt> for an extended example.
module Text.PrettyBy.Fixity

-- | The type of a general <tt>config</tt>-based pretty-printer.
type AnyToDoc config ann = forall a. PrettyBy config a => a -> Doc ann

-- | A monad for precedence-aware pretty-printing.
newtype InContextM config a
InContextM :: Reader (Sole config) a -> InContextM config a
[unInContextM] :: InContextM config a -> Reader (Sole config) a

-- | A <tt>newtype</tt> wrapper around <tt>a</tt> introduced for its
--   <a>HasPrettyConfig</a> instance.
newtype Sole a
Sole :: a -> Sole a
[unSole] :: Sole a -> a

-- | A constraint for "<tt>m</tt> is a <a>Monad</a> supporting configurable
--   precedence-aware pretty-printing".
type MonadPrettyContext config env m = (MonadPretty config env m, HasRenderContext config)

-- | A constraint for "<a>RenderContext</a> is a part of <tt>config</tt>".
class HasRenderContext config
renderContext :: HasRenderContext config => Lens' config RenderContext

-- | Run <a>InContextM</a> by supplying a <tt>config</tt>.
runInContextM :: config -> InContextM config a -> a

-- | Takes a monadic pretty-printer and turns it into one that receives a
--   <tt>config</tt> explicitly. Useful for defining instances of
--   <a>PrettyBy</a> monadically when writing precedence-aware
--   pretty-printing code (and since all functions below are monadic, it's
--   currenty the only option).
inContextM :: (a -> InContextM config (Doc ann)) -> config -> a -> Doc ann

-- | Enclose a <a>Doc</a> in parentheses if required or leave it as is. The
--   need for enclosing is determined from an outer <a>RenderContext</a>
--   (stored in the environment of the monad) and the inner fixity provided
--   as an argument.
encloseM :: MonadPrettyContext config env m => Fixity -> Doc ann -> m (Doc ann)

-- | Instantiate a supplied continuation with a precedence-aware
--   pretty-printer.
withPrettyIn :: MonadPrettyContext config env m => ((forall a. PrettyBy config a => Direction -> Fixity -> a -> Doc ann) -> m r) -> m r

-- | Instantiate a supplied continuation with a pretty-printer specialized
--   to supplied <a>Fixity</a> and <a>Direction</a>.
withPrettyAt :: MonadPrettyContext config env m => Direction -> Fixity -> (AnyToDoc config ann -> m r) -> m r

-- | Call <a>encloseM</a> on <a>unitFixity</a>.
unitDocM :: MonadPrettyContext config env m => Doc ann -> m (Doc ann)

-- | Instantiate a supplied continuation with a pretty-printer and apply
--   <a>encloseM</a>, specialized to supplied <a>Fixity</a>, to the result.
compoundDocM :: MonadPrettyContext config env m => Fixity -> ((forall a. PrettyBy config a => Direction -> Fixity -> a -> Doc ann) -> Doc ann) -> m (Doc ann)

-- | Instantiate a supplied continuation with a pretty-printer specialized
--   to supplied <a>Fixity</a> and <a>Direction</a> and apply
--   <a>encloseM</a> specialized to the provided fixity to the result. This
--   can be useful for pretty-printing a sequence of values (possibly
--   consisting of a single value).
sequenceDocM :: MonadPrettyContext config env m => Direction -> Fixity -> (AnyToDoc config ann -> Doc ann) -> m (Doc ann)

-- | Instantiate a supplied continuation with two pretty-printers (one is
--   going in the <a>ToTheLeft</a> direction, the other is in the
--   <a>ToTheRight</a> direction) specialized to supplied <a>Fixity</a> and
--   apply <a>encloseM</a>, specialized to the same fixity, to the result.
--   The idea is that to the outside an infix operator has the same inner
--   fixity as it has the outer fixity to inner subexpressions.
infixDocM :: MonadPrettyContext config env m => Fixity -> (AnyToDoc config ann -> AnyToDoc config ann -> Doc ann) -> m (Doc ann)

-- | Pretty-print two things with a space between them. The fixity of the
--   context in which the arguments get pretty-printed is set to
--   <a>juxtFixity</a>.
juxtPrettyM :: (MonadPrettyContext config env m, PrettyBy config a, PrettyBy config b) => a -> b -> m (Doc ann)
instance Control.Monad.Reader.Class.MonadReader (Text.PrettyBy.Fixity.Sole config) (Text.PrettyBy.Fixity.InContextM config)
instance GHC.Base.Monad (Text.PrettyBy.Fixity.InContextM config)
instance GHC.Base.Applicative (Text.PrettyBy.Fixity.InContextM config)
instance GHC.Base.Functor (Text.PrettyBy.Fixity.InContextM config)
instance (Text.PrettyBy.Fixity.HasRenderContext config, doc GHC.Types.~ Prettyprinter.Internal.Doc ann) => Data.String.IsString (Text.PrettyBy.Fixity.InContextM config doc)
instance Text.PrettyBy.Monad.HasPrettyConfig (Text.PrettyBy.Fixity.Sole config) config
instance Text.PrettyBy.Fixity.HasRenderContext Text.Fixity.RenderContext
