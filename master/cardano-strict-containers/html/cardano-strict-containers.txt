-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Various strict container types
--   
--   Various strict container types
@package cardano-strict-containers
@version 0.1.2.0


-- | Strict version of the <a>Maybe</a> type.
module Data.Maybe.Strict
data StrictMaybe a
SNothing :: StrictMaybe a
SJust :: !a -> StrictMaybe a
strictMaybeToMaybe :: StrictMaybe a -> Maybe a
maybeToStrictMaybe :: Maybe a -> StrictMaybe a

-- | Same as <a>fromMaybe</a>
fromSMaybe :: a -> StrictMaybe a -> a

-- | Same as <a>isNothing</a>
isSNothing :: StrictMaybe a -> Bool

-- | Same as <a>isJust</a>
isSJust :: StrictMaybe a -> Bool

-- | Same as <a>maybe</a>
strictMaybe :: a -> (b -> a) -> StrictMaybe b -> a
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Maybe.Strict.StrictMaybe a)
instance NoThunks.Class.NoThunks a => NoThunks.Class.NoThunks (Data.Maybe.Strict.StrictMaybe a)
instance Data.Traversable.Traversable Data.Maybe.Strict.StrictMaybe
instance Data.Foldable.Foldable Data.Maybe.Strict.StrictMaybe
instance GHC.Base.Functor Data.Maybe.Strict.StrictMaybe
instance GHC.Generics.Generic (Data.Maybe.Strict.StrictMaybe a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Maybe.Strict.StrictMaybe a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Maybe.Strict.StrictMaybe a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Maybe.Strict.StrictMaybe a)
instance GHC.Base.Applicative Data.Maybe.Strict.StrictMaybe
instance GHC.Base.Monad Data.Maybe.Strict.StrictMaybe
instance Control.Monad.Fail.MonadFail Data.Maybe.Strict.StrictMaybe
instance Cardano.Binary.ToCBOR.ToCBOR a => Cardano.Binary.ToCBOR.ToCBOR (Data.Maybe.Strict.StrictMaybe a)
instance Cardano.Binary.FromCBOR.FromCBOR a => Cardano.Binary.FromCBOR.FromCBOR (Data.Maybe.Strict.StrictMaybe a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Data.Maybe.Strict.StrictMaybe a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Data.Maybe.Strict.StrictMaybe a)
instance Data.Default.Class.Default (Data.Maybe.Strict.StrictMaybe t)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Maybe.Strict.StrictMaybe a)
instance GHC.Base.Semigroup a => GHC.Base.Monoid (Data.Maybe.Strict.StrictMaybe a)
instance GHC.Base.Alternative Data.Maybe.Strict.StrictMaybe


-- | Helper functions for enforcing strictness.
module Data.Unit.Strict

-- | The equivalent of <tt>()</tt>, but with a strict <a>mappend</a>
--   implementation.
--   
--   For more information, see the documentation for
--   <a>forceElemsToWHNF</a>.
data StrictUnit

-- | Force all of the elements of a <a>Foldable</a> to weak head normal
--   form.
--   
--   In order to ensure that all of the elements of a <a>Foldable</a> are
--   strict, we can simply <a>foldMap</a> over it and <a>seq</a> each value
--   with <tt>()</tt>. However, <tt>()</tt>'s <a>mappend</a> implementation
--   is actually completely lazy: <tt>_ &lt;&gt; _ = ()</tt> So, in order
--   to work around this, we instead utilize this newly defined
--   <a>StrictUnit</a> whose <a>mappend</a> implementation is specifically
--   strict.
forceElemsToWHNF :: Foldable t => t a -> t a
instance GHC.Base.Semigroup Data.Unit.Strict.StrictUnit
instance GHC.Base.Monoid Data.Unit.Strict.StrictUnit


-- | Strict variants of <a>Seq</a> operations.
module Data.Sequence.Strict

-- | A <tt>newtype</tt> wrapper around a <a>Seq</a>, representing a
--   general-purpose finite sequence that is strict in its values.
--   
--   This strictness is not enforced at the type level, but rather by the
--   construction functions in this module. These functions essentially
--   just wrap the original <a>Data.Sequence</a> functions while forcing
--   the provided value to WHNF.
data StrictSeq a

-- | A bidirectional pattern synonym matching an empty sequence.
pattern Empty :: StrictSeq a

-- | A bidirectional pattern synonym viewing the front of a non-empty
--   sequence.
pattern (:<|) :: a -> StrictSeq a -> StrictSeq a

-- | A bidirectional pattern synonym viewing the rear of a non-empty
--   sequence.
pattern (:|>) :: StrictSeq a -> a -> StrictSeq a
infixr 5 :<|
infixl 5 :|>
fromStrict :: StrictSeq a -> Seq a

-- | Convert a <a>Seq</a> into a <a>StrictSeq</a> by forcing each element
--   to WHNF.
forceToStrict :: Seq a -> StrictSeq a

-- | &lt;math&gt;. The empty sequence.
empty :: StrictSeq a

-- | &lt;math&gt;. A singleton sequence.
singleton :: a -> StrictSeq a

-- | &lt;math&gt;. Add an element to the left end of a sequence. Mnemonic:
--   a triangle with the single element at the pointy end.
(<|) :: a -> StrictSeq a -> StrictSeq a
infixr 5 <|

-- | &lt;math&gt;. Add an element to the right end of a sequence. Mnemonic:
--   a triangle with the single element at the pointy end.
(|>) :: StrictSeq a -> a -> StrictSeq a
infixl 5 |>

-- | &lt;math&gt;. Concatenate two sequences.
(><) :: StrictSeq a -> StrictSeq a -> StrictSeq a
infixr 5 ><
fromList :: [a] -> StrictSeq a

-- | &lt;math&gt;. Is this the empty sequence?
null :: StrictSeq a -> Bool

-- | &lt;math&gt;. The number of elements in the sequence.
length :: StrictSeq a -> Int

-- | <a>scanl</a> is similar to <a>foldl</a>, but returns a sequence of
--   reduced values from the left:
--   
--   <pre>
--   scanl f z (fromList [x1, x2, ...]) = fromList [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
scanl :: (a -> b -> a) -> a -> StrictSeq b -> StrictSeq a

-- | &lt;math&gt; where &lt;math&gt; is the prefix length.
--   <tt><a>dropWhileL</a> p xs</tt> returns the suffix remaining after
--   <tt><tt>takeWhileL</tt> p xs</tt>.
dropWhileL :: (a -> Bool) -> StrictSeq a -> StrictSeq a

-- | &lt;math&gt; where &lt;math&gt; is the suffix length.
--   <tt><a>dropWhileR</a> p xs</tt> returns the prefix remaining after
--   <tt><tt>takeWhileR</tt> p xs</tt>.
--   
--   <tt><a>dropWhileR</a> p xs</tt> is equivalent to <tt><a>reverse</a>
--   (<a>dropWhileL</a> p (<a>reverse</a> xs))</tt>.
dropWhileR :: (a -> Bool) -> StrictSeq a -> StrictSeq a

-- | &lt;math&gt; where &lt;math&gt; is the prefix length. <a>spanl</a>,
--   applied to a predicate <tt>p</tt> and a sequence <tt>xs</tt>, returns
--   a pair whose first element is the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt> and the second element
--   is the remainder of the sequence.
spanl :: (a -> Bool) -> StrictSeq a -> (StrictSeq a, StrictSeq a)

-- | &lt;math&gt; where &lt;math&gt; is the suffix length. <a>spanr</a>,
--   applied to a predicate <tt>p</tt> and a sequence <tt>xs</tt>, returns
--   a pair whose <i>first</i> element is the longest <i>suffix</i>
--   (possibly empty) of <tt>xs</tt> of elements that satisfy <tt>p</tt>
--   and the second element is the remainder of the sequence.
spanr :: (a -> Bool) -> StrictSeq a -> (StrictSeq a, StrictSeq a)

-- | &lt;math&gt;. The element at the specified position, counting from 0.
--   If the specified position is negative or at least the length of the
--   sequence, <a>lookup</a> returns <a>Nothing</a>.
--   
--   <pre>
--   0 &lt;= i &lt; length xs ==&gt; lookup i xs == Just (toList xs !! i)
--   </pre>
--   
--   <pre>
--   i &lt; 0 || i &gt;= length xs ==&gt; lookup i xs = Nothing
--   </pre>
--   
--   Unlike <tt>index</tt>, this can be used to retrieve an element without
--   forcing it. For example, to insert the fifth element of a sequence
--   <tt>xs</tt> into a <a>Map</a> <tt>m</tt> at key <tt>k</tt>, you could
--   use
--   
--   <pre>
--   case lookup 5 xs of
--     Nothing -&gt; m
--     Just x -&gt; <a>insert</a> k x m
--   </pre>
lookup :: Int -> StrictSeq a -> Maybe a

-- | &lt;math&gt;. A flipped, infix version of <a>lookup</a>.
(!?) :: StrictSeq a -> Int -> Maybe a

-- | &lt;math&gt;. The first <tt>i</tt> elements of a sequence. If
--   <tt>i</tt> is negative, <tt><a>take</a> i s</tt> yields the empty
--   sequence. If the sequence contains fewer than <tt>i</tt> elements, the
--   whole sequence is returned.
take :: Int -> StrictSeq a -> StrictSeq a

-- | Take the last <tt>n</tt> elements
--   
--   Returns the entire sequence if it has fewer than <tt>n</tt> elements.
--   
--   Inherits asymptotic complexity from <tt>drop</tt>.
takeLast :: Int -> StrictSeq a -> StrictSeq a

-- | &lt;math&gt;. Elements of a sequence after the first <tt>i</tt>. If
--   <tt>i</tt> is negative, <tt><a>drop</a> i s</tt> yields the whole
--   sequence. If the sequence contains fewer than <tt>i</tt> elements, the
--   empty sequence is returned.
drop :: Int -> StrictSeq a -> StrictSeq a

-- | Drop the last <tt>n</tt> elements
--   
--   Returns the <tt>Empty</tt> sequence if it has fewer than <tt>n</tt>
--   elements.
--   
--   Inherits asymptotic complexity from <tt>take</tt>.
dropLast :: Int -> StrictSeq a -> StrictSeq a

-- | &lt;math&gt;. Split a sequence at a given position. <tt><a>splitAt</a>
--   i s = (<a>take</a> i s, <a>drop</a> i s)</tt>.
splitAt :: Int -> StrictSeq a -> (StrictSeq a, StrictSeq a)

-- | Split at the given position counting from the end of the sequence.
--   
--   Inherits asymptotic complexity from <a>splitAt</a>.
splitAtEnd :: Int -> StrictSeq a -> (StrictSeq a, StrictSeq a)

-- | <tt><a>findIndexL</a> p xs</tt> finds the index of the leftmost
--   element that satisfies <tt>p</tt>, if any exist.
findIndexL :: (a -> Bool) -> StrictSeq a -> Maybe Int

-- | <tt><a>findIndicesL</a> p</tt> finds all indices of elements that
--   satisfy <tt>p</tt>, in ascending order.
findIndicesL :: (a -> Bool) -> StrictSeq a -> [Int]

-- | <tt><a>findIndexR</a> p xs</tt> finds the index of the rightmost
--   element that satisfies <tt>p</tt>, if any exist.
findIndexR :: (a -> Bool) -> StrictSeq a -> Maybe Int

-- | <tt><a>findIndicesR</a> p</tt> finds all indices of elements that
--   satisfy <tt>p</tt>, in descending order.
findIndicesR :: (a -> Bool) -> StrictSeq a -> [Int]
zip :: StrictSeq a -> StrictSeq b -> StrictSeq (a, b)
zipWith :: (a -> b -> c) -> StrictSeq a -> StrictSeq b -> StrictSeq c
unzip :: StrictSeq (a, b) -> (StrictSeq a, StrictSeq b)
unzipWith :: (a -> (b, c)) -> StrictSeq a -> (StrictSeq b, StrictSeq c)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Sequence.Strict.StrictSeq a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Data.Sequence.Strict.StrictSeq a)
instance GHC.Base.Semigroup (Data.Sequence.Strict.StrictSeq a)
instance GHC.Base.Monoid (Data.Sequence.Strict.StrictSeq a)
instance Data.Foldable.Foldable Data.Sequence.Strict.StrictSeq
instance GHC.Show.Show a => GHC.Show.Show (Data.Sequence.Strict.StrictSeq a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Sequence.Strict.StrictSeq a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Sequence.Strict.StrictSeq a)
instance Cardano.Binary.ToCBOR.ToCBOR a => Cardano.Binary.ToCBOR.ToCBOR (Data.Sequence.Strict.StrictSeq a)
instance Cardano.Binary.FromCBOR.FromCBOR a => Cardano.Binary.FromCBOR.FromCBOR (Data.Sequence.Strict.StrictSeq a)
instance GHC.Base.Functor Data.Sequence.Strict.StrictSeq
instance Data.Traversable.Traversable Data.Sequence.Strict.StrictSeq
instance NoThunks.Class.NoThunks a => NoThunks.Class.NoThunks (Data.Sequence.Strict.StrictSeq a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Data.Sequence.Strict.StrictSeq a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Data.Sequence.Strict.StrictSeq a)


-- | Strict variants of <tt>FingerTree</tt> operations.
module Data.FingerTree.Strict

-- | A <tt>newtype</tt> wrapper around a <a>FingerTree</a>, representing a
--   finger tree that is strict in its values.
--   
--   This strictness is not enforced at the type level, but rather by the
--   construction functions in this module. These functions essentially
--   just wrap the original <a>Data.FingerTree</a> functions while forcing
--   the provided value to WHNF.
data StrictFingerTree v a
fromStrict :: StrictFingerTree v a -> FingerTree v a

-- | Convert a <a>FingerTree</a> into a <a>StrictFingerTree</a> by forcing
--   each element to WHNF.
forceToStrict :: FingerTree v a -> StrictFingerTree v a

-- | <i>O(1)</i>. The empty sequence.
empty :: Measured v a => StrictFingerTree v a

-- | <i>O(1)</i>. A singleton sequence.
singleton :: Measured v a => a -> StrictFingerTree v a

-- | <i>O(1)</i>. Add an element to the left end of a sequence. Mnemonic: a
--   triangle with the single element at the pointy end.
(<|) :: Measured v a => a -> StrictFingerTree v a -> StrictFingerTree v a
infixr 5 <|

-- | <i>O(1)</i>. Add an element to the right end of a sequence. Mnemonic:
--   a triangle with the single element at the pointy end.
(|>) :: Measured v a => StrictFingerTree v a -> a -> StrictFingerTree v a
infixl 5 |>

-- | <i>O(log(min(n1,n2)))</i>. Concatenate two sequences.
(><) :: Measured v a => StrictFingerTree v a -> StrictFingerTree v a -> StrictFingerTree v a
infixr 5 ><

-- | <i>O(n)</i>. Create a sequence from a finite list of elements. The
--   opposite operation <a>toList</a> is supplied by the <a>Foldable</a>
--   instance.
fromList :: Measured v a => [a] -> StrictFingerTree v a

-- | <i>O(1)</i>. Is this the empty sequence?
null :: StrictFingerTree v a -> Bool

-- | <i>O(1)</i>. Analyse the left end of a sequence.
viewl :: Measured v a => StrictFingerTree v a -> ViewL (StrictFingerTree v) a

-- | <i>O(1)</i>. Analyse the right end of a sequence.
viewr :: Measured v a => StrictFingerTree v a -> ViewR (StrictFingerTree v) a

-- | A result of <a>search</a>, attempting to find a point where a
--   predicate on splits of the sequence changes from <a>False</a> to
--   <a>True</a>.
data SearchResult v a

-- | A tree opened at a particular element: the prefix to the left, the
--   element, and the suffix to the right.
Position :: !StrictFingerTree v a -> !a -> !StrictFingerTree v a -> SearchResult v a

-- | A position to the left of the sequence, indicating that the predicate
--   is <a>True</a> at both ends.
OnLeft :: SearchResult v a

-- | A position to the right of the sequence, indicating that the predicate
--   is <a>False</a> at both ends.
OnRight :: SearchResult v a

-- | No position in the tree, returned if the predicate is <a>True</a> at
--   the left end and <a>False</a> at the right end. This will not occur if
--   the predicate in monotonic on the tree.
Nowhere :: SearchResult v a

-- | <i>O(log(min(i,n-i)))</i>. Search a sequence for a point where a
--   predicate on splits of the sequence changes from <a>False</a> to
--   <a>True</a>.
--   
--   The argument <tt>p</tt> is a relation between the measures of the two
--   sequences that could be appended together to form the sequence
--   <tt>t</tt>. If the relation is <a>False</a> at the leftmost split and
--   <a>True</a> at the rightmost split, i.e.
--   
--   <pre>
--   not (p <a>mempty</a> (<a>measure</a> t)) &amp;&amp; p (<a>measure</a> t) <a>mempty</a>
--   </pre>
--   
--   then there must exist an element <tt>x</tt> in the sequence such that
--   <tt>p</tt> is <a>False</a> for the split immediately before <tt>x</tt>
--   and <a>True</a> for the split just after it:
--   
--   
--   In this situation, <tt><a>search</a> p t</tt> returns such an element
--   <tt>x</tt> and the pieces <tt>l</tt> and <tt>r</tt> of the sequence to
--   its left and right respectively. That is, it returns
--   <tt><a>Position</a> l x r</tt> such that
--   
--   <ul>
--   <li><pre>l &gt;&lt; (x &lt;| r) = t</pre></li>
--   <li><pre>not (p (measure l) (measure (x &lt;| r))</pre></li>
--   <li><pre>p (measure (l |&gt; x)) (measure r)</pre></li>
--   </ul>
--   
--   For predictable results, one should ensure that there is only one such
--   point, i.e. that the predicate is <i>monotonic</i> on <tt>t</tt>.
search :: Measured v a => (v -> v -> Bool) -> StrictFingerTree v a -> SearchResult v a

-- | <i>O(log(min(i,n-i)))</i>. Split a sequence at a point where the
--   predicate on the accumulated measure of the prefix changes from
--   <a>False</a> to <a>True</a>.
--   
--   For predictable results, one should ensure that there is only one such
--   point, i.e. that the predicate is <i>monotonic</i>.
split :: Measured v a => (v -> Bool) -> StrictFingerTree v a -> (StrictFingerTree v a, StrictFingerTree v a)

-- | <i>O(log(min(i,n-i)))</i>. Given a monotonic predicate <tt>p</tt>,
--   <tt><a>takeUntil</a> p t</tt> is the largest prefix of <tt>t</tt>
--   whose measure does not satisfy <tt>p</tt>.
--   
--   <ul>
--   <li><pre><a>takeUntil</a> p t = <a>fst</a> (<a>split</a> p
--   t)</pre></li>
--   </ul>
takeUntil :: Measured v a => (v -> Bool) -> StrictFingerTree v a -> StrictFingerTree v a

-- | <i>O(log(min(i,n-i)))</i>. Given a monotonic predicate <tt>p</tt>,
--   <tt><a>dropUntil</a> p t</tt> is the rest of <tt>t</tt> after removing
--   the largest prefix whose measure does not satisfy <tt>p</tt>.
--   
--   <ul>
--   <li><pre><a>dropUntil</a> p t = <a>snd</a> (<a>split</a> p
--   t)</pre></li>
--   </ul>
dropUntil :: Measured v a => (v -> Bool) -> StrictFingerTree v a -> StrictFingerTree v a

-- | <i>O(n)</i>. The reverse of a sequence.
reverse :: Measured v a => StrictFingerTree v a -> StrictFingerTree v a

-- | Like <a>fmap</a>, but with constraints on the element types.
fmap' :: (Measured v1 a1, Measured v2 a2) => (a1 -> a2) -> StrictFingerTree v1 a1 -> StrictFingerTree v2 a2

-- | Like <a>fmap</a>, but safe only if the function preserves the measure.
unsafeFmap :: (a -> b) -> StrictFingerTree v a -> StrictFingerTree v b

-- | Things that can be measured.
class Monoid v => Measured v a | a -> v
measure :: Measured v a => a -> v

-- | View of the left end of a sequence.
data ViewL (s :: Type -> Type) a

-- | empty sequence
EmptyL :: ViewL (s :: Type -> Type) a

-- | leftmost element and the rest of the sequence
(:<) :: a -> s a -> ViewL (s :: Type -> Type) a
infixr 5 :<

-- | View of the right end of a sequence.
data ViewR (s :: Type -> Type) a

-- | empty sequence
EmptyR :: ViewR (s :: Type -> Type) a

-- | the sequence minus the rightmost element, and the rightmost element
(:>) :: s a -> a -> ViewR (s :: Type -> Type) a
infixl 5 :>
instance Data.FingerTree.Measured v a => Data.FingerTree.Measured v (Data.FingerTree.Strict.StrictFingerTree v a)
instance Data.FingerTree.Measured v a => GHC.Base.Monoid (Data.FingerTree.Strict.StrictFingerTree v a)
instance Data.FingerTree.Measured v a => GHC.Base.Semigroup (Data.FingerTree.Strict.StrictFingerTree v a)
instance Data.Foldable.Foldable (Data.FingerTree.Strict.StrictFingerTree v)
instance GHC.Show.Show a => GHC.Show.Show (Data.FingerTree.Strict.StrictFingerTree v a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.FingerTree.Strict.StrictFingerTree v a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.FingerTree.Strict.StrictFingerTree v a)
instance GHC.Generics.Generic (Data.FingerTree.Strict.SearchResult v a)
instance GHC.Show.Show a => GHC.Show.Show (Data.FingerTree.Strict.SearchResult v a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.FingerTree.Strict.SearchResult v a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.FingerTree.Strict.SearchResult v a)
instance NoThunks.Class.NoThunks a => NoThunks.Class.NoThunks (Data.FingerTree.Strict.StrictFingerTree v a)
