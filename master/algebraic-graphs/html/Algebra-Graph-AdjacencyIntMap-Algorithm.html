<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Algebra.Graph.AdjacencyIntMap.Algorithm</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">algebraic-graphs-0.7: A library for algebraic graph construction and transformation</span><ul class="links" id="page-menu"><li><a href="src/Algebra.Graph.AdjacencyIntMap.Algorithm.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) Andrey Mokhov 2016-2022</td></tr><tr><th>License</th><td>MIT (see the file LICENSE)</td></tr><tr><th>Maintainer</th><td>andrey.mokhov@gmail.com</td></tr><tr><th>Stability</th><td>unstable</td></tr><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Algebra.Graph.AdjacencyIntMap.Algorithm</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Algorithms</a></li><li><a href="#g:2">Correctness properties</a></li><li><a href="#g:3">Type synonyms</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p><strong>Alga</strong> is a library for algebraic construction and manipulation of graphs
 in Haskell. See <a href="https://github.com/snowleopard/alga-paper">this paper</a> for the
 motivation behind the library, the underlying theory, and implementation details.</p><p>This module provides basic graph algorithms, such as <em>depth-first search</em>,
 implemented for the <a href="Algebra-Graph-AdjacencyIntMap.html">Algebra.Graph.AdjacencyIntMap</a> data type.</p><p>Some of the worst-case complexities include the term <em>min(n,W)</em>.
 Following <code><a href="../../containers/html/Data-IntSet.html#t:IntSet" title="Data.IntSet">IntSet</a></code> and <code><a href="../../containers/html/Data-IntMap-Strict-Internal.html#t:IntMap" title="Data.IntMap.Strict.Internal">IntMap</a></code>, the <em>W</em> stands for
 word size (usually 32 or 64 bits).</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:bfsForest">bfsForest</a> :: <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; [<a href="../../ghc/html/libraries/base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; <a href="../../containers/html/Data-Tree.html#t:Forest" title="Data.Tree">Forest</a> <a href="../../ghc/html/libraries/base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a></li><li class="src short"><a href="#v:bfs">bfs</a> :: <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; [<a href="../../ghc/html/libraries/base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; [[<a href="../../ghc/html/libraries/base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a>]]</li><li class="src short"><a href="#v:dfsForest">dfsForest</a> :: <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; <a href="../../containers/html/Data-Tree.html#t:Forest" title="Data.Tree">Forest</a> <a href="../../ghc/html/libraries/base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a></li><li class="src short"><a href="#v:dfsForestFrom">dfsForestFrom</a> :: <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; [<a href="../../ghc/html/libraries/base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; <a href="../../containers/html/Data-Tree.html#t:Forest" title="Data.Tree">Forest</a> <a href="../../ghc/html/libraries/base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a></li><li class="src short"><a href="#v:dfs">dfs</a> :: <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; [<a href="../../ghc/html/libraries/base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; [<a href="../../ghc/html/libraries/base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a>]</li><li class="src short"><a href="#v:reachable">reachable</a> :: <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; <a href="../../ghc/html/libraries/base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [<a href="../../ghc/html/libraries/base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a>]</li><li class="src short"><a href="#v:topSort">topSort</a> :: <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; <a href="../../ghc/html/libraries/base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a> (<a href="Algebra-Graph-AdjacencyIntMap-Algorithm.html#t:Cycle" title="Algebra.Graph.AdjacencyIntMap.Algorithm">Cycle</a> <a href="../../ghc/html/libraries/base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a>) [<a href="../../ghc/html/libraries/base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a>]</li><li class="src short"><a href="#v:isAcyclic">isAcyclic</a> :: <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; <a href="../../ghc/html/libraries/base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:isDfsForestOf">isDfsForestOf</a> :: <a href="../../containers/html/Data-Tree.html#t:Forest" title="Data.Tree">Forest</a> <a href="../../ghc/html/libraries/base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; <a href="../../ghc/html/libraries/base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:isTopSortOf">isTopSortOf</a> :: [<a href="../../ghc/html/libraries/base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; <a href="../../ghc/html/libraries/base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:Cycle">Cycle</a> = <a href="../../ghc/html/libraries/base-4.16.4.0/Data-List-NonEmpty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a></li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Algorithms</h1></a><div class="top"><p class="src"><a id="v:bfsForest" class="def">bfsForest</a> :: <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; [<a href="../../ghc/html/libraries/base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; <a href="../../containers/html/Data-Tree.html#t:Forest" title="Data.Tree">Forest</a> <a href="../../ghc/html/libraries/base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="src/Algebra.Graph.AdjacencyIntMap.Algorithm.html#bfsForest" class="link">Source</a> <a href="#v:bfsForest" class="selflink">#</a></p><div class="doc"><p>Compute the <em>breadth-first search</em> forest of a graph, such that adjacent
 vertices are explored in the increasing order. The search is seeded by a list
 of vertices that will become the roots of the resulting forest. Duplicates in
 the list will have their first occurrence explored and subsequent ones
 ignored. The seed vertices that do not belong to the graph are also ignored.</p><p>Complexity: <em>O((L + m) * log n)</em> time and <em>O(n)</em> space, where <em>L</em> is the
 number of seed vertices.</p><pre><code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> $ bfsForest (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2) [0]        == <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:empty" title="Algebra.Graph.AdjacencyIntMap">empty</a></code>
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> $ bfsForest (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2) [1]        == <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> $ bfsForest (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2) [2]        == <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertex" title="Algebra.Graph.AdjacencyIntMap">vertex</a></code> 2
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> $ bfsForest (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2) [0,1,2]    == <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertices" title="Algebra.Graph.AdjacencyIntMap">vertices</a></code> [1,2]
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> $ bfsForest (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2) [2,1,0]    == <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertices" title="Algebra.Graph.AdjacencyIntMap">vertices</a></code> [1,2]
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> $ bfsForest (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 1) [1]        == <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertex" title="Algebra.Graph.AdjacencyIntMap">vertex</a></code> 1
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:isSubgraphOf" title="Algebra.Graph.AdjacencyIntMap">isSubgraphOf</a></code> (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> $ bfsForest x vs) x == True
bfsForest x (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertexList" title="Algebra.Graph.AdjacencyIntMap">vertexList</a></code> x)               == <code><a href="../../ghc/html/libraries/base-4.16.4.0/GHC-List.html#v:map" title="GHC.List">map</a></code> (\v -&gt; Node v []) (<code><a href="../../ghc/html/libraries/base-4.16.4.0/Data-List.html#v:nub" title="Data.List">nub</a></code> $ <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertexList" title="Algebra.Graph.AdjacencyIntMap">vertexList</a></code> x)
bfsForest x []                           == []
bfsForest <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:empty" title="Algebra.Graph.AdjacencyIntMap">empty</a></code> vs                       == []
bfsForest (3 * (1 + 4) * (1 + 5)) [1,4]  == [ Node { rootLabel = 1
                                                   , subForest = [ Node { rootLabel = 5
                                                                        , subForest = [] }]}
                                            , Node { rootLabel = 4
                                                   , subForest = [] }]
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> $ bfsForest (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:circuit" title="Algebra.Graph.AdjacencyIntMap">circuit</a></code> [1..5] + <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:circuit" title="Algebra.Graph.AdjacencyIntMap">circuit</a></code> [5,4..1]) [3] == <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:path" title="Algebra.Graph.AdjacencyIntMap">path</a></code> [3,2,1] + <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:path" title="Algebra.Graph.AdjacencyIntMap">path</a></code> [3,4,5]

</pre></div></div><div class="top"><p class="src"><a id="v:bfs" class="def">bfs</a> :: <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; [<a href="../../ghc/html/libraries/base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; [[<a href="../../ghc/html/libraries/base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a>]] <a href="src/Algebra.Graph.AdjacencyIntMap.Algorithm.html#bfs" class="link">Source</a> <a href="#v:bfs" class="selflink">#</a></p><div class="doc"><p>A version of <code><a href="Algebra-Graph-AdjacencyIntMap-Algorithm.html#v:bfsForest" title="Algebra.Graph.AdjacencyIntMap.Algorithm">bfsForest</a></code> where the resulting forest is converted to a level
 structure. Adjacent vertices are explored in the increasing order. Flattening
 the result via <code><code><a href="../../ghc/html/libraries/base-4.16.4.0/Data-List.html#v:concat" title="Data.List">concat</a></code></code> <code>.</code> <code><code><a href="Algebra-Graph-AdjacencyIntMap-Algorithm.html#v:bfs" title="Algebra.Graph.AdjacencyIntMap.Algorithm">bfs</a></code></code> <code>x</code> gives an enumeration of reachable
 vertices in the breadth-first search order.</p><p>Complexity: <em>O((L + m) * min(n,W))</em> time and <em>O(n)</em> space, where <em>L</em> is the
 number of seed vertices.</p><pre>bfs (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2) [0]                == []
bfs (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2) [1]                == [[1], [2]]
bfs (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2) [2]                == [[2]]
bfs (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2) [1,2]              == [[1,2]]
bfs (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2) [2,1]              == [[2,1]]
bfs (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 1) [1]                == [[1]]
bfs <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:empty" title="Algebra.Graph.AdjacencyIntMap">empty</a></code> vs                      == []
bfs x []                          == []
bfs (1 * 2 + 3 * 4 + 5 * 6) [1,2] == [[1,2]]
bfs (1 * 2 + 3 * 4 + 5 * 6) [1,3] == [[1,3], [2,4]]
bfs (3 * (1 + 4) * (1 + 5)) [3]   == [[3], [1,4,5]]

bfs (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:circuit" title="Algebra.Graph.AdjacencyIntMap">circuit</a></code> [1..5] + <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:circuit" title="Algebra.Graph.AdjacencyIntMap">circuit</a></code> [5,4..1]) [3]          == [[2], [1,3], [5,4]]
<code><a href="../../ghc/html/libraries/base-4.16.4.0/Data-List.html#v:concat" title="Data.List">concat</a></code> $ bfs (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:circuit" title="Algebra.Graph.AdjacencyIntMap">circuit</a></code> [1..5] + <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:circuit" title="Algebra.Graph.AdjacencyIntMap">circuit</a></code> [5,4..1]) [3] == [3,2,4,1,5]
<code><a href="../../ghc/html/libraries/base-4.16.4.0/GHC-List.html#v:map" title="GHC.List">map</a></code> <code><a href="../../ghc/html/libraries/base-4.16.4.0/Data-List.html#v:concat" title="Data.List">concat</a></code> . <code><a href="../../ghc/html/libraries/base-4.16.4.0/Data-List.html#v:transpose" title="Data.List">transpose</a></code> . <code><a href="../../ghc/html/libraries/base-4.16.4.0/GHC-List.html#v:map" title="GHC.List">map</a></code> <code><a href="../../containers/html/Data-Tree.html#v:levels" title="Data.Tree">levels</a></code> . <code><a href="Algebra-Graph-AdjacencyIntMap-Algorithm.html#v:bfsForest" title="Algebra.Graph.AdjacencyIntMap.Algorithm">bfsForest</a></code> x    == bfs x
</pre></div></div><div class="top"><p class="src"><a id="v:dfsForest" class="def">dfsForest</a> :: <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; <a href="../../containers/html/Data-Tree.html#t:Forest" title="Data.Tree">Forest</a> <a href="../../ghc/html/libraries/base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="src/Algebra.Graph.AdjacencyIntMap.Algorithm.html#dfsForest" class="link">Source</a> <a href="#v:dfsForest" class="selflink">#</a></p><div class="doc"><p>Compute the <em>depth-first search</em> forest of a graph, where adjacent vertices
 are explored in the increasing order.</p><p>Complexity: <em>O((n + m) * min(n,W))</em> time and <em>O(n)</em> space.</p><pre><code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> $ dfsForest <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:empty" title="Algebra.Graph.AdjacencyIntMap">empty</a></code>              == <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:empty" title="Algebra.Graph.AdjacencyIntMap">empty</a></code>
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> $ dfsForest (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 1)         == <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertex" title="Algebra.Graph.AdjacencyIntMap">vertex</a></code> 1
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> $ dfsForest (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2)         == <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> $ dfsForest (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 2 1)         == <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertices" title="Algebra.Graph.AdjacencyIntMap">vertices</a></code> [1,2]
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:isSubgraphOf" title="Algebra.Graph.AdjacencyIntMap">isSubgraphOf</a></code> (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> $ dfsForest x) x == True
<code><a href="Algebra-Graph-AdjacencyIntMap-Algorithm.html#v:isDfsForestOf" title="Algebra.Graph.AdjacencyIntMap.Algorithm">isDfsForestOf</a></code> (dfsForest x) x         == True
dfsForest . <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> . dfsForest        == dfsForest
dfsForest (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertices" title="Algebra.Graph.AdjacencyIntMap">vertices</a></code> vs)               == <code><a href="../../ghc/html/libraries/base-4.16.4.0/GHC-List.html#v:map" title="GHC.List">map</a></code> (\v -&gt; Node v []) (<code><a href="../../ghc/html/libraries/base-4.16.4.0/Data-List.html#v:nub" title="Data.List">nub</a></code> $ <code><a href="../../ghc/html/libraries/base-4.16.4.0/Data-List.html#v:sort" title="Data.List">sort</a></code> vs)
dfsForest $ 3 * (1 + 4) * (1 + 5)     == [ Node { rootLabel = 1
                                                , subForest = [ Node { rootLabel = 5
                                                                     , subForest = [] }]}
                                         , Node { rootLabel = 3
                                                , subForest = [ Node { rootLabel = 4
                                                                     , subForest = [] }]}]
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> (dfsForest $ <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:circuit" title="Algebra.Graph.AdjacencyIntMap">circuit</a></code> [1..5] + <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:circuit" title="Algebra.Graph.AdjacencyIntMap">circuit</a></code> [5,4..1]) == <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:path" title="Algebra.Graph.AdjacencyIntMap">path</a></code> [1,2,3,4,5]
</pre></div></div><div class="top"><p class="src"><a id="v:dfsForestFrom" class="def">dfsForestFrom</a> :: <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; [<a href="../../ghc/html/libraries/base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; <a href="../../containers/html/Data-Tree.html#t:Forest" title="Data.Tree">Forest</a> <a href="../../ghc/html/libraries/base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="src/Algebra.Graph.AdjacencyIntMap.Algorithm.html#dfsForestFrom" class="link">Source</a> <a href="#v:dfsForestFrom" class="selflink">#</a></p><div class="doc"><p>Compute the <em>depth-first search</em> forest of a graph starting from the given
 seed vertices, where adjacent vertices are explored in the increasing order.
 Note that the resulting forest does not necessarily span the whole graph, as
 some vertices may be unreachable. The seed vertices which do not belong to
 the graph are ignored.</p><p>Complexity: <em>O((L + m) * log n)</em> time and <em>O(n)</em> space, where <em>L</em> is the
 number of seed vertices.</p><pre><code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> $ dfsForestFrom <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:empty" title="Algebra.Graph.AdjacencyIntMap">empty</a></code>      vs             == <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:empty" title="Algebra.Graph.AdjacencyIntMap">empty</a></code>
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> $ dfsForestFrom (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 1) [1]            == <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertex" title="Algebra.Graph.AdjacencyIntMap">vertex</a></code> 1
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> $ dfsForestFrom (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2) [0]            == <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:empty" title="Algebra.Graph.AdjacencyIntMap">empty</a></code>
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> $ dfsForestFrom (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2) [1]            == <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> $ dfsForestFrom (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2) [2]            == <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertex" title="Algebra.Graph.AdjacencyIntMap">vertex</a></code> 2
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> $ dfsForestFrom (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2) [1,2]          == <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> $ dfsForestFrom (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2) [2,1]          == <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertices" title="Algebra.Graph.AdjacencyIntMap">vertices</a></code> [1,2]
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:isSubgraphOf" title="Algebra.Graph.AdjacencyIntMap">isSubgraphOf</a></code> (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> $ dfsForestFrom x vs) x     == True
<code><a href="Algebra-Graph-AdjacencyIntMap-Algorithm.html#v:isDfsForestOf" title="Algebra.Graph.AdjacencyIntMap.Algorithm">isDfsForestOf</a></code> (dfsForestFrom x (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertexList" title="Algebra.Graph.AdjacencyIntMap">vertexList</a></code> x)) x == True
dfsForestFrom x (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertexList" title="Algebra.Graph.AdjacencyIntMap">vertexList</a></code> x)                   == <code><a href="Algebra-Graph-AdjacencyIntMap-Algorithm.html#v:dfsForest" title="Algebra.Graph.AdjacencyIntMap.Algorithm">dfsForest</a></code> x
dfsForestFrom x []                               == []
dfsForestFrom (3 * (1 + 4) * (1 + 5)) [1,4]      == [ Node { rootLabel = 1
                                                           , subForest = [ Node { rootLabel = 5
                                                                                , subForest = [] }
                                                    , Node { rootLabel = 4
                                                           , subForest = [] }]
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> $ dfsForestFrom (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:circuit" title="Algebra.Graph.AdjacencyIntMap">circuit</a></code> [1..5] + <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:circuit" title="Algebra.Graph.AdjacencyIntMap">circuit</a></code> [5,4..1]) [3] == <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:path" title="Algebra.Graph.AdjacencyIntMap">path</a></code> [3,2,1,5,4]
</pre></div></div><div class="top"><p class="src"><a id="v:dfs" class="def">dfs</a> :: <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; [<a href="../../ghc/html/libraries/base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; [<a href="../../ghc/html/libraries/base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] <a href="src/Algebra.Graph.AdjacencyIntMap.Algorithm.html#dfs" class="link">Source</a> <a href="#v:dfs" class="selflink">#</a></p><div class="doc"><p>Return the list vertices visited by the <em>depth-first search</em> in a graph,
 starting from the given seed vertices. Adjacent vertices are explored in the
 increasing order.</p><p>Complexity: <em>O((L + m) * log n)</em> time and <em>O(n)</em> space, where <em>L</em> is the
 number of seed vertices.</p><pre>dfs <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:empty" title="Algebra.Graph.AdjacencyIntMap">empty</a></code>      vs    == []
dfs (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 1) [1]   == [1]
dfs (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2) [0]   == []
dfs (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2) [1]   == [1,2]
dfs (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2) [2]   == [2]
dfs (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2) [1,2] == [1,2]
dfs (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2) [2,1] == [2,1]
dfs x          []    == []

<code><a href="../../ghc/html/libraries/base-4.16.4.0/Data-List.html#v:and" title="Data.List">and</a></code> [ <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:hasVertex" title="Algebra.Graph.AdjacencyIntMap">hasVertex</a></code> v x | v &lt;- dfs x vs ]       == True
dfs (3 * (1 + 4) * (1 + 5)) [1,4]           == [1,5,4]
dfs (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:circuit" title="Algebra.Graph.AdjacencyIntMap">circuit</a></code> [1..5] + <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:circuit" title="Algebra.Graph.AdjacencyIntMap">circuit</a></code> [5,4..1]) [3] == [3,2,1,5,4]
</pre></div></div><div class="top"><p class="src"><a id="v:reachable" class="def">reachable</a> :: <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; <a href="../../ghc/html/libraries/base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [<a href="../../ghc/html/libraries/base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] <a href="src/Algebra.Graph.AdjacencyIntMap.Algorithm.html#reachable" class="link">Source</a> <a href="#v:reachable" class="selflink">#</a></p><div class="doc"><p>Return the list of vertices <em>reachable</em> from a source vertex in a graph.
 The vertices in the resulting list appear in the <em>depth-first search order</em>.</p><p>Complexity: <em>O(m * log n)</em> time and <em>O(n)</em> space.</p><pre>reachable <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:empty" title="Algebra.Graph.AdjacencyIntMap">empty</a></code>              x == []
reachable (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertex" title="Algebra.Graph.AdjacencyIntMap">vertex</a></code> 1)         1 == [1]
reachable (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 1)         1 == [1]
reachable (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2)         0 == []
reachable (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2)         1 == [1,2]
reachable (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2)         2 == [2]
reachable (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:path" title="Algebra.Graph.AdjacencyIntMap">path</a></code>    [1..8]  ) 4 == [4..8]
reachable (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:circuit" title="Algebra.Graph.AdjacencyIntMap">circuit</a></code> [1..8]  ) 4 == [4..8] ++ [1..3]
reachable (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:clique" title="Algebra.Graph.AdjacencyIntMap">clique</a></code>  [8,7..1]) 8 == [8] ++ [1..7]

<code><a href="../../ghc/html/libraries/base-4.16.4.0/Data-List.html#v:and" title="Data.List">and</a></code> [ <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:hasVertex" title="Algebra.Graph.AdjacencyIntMap">hasVertex</a></code> v x | v &lt;- reachable x y ] == True
</pre></div></div><div class="top"><p class="src"><a id="v:topSort" class="def">topSort</a> :: <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; <a href="../../ghc/html/libraries/base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a> (<a href="Algebra-Graph-AdjacencyIntMap-Algorithm.html#t:Cycle" title="Algebra.Graph.AdjacencyIntMap.Algorithm">Cycle</a> <a href="../../ghc/html/libraries/base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a>) [<a href="../../ghc/html/libraries/base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] <a href="src/Algebra.Graph.AdjacencyIntMap.Algorithm.html#topSort" class="link">Source</a> <a href="#v:topSort" class="selflink">#</a></p><div class="doc"><p>Compute a topological sort of a graph or discover a cycle.</p><p>Vertices are explored in the decreasing order according to their <code><a href="../../ghc/html/libraries/base-4.16.4.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a></code>
 instance. This gives the lexicographically smallest topological ordering in
 the case of success. In the case of failure, the cycle is characterized by
 being the lexicographically smallest up to rotation with respect to
 <code>Ord</code> <code>(Dual</code> <code>Int)</code> in the first connected component of the graph containing
 a cycle, where the connected components are ordered by their largest vertex
 with respect to <code>Ord a</code>.</p><p>Complexity: <em>O((n + m) * min(n,W))</em> time and <em>O(n)</em> space.</p><pre>topSort (1 * 2 + 3 * 1)                    == Right [3,1,2]
topSort (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:path" title="Algebra.Graph.AdjacencyIntMap">path</a></code> [1..5])                      == Right [1..5]
topSort (3 * (1 * 4 + 2 * 5))              == Right [3,1,2,4,5]
topSort (1 * 2 + 2 * 1)                    == Left (2 <code><a href="../../ghc/html/libraries/base-4.16.4.0/Data-List-NonEmpty.html#v::-124-" title="Data.List.NonEmpty">:|</a></code> [1])
topSort (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:path" title="Algebra.Graph.AdjacencyIntMap">path</a></code> [5,4..1] + <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 2 4)         == Left (4 <code><a href="../../ghc/html/libraries/base-4.16.4.0/Data-List-NonEmpty.html#v::-124-" title="Data.List.NonEmpty">:|</a></code> [3,2])
topSort (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:circuit" title="Algebra.Graph.AdjacencyIntMap">circuit</a></code> [1..3])                   == Left (3 <code><a href="../../ghc/html/libraries/base-4.16.4.0/Data-List-NonEmpty.html#v::-124-" title="Data.List.NonEmpty">:|</a></code> [1,2])
topSort (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:circuit" title="Algebra.Graph.AdjacencyIntMap">circuit</a></code> [1..3] + <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:circuit" title="Algebra.Graph.AdjacencyIntMap">circuit</a></code> [3,2,1]) == Left (3 <code><a href="../../ghc/html/libraries/base-4.16.4.0/Data-List-NonEmpty.html#v::-124-" title="Data.List.NonEmpty">:|</a></code> [2])
topSort (1 * 2 + (5 + 2) * 1 + 3 * 4 * 3)  == Left (1 <code><a href="../../ghc/html/libraries/base-4.16.4.0/Data-List-NonEmpty.html#v::-124-" title="Data.List.NonEmpty">:|</a></code> [2])
fmap (<code><a href="../../ghc/html/libraries/base-4.16.4.0/Data-Function.html#v:flip" title="Data.Function">flip</a></code> <code><a href="Algebra-Graph-AdjacencyIntMap-Algorithm.html#v:isTopSortOf" title="Algebra.Graph.AdjacencyIntMap.Algorithm">isTopSortOf</a></code> x) (topSort x)      /= Right False
topSort . <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertices" title="Algebra.Graph.AdjacencyIntMap">vertices</a></code>                         == Right . <code>nub</code> . <code>sort</code>
</pre></div></div><div class="top"><p class="src"><a id="v:isAcyclic" class="def">isAcyclic</a> :: <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; <a href="../../ghc/html/libraries/base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Algebra.Graph.AdjacencyIntMap.Algorithm.html#isAcyclic" class="link">Source</a> <a href="#v:isAcyclic" class="selflink">#</a></p><div class="doc"><p>Check if a given graph is <em>acyclic</em>.</p><p>Complexity: <em>O((n + m) * min(n,W))</em> time and <em>O(n)</em> space.</p><pre>isAcyclic (1 * 2 + 3 * 1) == True
isAcyclic (1 * 2 + 2 * 1) == False
isAcyclic . <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:circuit" title="Algebra.Graph.AdjacencyIntMap">circuit</a></code>       == <code><a href="../../ghc/html/libraries/base-4.16.4.0/Data-List.html#v:null" title="Data.List">null</a></code>
isAcyclic                 == <code><a href="../../ghc/html/libraries/base-4.16.4.0/Data-Either.html#v:isRight" title="Data.Either">isRight</a></code> . <code><a href="Algebra-Graph-AdjacencyIntMap-Algorithm.html#v:topSort" title="Algebra.Graph.AdjacencyIntMap.Algorithm">topSort</a></code>
</pre></div></div><a href="#g:2" id="g:2"><h1>Correctness properties</h1></a><div class="top"><p class="src"><a id="v:isDfsForestOf" class="def">isDfsForestOf</a> :: <a href="../../containers/html/Data-Tree.html#t:Forest" title="Data.Tree">Forest</a> <a href="../../ghc/html/libraries/base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; <a href="../../ghc/html/libraries/base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Algebra.Graph.AdjacencyIntMap.Algorithm.html#isDfsForestOf" class="link">Source</a> <a href="#v:isDfsForestOf" class="selflink">#</a></p><div class="doc"><p>Check if a given forest is a correct <em>depth-first search</em> forest of a graph.
 The implementation is based on the paper &quot;Depth-First Search and Strong
 Connectivity in Coq&quot; by Fran&#231;ois Pottier.</p><pre>isDfsForestOf []                              <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:empty" title="Algebra.Graph.AdjacencyIntMap">empty</a></code>            == True
isDfsForestOf []                              (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertex" title="Algebra.Graph.AdjacencyIntMap">vertex</a></code> 1)       == False
isDfsForestOf [Node 1 []]                     (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertex" title="Algebra.Graph.AdjacencyIntMap">vertex</a></code> 1)       == True
isDfsForestOf [Node 1 []]                     (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertex" title="Algebra.Graph.AdjacencyIntMap">vertex</a></code> 2)       == False
isDfsForestOf [Node 1 [], Node 1 []]          (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertex" title="Algebra.Graph.AdjacencyIntMap">vertex</a></code> 1)       == False
isDfsForestOf [Node 1 []]                     (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 1)       == True
isDfsForestOf [Node 1 []]                     (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2)       == False
isDfsForestOf [Node 1 [], Node 2 []]          (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2)       == False
isDfsForestOf [Node 2 [], Node 1 []]          (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2)       == True
isDfsForestOf [Node 1 [Node 2 []]]            (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2)       == True
isDfsForestOf [Node 1 [], Node 2 []]          (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertices" title="Algebra.Graph.AdjacencyIntMap">vertices</a></code> [1,2]) == True
isDfsForestOf [Node 2 [], Node 1 []]          (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertices" title="Algebra.Graph.AdjacencyIntMap">vertices</a></code> [1,2]) == True
isDfsForestOf [Node 1 [Node 2 []]]            (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertices" title="Algebra.Graph.AdjacencyIntMap">vertices</a></code> [1,2]) == False
isDfsForestOf [Node 1 [Node 2 [Node 3 []]]]   (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:path" title="Algebra.Graph.AdjacencyIntMap">path</a></code> [1,2,3])   == True
isDfsForestOf [Node 1 [Node 3 [Node 2 []]]]   (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:path" title="Algebra.Graph.AdjacencyIntMap">path</a></code> [1,2,3])   == False
isDfsForestOf [Node 3 [], Node 1 [Node 2 []]] (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:path" title="Algebra.Graph.AdjacencyIntMap">path</a></code> [1,2,3])   == True
isDfsForestOf [Node 2 [Node 3 []], Node 1 []] (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:path" title="Algebra.Graph.AdjacencyIntMap">path</a></code> [1,2,3])   == True
isDfsForestOf [Node 1 [], Node 2 [Node 3 []]] (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:path" title="Algebra.Graph.AdjacencyIntMap">path</a></code> [1,2,3])   == False
</pre></div></div><div class="top"><p class="src"><a id="v:isTopSortOf" class="def">isTopSortOf</a> :: [<a href="../../ghc/html/libraries/base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; <a href="../../ghc/html/libraries/base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Algebra.Graph.AdjacencyIntMap.Algorithm.html#isTopSortOf" class="link">Source</a> <a href="#v:isTopSortOf" class="selflink">#</a></p><div class="doc"><p>Check if a given list of vertices is a correct <em>topological sort</em> of a graph.</p><pre>isTopSortOf [3,1,2] (1 * 2 + 3 * 1) == True
isTopSortOf [1,2,3] (1 * 2 + 3 * 1) == False
isTopSortOf []      (1 * 2 + 3 * 1) == False
isTopSortOf []      <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:empty" title="Algebra.Graph.AdjacencyIntMap">empty</a></code>           == True
isTopSortOf [x]     (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertex" title="Algebra.Graph.AdjacencyIntMap">vertex</a></code> x)      == True
isTopSortOf [x]     (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> x x)      == False
</pre></div></div><a href="#g:3" id="g:3"><h1>Type synonyms</h1></a><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Cycle" class="def">Cycle</a> = <a href="../../ghc/html/libraries/base-4.16.4.0/Data-List-NonEmpty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a> <a href="src/Algebra.Graph.AdjacencyIntMap.Algorithm.html#Cycle" class="link">Source</a> <a href="#t:Cycle" class="selflink">#</a></p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.26.0</p></div></body></html>