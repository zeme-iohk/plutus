

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6.4.11. Kind polymorphism &mdash; Glasgow Haskell Compiler 9.2.5 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.5 User&#39;s Guide"
          href="../_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6.4.12. Levity polymorphism" href="levity_polymorphism.html" />
    <link rel="prev" title="6.4.10. Datatype promotion" href="data_kinds.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="../runghc.html">4. Using runghc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">5. Using GHC</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../exts.html">6. Language extensions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">6.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="syntax.html">6.2. Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="import_export.html">6.3. Import and export</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="types.html">6.4. Types</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="nullary_types.html">6.4.1. Data types with no constructors</a></li>
<li class="toctree-l3"><a class="reference internal" href="datatype_contexts.html">6.4.2. Data type contexts</a></li>
<li class="toctree-l3"><a class="reference internal" href="infix_tycons.html">6.4.3. Infix type constructors, classes, and type variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="type_operators.html">6.4.4. Type operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="liberal_type_synonyms.html">6.4.5. Liberalised type synonyms</a></li>
<li class="toctree-l3"><a class="reference internal" href="existential_quantification.html">6.4.6. Existentially quantified data constructors</a></li>
<li class="toctree-l3"><a class="reference internal" href="gadt_syntax.html">6.4.7. Declaring data types with explicit constructor signatures</a></li>
<li class="toctree-l3"><a class="reference internal" href="gadt.html">6.4.8. Generalised Algebraic Data Types (GADTs)</a></li>
<li class="toctree-l3"><a class="reference internal" href="type_families.html">6.4.9. Type families</a></li>
<li class="toctree-l3"><a class="reference internal" href="data_kinds.html">6.4.10. Datatype promotion</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">6.4.11. Kind polymorphism</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview-of-kind-polymorphism">6.4.11.1. Overview of kind polymorphism</a></li>
<li class="toctree-l4"><a class="reference internal" href="#overview-of-type-in-type">6.4.11.2. Overview of Type-in-Type</a></li>
<li class="toctree-l4"><a class="reference internal" href="#principles-of-kind-inference">6.4.11.3. Principles of kind inference</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kind-inference-in-type-signatures">6.4.11.4. Kind inference in type signatures</a></li>
<li class="toctree-l4"><a class="reference internal" href="#explicit-kind-quantification">6.4.11.5. Explicit kind quantification</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inferring-the-order-of-variables-in-a-type-class-declaration">6.4.11.6. Inferring the order of variables in a type/class declaration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#complete-user-supplied-kind-signatures-and-polymorphic-recursion">6.4.11.7. Complete user-supplied kind signatures and polymorphic recursion</a></li>
<li class="toctree-l4"><a class="reference internal" href="#standalone-kind-signatures-and-polymorphic-recursion">6.4.11.8. Standalone kind signatures and polymorphic recursion</a></li>
<li class="toctree-l4"><a class="reference internal" href="#standalone-kind-signatures-and-declaration-headers">6.4.11.9. Standalone kind signatures and declaration headers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kind-inference-in-data-type-declarations">6.4.11.10. Kind inference in data type declarations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kind-inference-for-data-newtype-instance-declarations">6.4.11.11. Kind inference for data/newtype instance declarations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kind-inference-in-class-instance-declarations">6.4.11.12. Kind inference in class instance declarations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kind-inference-in-type-synonyms-and-type-family-instances">6.4.11.13. Kind inference in type synonyms and type family instances</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kind-inference-in-closed-type-families">6.4.11.14. Kind inference in closed type families</a></li>
<li class="toctree-l4"><a class="reference internal" href="#higher-rank-kinds">6.4.11.15. Higher-rank kinds</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-kind-type">6.4.11.16. The kind <code class="docutils literal notranslate"><span class="pre">Type</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#inferring-dependency-in-datatype-declarations">6.4.11.17. Inferring dependency in datatype declarations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inferring-dependency-in-user-written-foralls">6.4.11.18. Inferring dependency in user-written <code class="docutils literal notranslate"><span class="pre">forall</span></code>s</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kind-defaulting-without-polykinds">6.4.11.19. Kind defaulting without <code class="xref std std-extension docutils literal notranslate"><span class="pre">PolyKinds</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pretty-printing-in-the-presence-of-kind-polymorphism">6.4.11.20. Pretty-printing in the presence of kind polymorphism</a></li>
<li class="toctree-l4"><a class="reference internal" href="#datatype-return-kinds">6.4.11.21. Datatype return kinds</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="levity_polymorphism.html">6.4.12. Levity polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="type_literals.html">6.4.13. Type-Level Literals</a></li>
<li class="toctree-l3"><a class="reference internal" href="type_applications.html">6.4.14. Visible type application</a></li>
<li class="toctree-l3"><a class="reference internal" href="rank_polymorphism.html">6.4.15. Arbitrary-rank polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="impredicative_types.html">6.4.16. Impredicative polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="linear_types.html">6.4.17. Linear types</a></li>
<li class="toctree-l3"><a class="reference internal" href="type_errors.html">6.4.18. Custom compile-time errors</a></li>
<li class="toctree-l3"><a class="reference internal" href="defer_type_errors.html">6.4.19. Deferring type errors to runtime</a></li>
<li class="toctree-l3"><a class="reference internal" href="roles.html">6.4.20. Roles</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="records.html">6.5. Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="deriving.html">6.6. Deriving mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="patterns.html">6.7. Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="typeclasses.html">6.8. Class and instances declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="literals.html">6.9. Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="constraints.html">6.10. Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="type_signatures.html">6.11. Type signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="bindings.html">6.12. Bindings and generalisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="template_haskell.html">6.13. Template Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="strict.html">6.14. Bang patterns and Strict Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel.html">6.15. Parallel and Concurrent</a></li>
<li class="toctree-l2"><a class="reference internal" href="primitives.html">6.16. Unboxed types and primitive operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffi.html">6.17. Foreign function interface (FFI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="safe_haskell.html">6.18. Safe Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc.html">6.19. Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="pragmas.html">6.20. Pragmas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../exts.html"><span class="section-number">6. </span>Language extensions</a> &raquo;</li>
        
          <li><a href="types.html"><span class="section-number">6.4. </span>Types</a> &raquo;</li>
        
      <li><span class="section-number">6.4.11. </span>Kind polymorphism</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/exts/poly_kinds.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="kind-polymorphism">
<span id="type-in-type"></span><span id="id1"></span><h1><span class="section-number">6.4.11. </span>Kind polymorphism<a class="headerlink" href="#kind-polymorphism" title="Permalink to this heading">¶</a></h1>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-TypeInType">
<span id="ghc-flag--XTypeInType"></span><span id="extension-NoTypeInType"></span><span class="sig-name descname"><span class="pre">TypeInType</span></span><a class="headerlink" href="#extension-TypeInType" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Implies<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#extension-PolyKinds"><code class="xref std std-extension docutils literal notranslate"><span class="pre">PolyKinds</span></code></a>, <a class="reference internal" href="data_kinds.html#extension-DataKinds"><code class="xref std std-extension docutils literal notranslate"><span class="pre">DataKinds</span></code></a>, <a class="reference internal" href="kind_signatures.html#extension-KindSignatures"><code class="xref std std-extension docutils literal notranslate"><span class="pre">KindSignatures</span></code></a></p>
</dd>
<dt class="field-even">Since<span class="colon">:</span></dt>
<dd class="field-even"><p>8.0.1</p>
</dd>
</dl>
<p>The extension <a class="reference internal" href="#extension-TypeInType"><code class="xref std std-extension docutils literal notranslate"><span class="pre">TypeInType</span></code></a> is now deprecated: its sole effect is
to switch on <a class="reference internal" href="#extension-PolyKinds"><code class="xref std std-extension docutils literal notranslate"><span class="pre">PolyKinds</span></code></a>
(and hence <a class="reference internal" href="kind_signatures.html#extension-KindSignatures"><code class="xref std std-extension docutils literal notranslate"><span class="pre">KindSignatures</span></code></a>) and <a class="reference internal" href="data_kinds.html#extension-DataKinds"><code class="xref std std-extension docutils literal notranslate"><span class="pre">DataKinds</span></code></a>.</p>
</dd></dl>

<dl class="std extension">
<dt class="sig sig-object std" id="extension-PolyKinds">
<span id="ghc-flag--XPolyKinds"></span><span id="extension-NoPolyKinds"></span><span class="sig-name descname"><span class="pre">PolyKinds</span></span><a class="headerlink" href="#extension-PolyKinds" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Implies<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="kind_signatures.html#extension-KindSignatures"><code class="xref std std-extension docutils literal notranslate"><span class="pre">KindSignatures</span></code></a></p>
</dd>
<dt class="field-even">Since<span class="colon">:</span></dt>
<dd class="field-even"><p>7.4.1</p>
</dd>
</dl>
<p>Allow kind polymorphic types.</p>
</dd></dl>

<p>This section describes GHC’s kind system, as it appears in version 8.0 and beyond.
The kind system as described here is always in effect, with or without extensions,
although it is a conservative extension beyond standard Haskell. The extensions
above simply enable syntax and tweak the inference algorithm to allow users to
take advantage of the extra expressiveness of GHC’s kind system.</p>
<section id="overview-of-kind-polymorphism">
<h2><span class="section-number">6.4.11.1. </span>Overview of kind polymorphism<a class="headerlink" href="#overview-of-kind-polymorphism" title="Permalink to this heading">¶</a></h2>
<p>Consider inferring the kind for</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">App</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkApp</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>In Haskell 98, the inferred kind for <code class="docutils literal notranslate"><span class="pre">App</span></code> is <code class="docutils literal notranslate"><span class="pre">(Type</span> <span class="pre">-&gt;</span> <span class="pre">Type)</span> <span class="pre">-&gt;</span> <span class="pre">Type</span> <span class="pre">-&gt;</span>
<span class="pre">Type</span></code>. But this is overly specific, because another suitable Haskell 98 kind
for <code class="docutils literal notranslate"><span class="pre">App</span></code> is <code class="docutils literal notranslate"><span class="pre">((Type</span> <span class="pre">-&gt;</span> <span class="pre">Type)</span> <span class="pre">-&gt;</span> <span class="pre">Type)</span> <span class="pre">-&gt;</span> <span class="pre">(Type</span> <span class="pre">-&gt;</span> <span class="pre">Type)</span> <span class="pre">-&gt;</span> <span class="pre">Type</span></code>, where the
kind assigned to <code class="docutils literal notranslate"><span class="pre">a</span></code> is <code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">-&gt;</span> <span class="pre">Type</span></code>. Indeed, without kind signatures
(<a class="reference internal" href="kind_signatures.html#extension-KindSignatures"><code class="xref std std-extension docutils literal notranslate"><span class="pre">KindSignatures</span></code></a>), it is necessary to use a dummy constructor to get
a Haskell compiler to infer the second kind. With kind polymorphism
(<a class="reference internal" href="#extension-PolyKinds"><code class="xref std std-extension docutils literal notranslate"><span class="pre">PolyKinds</span></code></a>), GHC infers the kind <code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">k.</span> <span class="pre">(k</span> <span class="pre">-&gt;</span> <span class="pre">Type)</span> <span class="pre">-&gt;</span> <span class="pre">k</span> <span class="pre">-&gt;</span>
<span class="pre">Type</span></code> for <code class="docutils literal notranslate"><span class="pre">App</span></code>, which is its most general kind.</p>
<p>Thus, the chief benefit of kind polymorphism is that we can now infer these
most general kinds and use <code class="docutils literal notranslate"><span class="pre">App</span></code> at a variety of kinds:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">App</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="kt">Int</span><span class="w">   </span><span class="c1">-- `k` is instantiated to Type</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkT</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="w">    </span><span class="c1">-- `a` is inferred to have kind (Type -&gt; Type)</span><span class="w"></span>
<span class="kt">App</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="kt">Maybe</span><span class="w">     </span><span class="c1">-- `k` is instantiated to (Type -&gt; Type)</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="overview-of-type-in-type">
<h2><span class="section-number">6.4.11.2. </span>Overview of Type-in-Type<a class="headerlink" href="#overview-of-type-in-type" title="Permalink to this heading">¶</a></h2>
<p>GHC 8 extends the idea of kind polymorphism by declaring that types and kinds
are indeed one and the same. Nothing within GHC distinguishes between types
and kinds. Another way of thinking about this is that the type <code class="docutils literal notranslate"><span class="pre">Bool</span></code> and
the “promoted kind” <code class="docutils literal notranslate"><span class="pre">Bool</span></code> are actually identical. (Note that term
<code class="docutils literal notranslate"><span class="pre">True</span></code> and the type <code class="docutils literal notranslate"><span class="pre">'True</span></code> are still distinct, because the former can
be used in expressions and the latter in types.) This lack of distinction
between types and kinds is a hallmark of dependently typed languages.
Full dependently typed languages also remove the difference between expressions
and types, but doing that in GHC is a story for another day.</p>
<p>One simplification allowed by combining types and kinds is that the type of
<code class="docutils literal notranslate"><span class="pre">Type</span></code> is just <code class="docutils literal notranslate"><span class="pre">Type</span></code>. It is true that the <code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">::</span> <span class="pre">Type</span></code> axiom can lead
to non-termination, but this is not a problem in GHC, as we already have other
means of non-terminating programs in both types and expressions. This decision
(among many, many others) <em>does</em> mean that despite the expressiveness of GHC’s
type system, a “proof” you write in Haskell is not an irrefutable mathematical
proof. GHC promises only partial correctness, that if your programs compile and
run to completion, their results indeed have the types assigned. It makes no
claim about programs that do not finish in a finite amount of time.</p>
<p>To learn more about this decision and the design of GHC under the hood
please see the <a class="reference external" href="http://www.seas.upenn.edu/~sweirich/papers/fckinds.pdf">paper</a>
introducing this kind system to GHC/Haskell.</p>
</section>
<section id="principles-of-kind-inference">
<h2><span class="section-number">6.4.11.3. </span>Principles of kind inference<a class="headerlink" href="#principles-of-kind-inference" title="Permalink to this heading">¶</a></h2>
<p>Generally speaking, when <a class="reference internal" href="#extension-PolyKinds"><code class="xref std std-extension docutils literal notranslate"><span class="pre">PolyKinds</span></code></a> is on, GHC tries to infer the
most general kind for a declaration.
In many cases (for example, in a datatype declaration)
the definition has a right-hand side to inform kind
inference. But that is not always the case. Consider</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>Type family declarations have no right-hand side, but GHC must still
infer a kind for <code class="docutils literal notranslate"><span class="pre">F</span></code>. Since there are no constraints, it could infer
<code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">::</span> <span class="pre">forall</span> <span class="pre">k1</span> <span class="pre">k2.</span> <span class="pre">k1</span> <span class="pre">-&gt;</span> <span class="pre">k2</span></code>, but that seems <em>too</em> polymorphic. So
GHC defaults those entirely-unconstrained kind variables to <code class="docutils literal notranslate"><span class="pre">Type</span></code> and we
get <code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">::</span> <span class="pre">Type</span> <span class="pre">-&gt;</span> <span class="pre">Type</span></code>. You can still declare <code class="docutils literal notranslate"><span class="pre">F</span></code> to be kind-polymorphic
using kind signatures:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">F1</span><span class="w"> </span><span class="n">a</span><span class="w">                </span><span class="c1">-- F1 :: Type -&gt; Type</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">F2</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w">         </span><span class="c1">-- F2 :: forall k. k -&gt; Type</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">F3</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="w">           </span><span class="c1">-- F3 :: forall k. Type -&gt; k</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">F4</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k1</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k2</span><span class="w">  </span><span class="c1">-- F4 :: forall k1 k2. k1 -&gt; k2</span><span class="w"></span>
</pre></div>
</div>
<p>The general principle is this:</p>
<ul class="simple">
<li><p>When there is a right-hand side, GHC infers the most polymorphic
kind consistent with the right-hand side. Examples: ordinary data
type and GADT declarations, class declarations. In the case of a
class declaration the role of “right hand side” is played by the
class method signatures.</p></li>
<li><p>When there is no right hand side, GHC defaults argument and result
kinds to <code class="docutils literal notranslate"><span class="pre">Type</span></code>, except when directed otherwise by a kind signature.
Examples: data and open type family declarations.</p></li>
</ul>
<p>This rule has occasionally-surprising consequences (see
<a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/10132">#10132</a>).</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w">    </span><span class="c1">-- Class declarations are generalised</span><span class="w"></span>
<span class="w">                   </span><span class="c1">-- so C :: forall k. k -&gt; Constraint</span><span class="w"></span>
<span class="w">  </span><span class="kr">data</span><span class="w"> </span><span class="kt">D1</span><span class="w"> </span><span class="n">a</span><span class="w">        </span><span class="c1">-- No right hand side for these two family</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">F1</span><span class="w"> </span><span class="n">a</span><span class="w">        </span><span class="c1">-- declarations, but the class forces (a :: k)</span><span class="w"></span>
<span class="w">                   </span><span class="c1">-- so   D1, F1 :: forall k. k -&gt; Type</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">D2</span><span class="w"> </span><span class="n">a</span><span class="w">   </span><span class="c1">-- No right-hand side so D2 :: Type -&gt; Type</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kt">F2</span><span class="w"> </span><span class="n">a</span><span class="w">   </span><span class="c1">-- No right-hand side so F2 :: Type -&gt; Type</span><span class="w"></span>
</pre></div>
</div>
<p>The kind-polymorphism from the class declaration makes <code class="docutils literal notranslate"><span class="pre">D1</span></code>
kind-polymorphic, but not so <code class="docutils literal notranslate"><span class="pre">D2</span></code>; and similarly <code class="docutils literal notranslate"><span class="pre">F1</span></code>, <code class="docutils literal notranslate"><span class="pre">F2</span></code>.</p>
</section>
<section id="kind-inference-in-type-signatures">
<h2><span class="section-number">6.4.11.4. </span>Kind inference in type signatures<a class="headerlink" href="#kind-inference-in-type-signatures" title="Permalink to this heading">¶</a></h2>
<p>When kind-checking a type, GHC considers only what is written in that
type when figuring out how to generalise the type’s kind.</p>
<p>For example,
consider these definitions (with <a class="reference internal" href="scoped_type_variables.html#extension-ScopedTypeVariables"><code class="xref std std-extension docutils literal notranslate"><span class="pre">ScopedTypeVariables</span></code></a>):</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="n">a</span><span class="w">    </span><span class="c1">-- Proxy :: forall k. k -&gt; Type</span><span class="w"></span>
<span class="nf">p</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">p</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>GHC reports an error, saying that the kind of <code class="docutils literal notranslate"><span class="pre">a</span></code> should be a kind variable
<code class="docutils literal notranslate"><span class="pre">k</span></code>, not <code class="docutils literal notranslate"><span class="pre">Type</span></code>. This is because, by looking at the type signature
<code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">a.</span> <span class="pre">Proxy</span> <span class="pre">a</span></code>, GHC assumes <code class="docutils literal notranslate"><span class="pre">a</span></code>’s kind should be generalised, not
restricted to be <code class="docutils literal notranslate"><span class="pre">Type</span></code>. The function definition is then rejected for being
more specific than its type signature.</p>
</section>
<section id="explicit-kind-quantification">
<span id="id2"></span><h2><span class="section-number">6.4.11.5. </span>Explicit kind quantification<a class="headerlink" href="#explicit-kind-quantification" title="Permalink to this heading">¶</a></h2>
<p>Enabled by <a class="reference internal" href="#extension-PolyKinds"><code class="xref std std-extension docutils literal notranslate"><span class="pre">PolyKinds</span></code></a>, GHC supports explicit kind quantification,
as in these examples:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">k</span><span class="o">.</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">forall</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="nb">()</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
</pre></div>
</div>
<p>Note that the second example has a <code class="docutils literal notranslate"><span class="pre">forall</span></code> that binds both a kind <code class="docutils literal notranslate"><span class="pre">k</span></code> and
a type variable <code class="docutils literal notranslate"><span class="pre">a</span></code> of kind <code class="docutils literal notranslate"><span class="pre">k</span></code>. In general, there is no limit to how
deeply nested this sort of dependency can work. However, the dependency must
be well-scoped: <code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">(a</span> <span class="pre">::</span> <span class="pre">k)</span> <span class="pre">k.</span> <span class="pre">...</span></code> is an error.</p>
</section>
<section id="inferring-the-order-of-variables-in-a-type-class-declaration">
<span id="inferring-variable-order"></span><h2><span class="section-number">6.4.11.6. </span>Inferring the order of variables in a type/class declaration<a class="headerlink" href="#inferring-the-order-of-variables-in-a-type-class-declaration" title="Permalink to this heading">¶</a></h2>
<p>It is possible to get intricate dependencies among the type variables
introduced in a type or class declaration. Here is an example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkT</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>After analysing this declaration, GHC will discover that <code class="docutils literal notranslate"><span class="pre">a</span></code> and
<code class="docutils literal notranslate"><span class="pre">c</span></code> can be kind-polymorphic, with <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">::</span> <span class="pre">k2</span> <span class="pre">-&gt;</span> <span class="pre">Type</span></code> and
<code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">::</span> <span class="pre">k2</span></code>. We thus infer the following kind:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">T</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="p">{</span><span class="n">k2</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="p">}</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="p">)</span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="n">k2</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k2</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">k2</span></code> is placed <em>before</em> <code class="docutils literal notranslate"><span class="pre">k</span></code>, and that <code class="docutils literal notranslate"><span class="pre">k</span></code> is placed <em>before</em>
<code class="docutils literal notranslate"><span class="pre">a</span></code>. Also, note that <code class="docutils literal notranslate"><span class="pre">k2</span></code> is written here in braces. As explained with
<a class="reference internal" href="type_applications.html#extension-TypeApplications"><code class="xref std std-extension docutils literal notranslate"><span class="pre">TypeApplications</span></code></a> (<a class="reference internal" href="type_applications.html#inferred-vs-specified"><span class="std std-ref">Inferred vs. specified type variables</span></a>),
type and kind variables that GHC generalises
over, but not written in the original program, are not available for visible
type application. (These are called <em>inferred</em> variables.)
Such variables are written in braces.</p>
<p>The general principle is this:</p>
<blockquote>
<div><ul class="simple">
<li><p>Variables not available for type application come first.</p></li>
<li><p>Then come variables the user has written, implicitly brought into scope
in a type variable’s kind.</p></li>
<li><p>Lastly come the normal type variables of a declaration.</p></li>
<li><p>Variables not given an explicit ordering by the user are sorted according
to ScopedSort (<a class="reference internal" href="type_applications.html#scopedsort"><span class="std std-ref">Ordering of specified variables</span></a>).</p></li>
</ul>
</div></blockquote>
<p>With the <code class="docutils literal notranslate"><span class="pre">T</span></code> example above, we could bind <code class="docutils literal notranslate"><span class="pre">k</span></code> <em>after</em> <code class="docutils literal notranslate"><span class="pre">a</span></code>; doing so
would not violate dependency concerns. However, it would violate our general
principle, and so <code class="docutils literal notranslate"><span class="pre">k</span></code> comes first.</p>
<p>Sometimes, this ordering does not respect dependency. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">T2</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="kt">&#39;[a, b]</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>It must be that <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> have the same kind. Note also that <code class="docutils literal notranslate"><span class="pre">b</span></code>
is implicitly declared in <code class="docutils literal notranslate"><span class="pre">c</span></code>'s kind. Thus, according to our general
principle, <code class="docutils literal notranslate"><span class="pre">b</span></code> must come <em>before</em> <code class="docutils literal notranslate"><span class="pre">k</span></code>. However, <code class="docutils literal notranslate"><span class="pre">b</span></code> <em>depends on</em>
<code class="docutils literal notranslate"><span class="pre">k</span></code>. We thus reject <code class="docutils literal notranslate"><span class="pre">T2</span></code> with a suitable error message.</p>
<p>In associated types, we order the type variables as if the type family was a
top-level declaration, ignoring the visibilities of the class’s type variable
binders. Here is an example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">d</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
</pre></div>
</div>
<p>We infer these kinds:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">C</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="p">{</span><span class="n">k1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="p">}</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="p">)</span><span class="o">.</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k1</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Constraint</span><span class="w"></span>
<span class="kt">F</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="p">{</span><span class="n">k1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="p">}</span><span class="w"> </span><span class="p">{</span><span class="n">k2</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="p">}</span><span class="w"> </span><span class="p">{</span><span class="n">k3</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="p">}</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k1</span><span class="p">)</span><span class="o">.</span><span class="w"></span>
<span class="w">     </span><span class="n">j</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k2</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k3</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
</pre></div>
</div>
<p>Note that the kind of <code class="docutils literal notranslate"><span class="pre">a</span></code> is specified in the kind of <code class="docutils literal notranslate"><span class="pre">C</span></code> but inferred in
the kind of <code class="docutils literal notranslate"><span class="pre">F</span></code>.</p>
<p>The “general principle” described here is meant to make all this more
predictable for users. It would not be hard to extend GHC to relax
this principle. If you should want a change here, consider writing
a <a class="reference external" href="https://github.com/ghc-proposals/ghc-proposals/">proposal</a> to
do so.</p>
</section>
<section id="complete-user-supplied-kind-signatures-and-polymorphic-recursion">
<span id="complete-kind-signatures"></span><span id="index-0"></span><h2><span class="section-number">6.4.11.7. </span>Complete user-supplied kind signatures and polymorphic recursion<a class="headerlink" href="#complete-user-supplied-kind-signatures-and-polymorphic-recursion" title="Permalink to this heading">¶</a></h2>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-CUSKs">
<span id="ghc-flag--XCUSKs"></span><span id="extension-NoCUSKs"></span><span class="sig-name descname"><span class="pre">CUSKs</span></span><a class="headerlink" href="#extension-CUSKs" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>8.10.1</p>
</dd>
</dl>
</dd></dl>

<p>NB! This is a legacy feature, see <a class="reference internal" href="#extension-StandaloneKindSignatures"><code class="xref std std-extension docutils literal notranslate"><span class="pre">StandaloneKindSignatures</span></code></a> for the
modern replacement.</p>
<p>Just as in type inference, kind inference for recursive types can only
use <em>monomorphic</em> recursion. Consider this (contrived) example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkT</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">T</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="p">))</span><span class="w"></span>
<span class="c1">-- GHC infers kind  T :: (Type -&gt; Type) -&gt; Type -&gt; Type</span><span class="w"></span>
</pre></div>
</div>
<p>The recursive use of <code class="docutils literal notranslate"><span class="pre">T</span></code> forced the second argument to have kind
<code class="docutils literal notranslate"><span class="pre">Type</span></code>. However, just as in type inference, you can achieve polymorphic
recursion by giving a <em>complete user-supplied kind signature</em> (or CUSK)
for <code class="docutils literal notranslate"><span class="pre">T</span></code>. A CUSK is present when all argument kinds and the result kind
are known, without any need for inference. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">MkT</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>The complete user-supplied kind signature specifies the polymorphic kind
for <code class="docutils literal notranslate"><span class="pre">T</span></code>, and this signature is used for all the calls to <code class="docutils literal notranslate"><span class="pre">T</span></code>
including the recursive ones. In particular, the recursive use of <code class="docutils literal notranslate"><span class="pre">T</span></code>
is at kind <code class="docutils literal notranslate"><span class="pre">Type</span></code>.</p>
<p>What exactly is considered to be a “complete user-supplied kind
signature” for a type constructor? These are the forms:</p>
<ul>
<li><p>For a datatype, every type variable must be annotated with a kind. In
a GADT-style declaration, there may also be a kind signature (with a
top-level <code class="docutils literal notranslate"><span class="pre">::</span></code> in the header), but the presence or absence of this
annotation does not affect whether or not the declaration has a
complete signature.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">T1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w">       </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="c1">-- Yes;  T1 :: forall k. (k-&gt;Type) -&gt; k -&gt; Type</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">T2</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w">     </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="c1">-- Yes;  T2 :: forall k. (k-&gt;Type) -&gt; k -&gt; Type</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">T3</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="c1">-- Yes;  T3 :: forall k. (k-&gt;Type) -&gt; k -&gt; Type</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">T4</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w">      </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="c1">-- Yes;  T4 :: forall k. (k-&gt;Type) -&gt; k -&gt; Type</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">T5</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w">             </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="c1">-- No;  kind is inferred</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">T6</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w">                         </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="c1">-- No;  kind is inferred</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>For a datatype with a top-level <code class="docutils literal notranslate"><span class="pre">::</span></code>: all kind variables introduced after
the <code class="docutils literal notranslate"><span class="pre">::</span></code> must be explicitly quantified.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">T1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w">            </span><span class="c1">-- No CUSK: `k` is not explicitly quantified</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">T2</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">k</span><span class="o">.</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w">  </span><span class="c1">-- CUSK: `k` is bound explicitly</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">T3</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="p">)</span><span class="o">.</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w">   </span><span class="c1">-- still a CUSK</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>For a newtype, the rules are the same as they are for a data type
unless <a class="reference internal" href="primitives.html#extension-UnliftedNewtypes"><code class="xref std std-extension docutils literal notranslate"><span class="pre">UnliftedNewtypes</span></code></a> is enabled.
With <a class="reference internal" href="primitives.html#extension-UnliftedNewtypes"><code class="xref std std-extension docutils literal notranslate"><span class="pre">UnliftedNewtypes</span></code></a>, the type constructor
only has a CUSK if a kind signature is present. As with a datatype
with a top-level <code class="docutils literal notranslate"><span class="pre">::</span></code>, all kind variables introduced after
the <code class="docutils literal notranslate"><span class="pre">::</span></code> must be explicitly quantified</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE UnliftedNewtypes #-}</span><span class="w"></span>
<span class="kr">newtype</span><span class="w"> </span><span class="kt">N1</span><span class="w"> </span><span class="kr">where</span><span class="w">                 </span><span class="c1">-- No; missing kind signature</span><span class="w"></span>
<span class="kr">newtype</span><span class="w"> </span><span class="kt">N2</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">TYPE</span><span class="w"> </span><span class="kt">&#39;IntRep</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="c1">-- Yes; kind signature present</span><span class="w"></span>
<span class="kr">newtype</span><span class="w"> </span><span class="kt">N3</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w">     </span><span class="c1">-- No; missing kind signature</span><span class="w"></span>
<span class="kr">newtype</span><span class="w"> </span><span class="kt">N4</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="kr">where</span><span class="w">    </span><span class="c1">-- No; `k` is not explicitly quantified</span><span class="w"></span>
<span class="kr">newtype</span><span class="w"> </span><span class="kt">N5</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="p">)</span><span class="o">.</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="c1">-- Yes; good signature</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>For a class, every type variable must be annotated with a kind.</p></li>
<li><p>For a type synonym, every type variable and the result type must all
be annotated with kinds:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kt">S1</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w">    </span><span class="c1">-- Yes   S1 :: forall k. k -&gt; k</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kt">S2</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w">           </span><span class="c1">-- No    kind is inferred</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kt">S3</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="n">a</span><span class="w">     </span><span class="c1">-- No    kind is inferred</span><span class="w"></span>
</pre></div>
</div>
<p>Note that in <code class="docutils literal notranslate"><span class="pre">S2</span></code> and <code class="docutils literal notranslate"><span class="pre">S3</span></code>, the kind of the right-hand side is
rather apparent, but it is still not considered to have a complete
signature – no inference can be done before detecting the signature.</p>
</li>
<li><p>An un-associated open type or data family declaration <em>always</em> has a CUSK;
un-annotated type variables default to kind <code class="docutils literal notranslate"><span class="pre">Type</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">D1</span><span class="w"> </span><span class="n">a</span><span class="w">                  </span><span class="c1">-- D1 :: Type -&gt; Type</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">D2</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w">           </span><span class="c1">-- D2 :: forall k. k -&gt; Type</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">D3</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w">   </span><span class="c1">-- D3 :: forall k. k -&gt; Type</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">S1</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w">     </span><span class="c1">-- S1 :: forall k. Type -&gt; k -&gt; Type</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>An associated type or data family declaration has a CUSK precisely if
its enclosing class has a CUSK.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w">                </span><span class="c1">-- no CUSK</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">AT</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w">                  </span><span class="c1">-- no CUSK, b is defaulted</span><span class="w"></span>

<span class="kr">class</span><span class="w"> </span><span class="kt">D</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w">         </span><span class="c1">-- yes CUSK</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">AT2</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w">                 </span><span class="c1">-- yes CUSK, b is defaulted</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>A closed type family has a complete signature when all of its type
variables are annotated and a return kind (with a top-level <code class="docutils literal notranslate"><span class="pre">::</span></code>)
is supplied.</p></li>
</ul>
<p>It is possible to write a datatype that syntactically has a CUSK (according to
the rules above) but actually requires some inference. As a very contrived
example, consider</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="n">a</span><span class="w">           </span><span class="c1">-- Proxy :: forall k. k -&gt; Type</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">X</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>According to the rules above <code class="docutils literal notranslate"><span class="pre">X</span></code> has a CUSK. Yet, the kind of <code class="docutils literal notranslate"><span class="pre">k</span></code> is undetermined.
It is thus quantified over, giving <code class="docutils literal notranslate"><span class="pre">X</span></code> the kind <code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">k1</span> <span class="pre">(k</span> <span class="pre">::</span> <span class="pre">k1).</span> <span class="pre">Proxy</span> <span class="pre">k</span> <span class="pre">-&gt;</span> <span class="pre">Type</span></code>.</p>
<p>The detection of CUSKs is enabled by the <a class="reference internal" href="#extension-CUSKs"><code class="xref std std-extension docutils literal notranslate"><span class="pre">CUSKs</span></code></a> flag, which is
switched on by default. This extension is scheduled for deprecation to be
replaced with <a class="reference internal" href="#extension-StandaloneKindSignatures"><code class="xref std std-extension docutils literal notranslate"><span class="pre">StandaloneKindSignatures</span></code></a>.</p>
</section>
<section id="standalone-kind-signatures-and-polymorphic-recursion">
<span id="standalone-kind-signatures"></span><span id="index-1"></span><h2><span class="section-number">6.4.11.8. </span>Standalone kind signatures and polymorphic recursion<a class="headerlink" href="#standalone-kind-signatures-and-polymorphic-recursion" title="Permalink to this heading">¶</a></h2>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-StandaloneKindSignatures">
<span id="ghc-flag--XStandaloneKindSignatures"></span><span id="extension-NoStandaloneKindSignatures"></span><span class="sig-name descname"><span class="pre">StandaloneKindSignatures</span></span><a class="headerlink" href="#extension-StandaloneKindSignatures" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Implies<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#extension-CUSKs"><code class="xref std std-extension docutils literal notranslate"><span class="pre">NoCUSKs</span></code></a></p>
</dd>
<dt class="field-even">Since<span class="colon">:</span></dt>
<dd class="field-even"><p>8.10.1</p>
</dd>
</dl>
</dd></dl>

<p>Just as in type inference, kind inference for recursive types can only
use <em>monomorphic</em> recursion. Consider this (contrived) example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkT</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">T</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="p">))</span><span class="w"></span>
<span class="c1">-- GHC infers kind  T :: (Type -&gt; Type) -&gt; Type -&gt; Type</span><span class="w"></span>
</pre></div>
</div>
<p>The recursive use of <code class="docutils literal notranslate"><span class="pre">T</span></code> forced the second argument to have kind
<code class="docutils literal notranslate"><span class="pre">Type</span></code>. However, just as in type inference, you can achieve polymorphic
recursion by giving a <em>standalone kind signature</em> for <code class="docutils literal notranslate"><span class="pre">T</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkT</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">T</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
<p>The standalone kind signature specifies the polymorphic kind
for <code class="docutils literal notranslate"><span class="pre">T</span></code>, and this signature is used for all the calls to <code class="docutils literal notranslate"><span class="pre">T</span></code>
including the recursive ones. In particular, the recursive use of <code class="docutils literal notranslate"><span class="pre">T</span></code>
is at kind <code class="docutils literal notranslate"><span class="pre">Type</span></code>.</p>
<p>While a standalone kind signature determines the kind of a type constructor, it
does not determine its arity. This is of particular importance for type
families and type synonyms, as they cannot be partially applied. See
<a class="reference internal" href="type_families.html#type-family-declarations"><span class="std std-ref">Type family declarations</span></a> for more information about arity.</p>
<p>The arity can be specified using explicit binders and inline kind annotations:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- arity F0 = 0</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kt">F0</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">k</span><span class="o">.</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">F0</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">k</span><span class="o">.</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>

<span class="c1">-- arity F1 = 1</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kt">F1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">k</span><span class="o">.</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">F1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>

<span class="c1">-- arity F2 = 2</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kt">F2</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">k</span><span class="o">.</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">F2</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
</pre></div>
</div>
<p>In absence of an inline kind annotation, the inferred arity includes all
explicitly bound parameters and all immediately following invisible
parameters:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- arity FD1 = 1</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kt">FD1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">k</span><span class="o">.</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kt">FD1</span><span class="w"></span>

<span class="c1">-- arity FD2 = 2</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kt">FD2</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">k</span><span class="o">.</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kt">FD2</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">F0</span></code>, <code class="docutils literal notranslate"><span class="pre">F1</span></code>, <code class="docutils literal notranslate"><span class="pre">F2</span></code>, <code class="docutils literal notranslate"><span class="pre">FD1</span></code>, and <code class="docutils literal notranslate"><span class="pre">FD2</span></code> all have identical
standalone kind signatures. The arity is inferred from the type family header.</p>
<p>The kind variables bound by an outermost <code class="docutils literal notranslate"><span class="pre">forall</span></code> in a standalone kind
signature scope only over the kind in that signature. Unlike term-level type
signatures (see <a class="reference internal" href="scoped_type_variables.html#decl-type-sigs"><span class="std std-ref">Declaration type signatures</span></a>), the outermost kind variables do <em>not</em>
scope over the corresponding declaration. For example, given this class
declaration:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">m</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
</pre></div>
</div>
<p>The following would <em>not</em> be an equivalent definition of <code class="docutils literal notranslate"><span class="pre">C</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">k</span><span class="o">.</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Constraint</span><span class="w"></span>
<span class="kr">class</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">m</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
</pre></div>
</div>
<p>Because the <code class="docutils literal notranslate"><span class="pre">k</span></code> from the standalone kind signature does not scope over
<code class="docutils literal notranslate"><span class="pre">C</span></code>’s definition, the <code class="docutils literal notranslate"><span class="pre">k</span></code> in <code class="docutils literal notranslate"><span class="pre">m</span></code>’s type signature is no longer the kind
of <code class="docutils literal notranslate"><span class="pre">a</span></code>, but rather a completely distinct kind. It’s as if you had written
this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">k</span><span class="o">.</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Constraint</span><span class="w"></span>
<span class="kr">class</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">kindOfA</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">m</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">k</span><span class="o">.</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">kindOfA</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
</pre></div>
</div>
<p>To avoid this issue, <code class="docutils literal notranslate"><span class="pre">C</span></code>’s definition must be given an inline kind annotation
like so:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">k</span><span class="o">.</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Constraint</span><span class="w"></span>
<span class="kr">class</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">m</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="standalone-kind-signatures-and-declaration-headers">
<h2><span class="section-number">6.4.11.9. </span>Standalone kind signatures and declaration headers<a class="headerlink" href="#standalone-kind-signatures-and-declaration-headers" title="Permalink to this heading">¶</a></h2>
<p>GHC requires that in the presence of a standalone kind signature, data
declarations must bind all their inputs. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kt">Prox1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Prox1</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkProx1</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- OK.</span><span class="w"></span>

<span class="kr">type</span><span class="w"> </span><span class="kt">Prox2</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Prox2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkProx2</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- Error:</span><span class="w"></span>
<span class="w">  </span><span class="c1">--   • Expected a type, but found something with kind ‘k -&gt; Type’</span><span class="w"></span>
<span class="w">  </span><span class="c1">--   • In the data type declaration for ‘Prox2’</span><span class="w"></span>
</pre></div>
</div>
<p>GADT-style data declarations may either bind their inputs or use an inline
signature in addition to the standalone kind signature:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kt">GProx1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">GProx1</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="kt">MkGProx1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">GProx1</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- OK.</span><span class="w"></span>

<span class="kr">type</span><span class="w"> </span><span class="kt">GProx2</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">GProx2</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="kt">MkGProx2</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">GProx2</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- Error:</span><span class="w"></span>
<span class="w">  </span><span class="c1">--   • Expected a type, but found something with kind ‘k -&gt; Type’</span><span class="w"></span>
<span class="w">  </span><span class="c1">--   • In the data type declaration for ‘GProx2’</span><span class="w"></span>

<span class="kr">type</span><span class="w"> </span><span class="kt">GProx3</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">GProx3</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="kt">MkGProx3</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">GProx3</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- OK.</span><span class="w"></span>

<span class="kr">type</span><span class="w"> </span><span class="kt">GProx4</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">GProx4</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="kt">MkGProx4</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">GProx4</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- OK, w ~ (k -&gt; Type)</span><span class="w"></span>
</pre></div>
</div>
<p>Classes are subject to the same rules:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kt">C1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Constraint</span><span class="w"></span>
<span class="kr">class</span><span class="w"> </span><span class="kt">C1</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- OK.</span><span class="w"></span>

<span class="kr">type</span><span class="w"> </span><span class="kt">C2</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Constraint</span><span class="w"></span>
<span class="kr">class</span><span class="w"> </span><span class="kt">C2</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- Error:</span><span class="w"></span>
<span class="w">  </span><span class="c1">--   • Couldn&#39;t match expected kind ‘Constraint’</span><span class="w"></span>
<span class="w">  </span><span class="c1">--                 with actual kind ‘Type -&gt; Constraint’</span><span class="w"></span>
<span class="w">  </span><span class="c1">--   • In the class declaration for ‘C2’</span><span class="w"></span>
</pre></div>
</div>
<p>On the other hand, type families are exempt from this rule:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">F</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- OK.</span><span class="w"></span>
</pre></div>
</div>
<p>Data families are tricky territory. Their headers are exempt from this rule,
but their instances are not:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">T</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- OK.</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkT1</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- OK.</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkT3</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- Error:</span><span class="w"></span>
<span class="w">  </span><span class="c1">--   • Expecting one more argument to ‘T’</span><span class="w"></span>
<span class="w">  </span><span class="c1">--     Expected a type, but ‘T’ has kind ‘k0 -&gt; Type’</span><span class="w"></span>
<span class="w">  </span><span class="c1">--   • In the data instance declaration for ‘T’</span><span class="w"></span>
</pre></div>
</div>
<p>This also applies to GADT-style data instances:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Nat</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="kt">MkN4</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="mi">4</span><span class="w"></span>
<span class="w">                                 </span><span class="kt">MKN9</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="mi">9</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- OK.</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Symbol</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="kt">MkSN</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="s">&quot;Neptune&quot;</span><span class="w"></span>
<span class="w">                                        </span><span class="kt">MkSJ</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="s">&quot;Jupiter&quot;</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- OK.</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="kt">MkT4</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- Error:</span><span class="w"></span>
<span class="w">  </span><span class="c1">--   • Expecting one more argument to ‘T’</span><span class="w"></span>
<span class="w">  </span><span class="c1">--     Expected a type, but ‘T’ has kind ‘k0 -&gt; Type’</span><span class="w"></span>
<span class="w">  </span><span class="c1">--   • In the data instance declaration for ‘T’</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="kind-inference-in-data-type-declarations">
<h2><span class="section-number">6.4.11.10. </span>Kind inference in data type declarations<a class="headerlink" href="#kind-inference-in-data-type-declarations" title="Permalink to this heading">¶</a></h2>
<p>Consider the declaration</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">T1</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkT1</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">T2</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">MkT2</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>In both cases GHC looks at the data constructor declarations to
give constraints on the kind of <code class="docutils literal notranslate"><span class="pre">T</span></code>, yielding</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">T1</span><span class="p">,</span><span class="w"> </span><span class="kt">T2</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">k</span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
</pre></div>
</div>
<p>Consider the type</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">k</span><span class="o">.</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">GInt</span><span class="w">    </span><span class="ow">::</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="w">  </span><span class="kt">GMaybe</span><span class="w">  </span><span class="ow">::</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"></span>
</pre></div>
</div>
<p>This datatype <code class="docutils literal notranslate"><span class="pre">G</span></code> is GADT-like in both its kind and its type. Suppose you
have <code class="docutils literal notranslate"><span class="pre">g</span> <span class="pre">::</span> <span class="pre">G</span> <span class="pre">a</span></code>, where <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">::</span> <span class="pre">k</span></code>. Then pattern matching to discover that
<code class="docutils literal notranslate"><span class="pre">g</span></code> is in fact <code class="docutils literal notranslate"><span class="pre">GMaybe</span></code> tells you both that <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">~</span> <span class="pre">(Type</span> <span class="pre">-&gt;</span> <span class="pre">Type)</span></code> and
<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">~</span> <span class="pre">Maybe</span></code>. The definition for <code class="docutils literal notranslate"><span class="pre">G</span></code> requires that <a class="reference internal" href="#extension-PolyKinds"><code class="xref std std-extension docutils literal notranslate"><span class="pre">PolyKinds</span></code></a>
be in effect, but pattern-matching on <code class="docutils literal notranslate"><span class="pre">G</span></code> requires no extension beyond
<a class="reference internal" href="gadt.html#extension-GADTs"><code class="xref std std-extension docutils literal notranslate"><span class="pre">GADTs</span></code></a>. That this works is actually a straightforward extension
of regular GADTs and a consequence of the fact that kinds and types are the
same.</p>
<p>Note that the datatype <code class="docutils literal notranslate"><span class="pre">G</span></code> is used at different kinds in its body, and
therefore that kind-indexed GADTs use a form of polymorphic recursion.
It is thus only possible to use this feature if you have provided a
complete user-supplied kind signature (CUSK)
for the datatype (<a class="reference internal" href="#complete-kind-signatures"><span class="std std-ref">Complete user-supplied kind signatures and polymorphic recursion</span></a>), or a standalone
kind signature (<a class="reference internal" href="#standalone-kind-signatures"><span class="std std-ref">Standalone kind signatures and polymorphic recursion</span></a>);
in the case of <code class="docutils literal notranslate"><span class="pre">G</span></code> we both.
If you wish to see the kind indexing explicitly, you can do so by enabling <a class="reference internal" href="../using.html#ghc-flag-fprint-explicit-kinds"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fprint-explicit-kinds</span></code></a> and querying <code class="docutils literal notranslate"><span class="pre">G</span></code> with GHCi’s <a class="reference internal" href="../ghci.html#ghci-cmd-info"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:info</span></code></a> command:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="w"> </span><span class="kt">:</span><span class="n">set</span><span class="w"> </span><span class="o">-</span><span class="n">fprint</span><span class="o">-</span><span class="n">explicit</span><span class="o">-</span><span class="n">kinds</span><span class="w"></span>
<span class="o">&gt;</span><span class="w"> </span><span class="kt">:</span><span class="n">info</span><span class="w"> </span><span class="kt">G</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="n">role</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="n">nominal</span><span class="w"> </span><span class="n">nominal</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">k</span><span class="o">.</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="o">@</span><span class="n">k</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">GInt</span><span class="w">   </span><span class="ow">::</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="o">@</span><span class="kt">Type</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="w">  </span><span class="kt">GMaybe</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="o">@</span><span class="p">(</span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="p">)</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"></span>
</pre></div>
</div>
<p>where you can see the GADT-like nature of the two constructors.</p>
</section>
<section id="kind-inference-for-data-newtype-instance-declarations">
<span id="kind-inference-data-family-instances"></span><h2><span class="section-number">6.4.11.11. </span>Kind inference for data/newtype instance declarations<a class="headerlink" href="#kind-inference-for-data-newtype-instance-declarations" title="Permalink to this heading">¶</a></h2>
<p>Consider these declarations</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">k</span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="ow">-&gt;</span><span class="kt">Type</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">   </span><span class="kt">MkT</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">r</span><span class="o">.</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">T</span></code> has an invisible kind argument; and perhaps it is instantiated
to <code class="docutils literal notranslate"><span class="pre">Type</span></code> in the instance, thus:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="o">@</span><span class="kt">Type</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="ow">-&gt;</span><span class="kt">Type</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">q</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">   </span><span class="kt">MkT</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">r</span><span class="o">.</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
</pre></div>
</div>
<p>Or perhaps we intended the specialisation to be in the GADT data
constructor, thus:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="o">@</span><span class="n">k</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="ow">-&gt;</span><span class="kt">Type</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">q</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">   </span><span class="kt">MkT</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">r</span><span class="o">.</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="o">@</span><span class="kt">Type</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
</pre></div>
</div>
<p>It gets more complicated if there are multiple constructors.  In
general, there is no principled way to tell which type specialisation
comes from the data instance, and which from the individual GADT data
constructors.</p>
<p>So GHC implements this rule: in data/newtype instance declararations
(unlike ordinary data/newtype declarations) we do <em>not</em> look at the
constructor declarations when inferring the shape of the instance
header.  The principle is that <em>the instantiation of the data instance
should be apparent from the header alone</em>.  This principle makes the
program easier to understand, and avoids the swamp of complexity
indicated above.</p>
</section>
<section id="kind-inference-in-class-instance-declarations">
<h2><span class="section-number">6.4.11.12. </span>Kind inference in class instance declarations<a class="headerlink" href="#kind-inference-in-class-instance-declarations" title="Permalink to this heading">¶</a></h2>
<p>Consider the following example of a poly-kinded class and an instance
for it:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="n">a</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kr">type</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
</pre></div>
</div>
<p>In the class declaration, nothing constrains the kind of the type <code class="docutils literal notranslate"><span class="pre">a</span></code>,
so it becomes a poly-kinded type variable <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">::</span> <span class="pre">k)</span></code>. Yet, in the
instance declaration, the right-hand side of the associated type
instance <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code> says that <code class="docutils literal notranslate"><span class="pre">b</span></code> must be of kind <code class="docutils literal notranslate"><span class="pre">Type</span></code>. GHC could
theoretically propagate this information back into the instance head,
and make that instance declaration apply only to type of kind <code class="docutils literal notranslate"><span class="pre">Type</span></code>, as
opposed to types of any kind. However, GHC does <em>not</em> do this.</p>
<p>In short: GHC does <em>not</em> propagate kind information from the members of
a class instance declaration into the instance declaration head.</p>
<p>This lack of kind inference is simply an engineering problem within GHC,
but getting it to work would make a substantial change to the inference
infrastructure, and it’s not clear the payoff is worth it. If you want
to restrict <code class="docutils literal notranslate"><span class="pre">b</span></code>‘s kind in the instance above, just use a kind
signature in the instance head.</p>
</section>
<section id="kind-inference-in-type-synonyms-and-type-family-instances">
<h2><span class="section-number">6.4.11.13. </span>Kind inference in type synonyms and type family instances<a class="headerlink" href="#kind-inference-in-type-synonyms-and-type-family-instances" title="Permalink to this heading">¶</a></h2>
<p>Consider the scoping rules for type synonyms and type family instances, such as
these:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w">          </span><span class="kt">TS</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">rhs</span><span class="o">&gt;</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">TF</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">rhs</span><span class="o">&gt;</span><span class="w"></span>
</pre></div>
</div>
<p>The basic principle is that all variables mentioned on the right hand side
<code class="docutils literal notranslate"><span class="pre">&lt;rhs&gt;</span></code> must be bound on the left hand side:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kt">TS</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w">    </span><span class="c1">-- accepted</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kt">TS</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="c1">-- rejected: z not in scope</span><span class="w"></span>
</pre></div>
</div>
<p>But there is one exception: free variables mentioned in the outermost kind
signature on the right hand side are quantified implicitly. Thus, in the
following example the variables <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, and <code class="docutils literal notranslate"><span class="pre">k</span></code> are all in scope on the
right hand side of <code class="docutils literal notranslate"><span class="pre">S</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kt">S</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">rhs</span><span class="o">&gt;</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"></span>
</pre></div>
</div>
<p>The reason for this exception is that there may be no other way to bind <code class="docutils literal notranslate"><span class="pre">k</span></code>.
For example, suppose we wanted <code class="docutils literal notranslate"><span class="pre">S</span></code> to have the following kind with an
<em>invisible</em> parameter <code class="docutils literal notranslate"><span class="pre">k</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">S</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">k</span><span class="o">.</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"></span>
</pre></div>
</div>
<p>In this case, we could not simply bind <code class="docutils literal notranslate"><span class="pre">k</span></code> on the left-hand side, as <code class="docutils literal notranslate"><span class="pre">k</span></code>
would become a <em>visible</em> parameter:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kt">S</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">rhs</span><span class="o">&gt;</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"></span>
<span class="kt">S</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"></span>
</pre></div>
</div>
<p>Note that we only look at the <em>outermost</em> kind signature to decide which
variables to quantify implicitly. As a counter-example, consider <code class="docutils literal notranslate"><span class="pre">M1</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kt">M1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">&#39;Just</span><span class="w"> </span><span class="p">(</span><span class="kt">&#39;Nothing</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w">    </span><span class="c1">-- rejected: k not in scope</span><span class="w"></span>
</pre></div>
</div>
<p>Here, the kind signature is hidden inside <code class="docutils literal notranslate"><span class="pre">'Just</span></code>, and there is no outermost
kind signature. We can fix this example by providing an outermost kind signature:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kt">M2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">&#39;Just</span><span class="w"> </span><span class="p">(</span><span class="kt">&#39;Nothing</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="p">(</span><span class="kt">Maybe</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">k</span></code> is brought into scope by <code class="docutils literal notranslate"><span class="pre">::</span> <span class="pre">Maybe</span> <span class="pre">(Maybe</span> <span class="pre">k)</span></code>.</p>
<p>A kind signature is considered to be outermost regardless of redundant
parentheses:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kt">P</span><span class="w"> </span><span class="ow">=</span><span class="w">    </span><span class="kt">&#39;Nothing</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="w">    </span><span class="c1">-- accepted</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kt">P</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(((</span><span class="kt">&#39;Nothing</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="p">)))</span><span class="w"> </span><span class="c1">-- accepted</span><span class="w"></span>
</pre></div>
</div>
<p>Closed type family instances are subject to the same rules:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">F</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">&#39;Nothing</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">k</span><span class="w">            </span><span class="c1">-- accepted</span><span class="w"></span>

<span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">F</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">&#39;Just</span><span class="w"> </span><span class="p">(</span><span class="kt">&#39;Nothing</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w">    </span><span class="c1">-- rejected: k not in scope</span><span class="w"></span>

<span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">F</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">&#39;Just</span><span class="w"> </span><span class="p">(</span><span class="kt">&#39;Nothing</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="p">(</span><span class="kt">Maybe</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w">  </span><span class="c1">-- accepted</span><span class="w"></span>

<span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="p">(</span><span class="kt">Maybe</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">F</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">&#39;Just</span><span class="w"> </span><span class="p">(</span><span class="kt">&#39;Nothing</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w">    </span><span class="c1">-- rejected: k not in scope</span><span class="w"></span>

<span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="p">(</span><span class="kt">Maybe</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">F</span><span class="w"> </span><span class="o">@</span><span class="n">k</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">&#39;Just</span><span class="w"> </span><span class="p">(</span><span class="kt">&#39;Nothing</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="c1">-- accepted</span><span class="w"></span>
</pre></div>
</div>
<p>Kind variables can also be quantified in <em>visible</em> positions. Consider the
following two examples:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">ProxyKInvis</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">ProxyKVis</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>In the first example, the kind variable <code class="docutils literal notranslate"><span class="pre">k</span></code> is an <em>invisible</em> argument to
<code class="docutils literal notranslate"><span class="pre">ProxyKInvis</span></code>. In other words, a user does not need to instantiate <code class="docutils literal notranslate"><span class="pre">k</span></code>
explicitly, as kind inference automatically determines what <code class="docutils literal notranslate"><span class="pre">k</span></code> should be.
For instance, in <code class="docutils literal notranslate"><span class="pre">ProxyKInvis</span> <span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">k</span></code> is inferred to be <code class="docutils literal notranslate"><span class="pre">Bool</span></code>.
This is reflected in the kind of <code class="docutils literal notranslate"><span class="pre">ProxyKInvis</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">ProxyKInvis</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">k</span><span class="o">.</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
</pre></div>
</div>
<p>In the second example, <code class="docutils literal notranslate"><span class="pre">k</span></code> is a <em>visible</em> argument to <code class="docutils literal notranslate"><span class="pre">ProxyKVis</span></code>. That is
to say, <code class="docutils literal notranslate"><span class="pre">k</span></code> is an argument that users must provide explicitly when applying
<code class="docutils literal notranslate"><span class="pre">ProxyKVis</span></code>. For example, <code class="docutils literal notranslate"><span class="pre">ProxyKVis</span> <span class="pre">Bool</span> <span class="pre">True</span></code> is a well formed type.</p>
<p>What is the kind of <code class="docutils literal notranslate"><span class="pre">ProxyKVis</span></code>? One might say
<code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">k.</span> <span class="pre">Type</span> <span class="pre">-&gt;</span> <span class="pre">k</span> <span class="pre">-&gt;</span> <span class="pre">Type</span></code>, but this isn’t quite right, since this would
allow incorrect things like <code class="docutils literal notranslate"><span class="pre">ProxyKVis</span> <span class="pre">Bool</span> <span class="pre">Int</span></code>, which should be rejected
due to the fact that <code class="docutils literal notranslate"><span class="pre">Int</span></code> is not of kind <code class="docutils literal notranslate"><span class="pre">Bool</span></code>. The key observation is that
the kind of the second argument <em>depends</em> on the first argument. GHC indicates
this dependency in the syntax that it gives for the kind of <code class="docutils literal notranslate"><span class="pre">ProxyKVis</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">ProxyKVis</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
</pre></div>
</div>
<p>This kind is similar to the kind of <code class="docutils literal notranslate"><span class="pre">ProxyKInvis</span></code>, but with a key difference:
the type variables quantified by the <code class="docutils literal notranslate"><span class="pre">forall</span></code> are followed by an arrow
(<code class="docutils literal notranslate"><span class="pre">-&gt;</span></code>), not a dot (<code class="docutils literal notranslate"><span class="pre">.</span></code>). This is a visible, dependent quantifier. It is
visible in that the user must pass in a type for <code class="docutils literal notranslate"><span class="pre">k</span></code> explicitly, and it is
dependent in the sense that <code class="docutils literal notranslate"><span class="pre">k</span></code> appears later in the kind of <code class="docutils literal notranslate"><span class="pre">ProxyKVis</span></code>.
As a counterpart, the <code class="docutils literal notranslate"><span class="pre">k</span></code> binder in <code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">k.</span> <span class="pre">k</span> <span class="pre">-&gt;</span> <span class="pre">Type</span></code> can be thought
of as an <em>invisible</em>, dependent quantifier.</p>
<p>GHC permits writing kinds with this syntax, provided that the
<code class="docutils literal notranslate"><span class="pre">ExplicitForAll</span></code> and <code class="docutils literal notranslate"><span class="pre">PolyKinds</span></code> language extensions are enabled. Just
like the invisible <code class="docutils literal notranslate"><span class="pre">forall</span></code>, one can put explicit kind signatures on visibly
bound kind variables, so the following is syntactically valid:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">ProxyKVis</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
</pre></div>
</div>
<p>Currently, the ability to write visible, dependent quantifiers is limited to
kinds. Consequently, visible dependent quantifiers are rejected in any context
that is unambiguously the type of a term. They are also rejected in the types
of data constructors.</p>
</section>
<section id="kind-inference-in-closed-type-families">
<h2><span class="section-number">6.4.11.14. </span>Kind inference in closed type families<a class="headerlink" href="#kind-inference-in-closed-type-families" title="Permalink to this heading">¶</a></h2>
<p>Although all open type families are considered to have a complete
user-supplied kind signature (<a class="reference internal" href="#complete-kind-signatures"><span class="std std-ref">Complete user-supplied kind signatures and polymorphic recursion</span></a>),
we can relax this condition for closed
type families, where we have equations on which to perform kind
inference. GHC will infer kinds for the arguments and result types of a
closed type family.</p>
<p>GHC supports <em>kind-indexed</em> type families, where the family matches both
on the kind and type. GHC will <em>not</em> infer this behaviour without a
complete user-supplied kind signature or standalone kind
signature (see <a class="reference internal" href="#standalone-kind-signatures"><span class="std std-ref">Standalone kind signatures and polymorphic recursion</span></a>),
because doing so would sometimes infer
non-principal types. Indeed, we can see kind-indexing as a form
of polymorphic recursion, where a type is used at a kind other than
its most general in its own definition.</p>
<p>For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">F1</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">F1</span><span class="w"> </span><span class="kt">True</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kt">False</span><span class="w"></span>
<span class="w">  </span><span class="kt">F1</span><span class="w"> </span><span class="kt">False</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">True</span><span class="w"></span>
<span class="w">  </span><span class="kt">F1</span><span class="w"> </span><span class="n">x</span><span class="w">     </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="c1">-- F1 fails to compile: kind-indexing is not inferred</span><span class="w"></span>

<span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">F2</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">F2</span><span class="w"> </span><span class="kt">True</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kt">False</span><span class="w"></span>
<span class="w">  </span><span class="kt">F2</span><span class="w"> </span><span class="kt">False</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">True</span><span class="w"></span>
<span class="w">  </span><span class="kt">F2</span><span class="w"> </span><span class="n">x</span><span class="w">     </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="c1">-- F2 fails to compile: no complete signature</span><span class="w"></span>

<span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">F3</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">F3</span><span class="w"> </span><span class="kt">True</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kt">False</span><span class="w"></span>
<span class="w">  </span><span class="kt">F3</span><span class="w"> </span><span class="kt">False</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">True</span><span class="w"></span>
<span class="w">  </span><span class="kt">F3</span><span class="w"> </span><span class="n">x</span><span class="w">     </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="c1">-- OK</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="higher-rank-kinds">
<h2><span class="section-number">6.4.11.15. </span>Higher-rank kinds<a class="headerlink" href="#higher-rank-kinds" title="Permalink to this heading">¶</a></h2>
<p>In concert with <a class="reference internal" href="rank_polymorphism.html#extension-RankNTypes"><code class="xref std std-extension docutils literal notranslate"><span class="pre">RankNTypes</span></code></a>, GHC supports higher-rank kinds.
Here is an example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Heterogeneous propositional equality</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k1</span><span class="p">)</span><span class="w"> </span><span class="kt">:~~:</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k2</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">HRefl</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kt">:~~:</span><span class="w"> </span><span class="n">a</span><span class="w"></span>

<span class="kr">class</span><span class="w"> </span><span class="kt">HTestEquality</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">k</span><span class="o">.</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">hTestEquality</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">k1</span><span class="w"> </span><span class="n">k2</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k2</span><span class="p">)</span><span class="o">.</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="kt">:~~:</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">hTestEquality</span></code> takes two arguments where the type variable <code class="docutils literal notranslate"><span class="pre">t</span></code> is applied
to types of different kinds. That type variable must then be polykinded. Accordingly,
the kind of <code class="docutils literal notranslate"><span class="pre">HTestEquality</span></code> (the class) is <code class="docutils literal notranslate"><span class="pre">(forall</span> <span class="pre">k.</span> <span class="pre">k</span> <span class="pre">-&gt;</span> <span class="pre">Type)</span> <span class="pre">-&gt;</span> <span class="pre">Constraint</span></code>,
a higher-rank kind.</p>
<p>A big difference with higher-rank kinds as compared with higher-rank types is that
<code class="docutils literal notranslate"><span class="pre">forall</span></code>s in kinds <em>cannot</em> be moved. This is best illustrated by example.
Suppose we want to have an instance of <code class="docutils literal notranslate"><span class="pre">HTestEquality</span></code> for <code class="docutils literal notranslate"><span class="pre">(:~~:)</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">HTestEquality</span><span class="w"> </span><span class="p">((</span><span class="kt">:~~:</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">hTestEquality</span><span class="w"> </span><span class="kt">HRefl</span><span class="w"> </span><span class="kt">HRefl</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="kt">HRefl</span><span class="w"></span>
</pre></div>
</div>
<p>With the declaration of <code class="docutils literal notranslate"><span class="pre">(:~~:)</span></code> above, it gets kind <code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">k1</span> <span class="pre">k2.</span> <span class="pre">k1</span> <span class="pre">-&gt;</span> <span class="pre">k2</span> <span class="pre">-&gt;</span> <span class="pre">Type</span></code>.
Thus, the type <code class="docutils literal notranslate"><span class="pre">(:~~:)</span> <span class="pre">a</span></code> has kind <code class="docutils literal notranslate"><span class="pre">k2</span> <span class="pre">-&gt;</span> <span class="pre">Type</span></code> for some <code class="docutils literal notranslate"><span class="pre">k2</span></code>. GHC cannot
then <em>regeneralize</em> this kind to become <code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">k2.</span> <span class="pre">k2</span> <span class="pre">-&gt;</span> <span class="pre">Type</span></code> as desired. Thus, the
instance is rejected as ill-kinded.</p>
<p>To allow for such an instance, we would have to define <code class="docutils literal notranslate"><span class="pre">(:~~:)</span></code> as follows:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="p">(</span><span class="kt">:~~:</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">k1</span><span class="o">.</span><span class="w"> </span><span class="n">k1</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">k2</span><span class="o">.</span><span class="w"> </span><span class="n">k2</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">HRefl</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kt">:~~:</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>In this redefinition, we give an explicit kind for <code class="docutils literal notranslate"><span class="pre">(:~~:)</span></code>, deferring the choice
of <code class="docutils literal notranslate"><span class="pre">k2</span></code> until after the first argument (<code class="docutils literal notranslate"><span class="pre">a</span></code>) has been given. With this declaration
for <code class="docutils literal notranslate"><span class="pre">(:~~:)</span></code>, the instance for <code class="docutils literal notranslate"><span class="pre">HTestEquality</span></code> is accepted.</p>
</section>
<section id="the-kind-type">
<h2><span class="section-number">6.4.11.16. </span>The kind <code class="docutils literal notranslate"><span class="pre">Type</span></code><a class="headerlink" href="#the-kind-type" title="Permalink to this heading">¶</a></h2>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-StarIsType">
<span id="ghc-flag--XStarIsType"></span><span id="extension-NoStarIsType"></span><span class="sig-name descname"><span class="pre">StarIsType</span></span><a class="headerlink" href="#extension-StarIsType" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>8.6.1</p>
</dd>
</dl>
<p>Treat the unqualified uses of the <code class="docutils literal notranslate"><span class="pre">*</span></code> type operator as nullary and desugar
to <code class="docutils literal notranslate"><span class="pre">Data.Kind.Type</span></code>.</p>
</dd></dl>

<p>The kind <code class="docutils literal notranslate"><span class="pre">Type</span></code> (imported from <code class="docutils literal notranslate"><span class="pre">Data.Kind</span></code>) classifies ordinary types. With
<a class="reference internal" href="#extension-StarIsType"><code class="xref std std-extension docutils literal notranslate"><span class="pre">StarIsType</span></code></a> (currently enabled by default), <code class="docutils literal notranslate"><span class="pre">*</span></code> is desugared to
<code class="docutils literal notranslate"><span class="pre">Type</span></code>, but using this legacy syntax is not recommended due to conflicts with
<a class="reference internal" href="type_operators.html#extension-TypeOperators"><code class="xref std std-extension docutils literal notranslate"><span class="pre">TypeOperators</span></code></a>. This also applies to <code class="docutils literal notranslate"><span class="pre">★</span></code>, the Unicode variant of
<code class="docutils literal notranslate"><span class="pre">*</span></code>.</p>
</section>
<section id="inferring-dependency-in-datatype-declarations">
<h2><span class="section-number">6.4.11.17. </span>Inferring dependency in datatype declarations<a class="headerlink" href="#inferring-dependency-in-datatype-declarations" title="Permalink to this heading">¶</a></h2>
<p>If a type variable <code class="docutils literal notranslate"><span class="pre">a</span></code> in a datatype, class, or type family declaration
depends on another such variable <code class="docutils literal notranslate"><span class="pre">k</span></code> in the same declaration, two properties
must hold:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">a</span></code> must appear after <code class="docutils literal notranslate"><span class="pre">k</span></code> in the declaration, and</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">k</span></code> must appear explicitly in the kind of <em>some</em> type variable in that
declaration.</p></li>
</ul>
<p>The first bullet simply means that the dependency must be well-scoped. The
second bullet concerns GHC’s ability to infer dependency. Inferring this
dependency is difficult, and GHC currently requires the dependency to be
made explicit, meaning that <code class="docutils literal notranslate"><span class="pre">k</span></code> must appear in the kind of a type variable,
making it obvious to GHC that dependency is intended. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w">            </span><span class="c1">-- OK: dependency is &quot;obvious&quot;</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Proxy2</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">P</span><span class="w"> </span><span class="p">(</span><span class="kt">Proxy</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w">  </span><span class="c1">-- ERROR: dependency is unclear</span><span class="w"></span>
</pre></div>
</div>
<p>In the second declaration, GHC cannot immediately tell that <code class="docutils literal notranslate"><span class="pre">k</span></code> should
be a dependent variable, and so the declaration is rejected.</p>
<p>It is conceivable that this restriction will be relaxed in the future,
but it is (at the time of writing) unclear if the difficulties around this
scenario are theoretical (inferring this dependency would mean our type
system does not have principal types) or merely practical (inferring this
dependency is hard, given GHC’s implementation). So, GHC takes the easy
way out and requires a little help from the user.</p>
</section>
<section id="inferring-dependency-in-user-written-foralls">
<h2><span class="section-number">6.4.11.18. </span>Inferring dependency in user-written <code class="docutils literal notranslate"><span class="pre">forall</span></code>s<a class="headerlink" href="#inferring-dependency-in-user-written-foralls" title="Permalink to this heading">¶</a></h2>
<p>A programmer may use <code class="docutils literal notranslate"><span class="pre">forall</span></code> in a type to introduce new quantified type
variables. These variables may depend on each other, even in the same
<code class="docutils literal notranslate"><span class="pre">forall</span></code>. However, GHC requires that the dependency be inferrable from
the body of the <code class="docutils literal notranslate"><span class="pre">forall</span></code>. Here are some examples:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkProxy</span><span class="w">   </span><span class="c1">-- just to use below</span><span class="w"></span>

<span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">a</span><span class="w">        </span><span class="c1">-- This is just fine. We see that (a :: k).</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">undefined</span><span class="w"></span>

<span class="nf">g</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="nb">()</span><span class="w">              </span><span class="c1">-- This is to use below.</span><span class="w"></span>
<span class="nf">g</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">undefined</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Sing</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">h</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="w"> </span><span class="kt">Sing</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Sing</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="nb">()</span><span class="w">  </span><span class="c1">-- No obvious relationship between k and a</span><span class="w"></span>
<span class="nf">h</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="p">(</span><span class="kt">MkProxy</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w">  </span><span class="c1">-- This fails. We didn&#39;t know that a should have kind k.</span><span class="w"></span>
</pre></div>
</div>
<p>Note that in the last example, it’s impossible to learn that <code class="docutils literal notranslate"><span class="pre">a</span></code> depends on <code class="docutils literal notranslate"><span class="pre">k</span></code> in the
body of the <code class="docutils literal notranslate"><span class="pre">forall</span></code> (that is, the <code class="docutils literal notranslate"><span class="pre">Sing</span> <span class="pre">k</span> <span class="pre">-&gt;</span> <span class="pre">Sing</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">()</span></code>). And so GHC rejects
the program.</p>
</section>
<section id="kind-defaulting-without-polykinds">
<h2><span class="section-number">6.4.11.19. </span>Kind defaulting without <a class="reference internal" href="#extension-PolyKinds"><code class="xref std std-extension docutils literal notranslate"><span class="pre">PolyKinds</span></code></a><a class="headerlink" href="#kind-defaulting-without-polykinds" title="Permalink to this heading">¶</a></h2>
<p>Without <a class="reference internal" href="#extension-PolyKinds"><code class="xref std std-extension docutils literal notranslate"><span class="pre">PolyKinds</span></code></a>, GHC refuses to generalise over kind variables.
It thus defaults kind variables to <code class="docutils literal notranslate"><span class="pre">Type</span></code> when possible; when this is not
possible, an error is issued.</p>
<p>Here is an example of this in action:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE PolyKinds #-}</span><span class="w"></span>
<span class="kr">import</span><span class="w"> </span><span class="nn">Data.Kind</span><span class="w"> </span><span class="p">(</span><span class="kt">Type</span><span class="p">)</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">P</span><span class="w">   </span><span class="c1">-- inferred kind: Proxy :: k -&gt; Type</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Compose</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkCompose</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="c1">-- inferred kind: Compose :: (b -&gt; Type) -&gt; (a -&gt; b) -&gt; a -&gt; Type</span><span class="w"></span>

<span class="c1">-- separate module having imported the first</span><span class="w"></span>
<span class="cm">{-# LANGUAGE NoPolyKinds, DataKinds #-}</span><span class="w"></span>
<span class="nf">z</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Proxy</span><span class="w"> </span><span class="kt">&#39;MkCompose</span><span class="w"></span>
</pre></div>
</div>
<p>In the last line, we use the promoted constructor <code class="docutils literal notranslate"><span class="pre">'MkCompose</span></code>, which has
kind</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">forall</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="w"></span>
<span class="w">  </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Compose</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
</pre></div>
</div>
<p>Now we must infer a type for <code class="docutils literal notranslate"><span class="pre">z</span></code>. To do so without generalising over kind
variables, we must default the kind variables of <code class="docutils literal notranslate"><span class="pre">'MkCompose</span></code>. We can easily
default <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> to <code class="docutils literal notranslate"><span class="pre">Type</span></code>, but <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code> would be ill-kinded if
defaulted. The definition for <code class="docutils literal notranslate"><span class="pre">z</span></code> is thus an error.</p>
</section>
<section id="pretty-printing-in-the-presence-of-kind-polymorphism">
<h2><span class="section-number">6.4.11.20. </span>Pretty-printing in the presence of kind polymorphism<a class="headerlink" href="#pretty-printing-in-the-presence-of-kind-polymorphism" title="Permalink to this heading">¶</a></h2>
<p>With kind polymorphism, there is quite a bit going on behind the scenes that
may be invisible to a Haskell programmer. GHC supports several flags that
control how types are printed in error messages and at the GHCi prompt.
See the <a class="reference internal" href="../using.html#pretty-printing-types"><span class="std std-ref">discussion of type pretty-printing options</span></a>
for further details. If you are using kind polymorphism and are confused as to
why GHC is rejecting (or accepting) your program, we encourage you to turn on
these flags, especially <a class="reference internal" href="../using.html#ghc-flag-fprint-explicit-kinds"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fprint-explicit-kinds</span></code></a>.</p>
</section>
<section id="datatype-return-kinds">
<h2><span class="section-number">6.4.11.21. </span>Datatype return kinds<a class="headerlink" href="#datatype-return-kinds" title="Permalink to this heading">¶</a></h2>
<p>With <a class="reference internal" href="kind_signatures.html#extension-KindSignatures"><code class="xref std std-extension docutils literal notranslate"><span class="pre">KindSignatures</span></code></a>, we can give the kind of a datatype written
in GADT-syntax (see <a class="reference internal" href="gadt_syntax.html#extension-GADTSyntax"><code class="xref std std-extension docutils literal notranslate"><span class="pre">GADTSyntax</span></code></a>). For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>There are a number of restrictions around these <em>return kinds</em>. The text below
considers <a class="reference internal" href="primitives.html#extension-UnliftedNewtypes"><code class="xref std std-extension docutils literal notranslate"><span class="pre">UnliftedNewtypes</span></code></a> and data families (enabled by <a class="reference internal" href="type_families.html#extension-TypeFamilies"><code class="xref std std-extension docutils literal notranslate"><span class="pre">TypeFamilies</span></code></a>).
The discussion also assumes familiarity with <a class="reference internal" href="levity_polymorphism.html#runtime-rep"><span class="std std-ref">levity polymorphism</span></a>.</p>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">data</span></code> and <code class="docutils literal notranslate"><span class="pre">data</span> <span class="pre">instance</span></code> declarations must have return kinds that
end in <code class="docutils literal notranslate"><span class="pre">TYPE</span> <span class="pre">LiftedRep</span></code>. (Recall that <code class="docutils literal notranslate"><span class="pre">Type</span></code> is just a synonym for
<code class="docutils literal notranslate"><span class="pre">TYPE</span> <span class="pre">LiftedRep</span></code>.) By “end in”, we refer to the kind left over after
all arguments (introduced either by <code class="docutils literal notranslate"><span class="pre">forall</span></code> or <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code>) are stripped
off and type synonyms expanded. Note that no type family expansion
is done when performing this check.</p></li>
<li><p>If <a class="reference internal" href="primitives.html#extension-UnliftedNewtypes"><code class="xref std std-extension docutils literal notranslate"><span class="pre">UnliftedNewtypes</span></code></a> is enabled, then <code class="docutils literal notranslate"><span class="pre">newtype</span></code> and
<code class="docutils literal notranslate"><span class="pre">newtype</span> <span class="pre">instance</span></code> declarations must have return kinds that end
in <code class="docutils literal notranslate"><span class="pre">TYPE</span> <span class="pre">rep</span></code> for some <code class="docutils literal notranslate"><span class="pre">rep</span></code>. The <code class="docutils literal notranslate"><span class="pre">rep</span></code> may mention type families,
but the <code class="docutils literal notranslate"><span class="pre">TYPE</span></code> must be apparent without type family expansion.
(Type synonym expansion is acceptable.)</p>
<p>If <a class="reference internal" href="primitives.html#extension-UnliftedNewtypes"><code class="xref std std-extension docutils literal notranslate"><span class="pre">UnliftedNewtypes</span></code></a> is not enabled, then <code class="docutils literal notranslate"><span class="pre">newtype</span></code> and
<code class="docutils literal notranslate"><span class="pre">newtype</span> <span class="pre">instance</span></code> declarations have the same restrictions as <code class="docutils literal notranslate"><span class="pre">data</span></code>
declarations.</p>
</li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">data</span></code> or <code class="docutils literal notranslate"><span class="pre">newtype</span></code> instance actually can have <em>two</em> return kinds.
The first is the kind derived by applying the data family to the
patterns provided in the instance declaration. The second is given by
a kind annotation. Both return kinds must satisfy the restrictions
above.</p></li>
</ol>
<p>Examples:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">T1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w">             </span><span class="c1">-- good: Type expands to TYPE LiftedRep</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">T2</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">TYPE</span><span class="w"> </span><span class="kt">LiftedRep</span><span class="w">   </span><span class="c1">-- good</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">T3</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">k</span><span class="o">.</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w">  </span><span class="c1">-- good: arguments are dropped</span><span class="w"></span>

<span class="kr">type</span><span class="w"> </span><span class="kt">LR</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">LiftedRep</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">T3</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">TYPE</span><span class="w"> </span><span class="kt">LR</span><span class="w">          </span><span class="c1">-- good: we look through type synonyms</span><span class="w"></span>

<span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">F</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">LiftedRep</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">T4</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">TYPE</span><span class="w"> </span><span class="p">(</span><span class="kt">F</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="w">     </span><span class="c1">-- bad: we do not look through type families</span><span class="w"></span>

<span class="kr">type</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">G</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">T5</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="kt">Int</span><span class="w">            </span><span class="c1">-- bad: we do not look through type families</span><span class="w"></span>

<span class="c1">-- assume -XUnliftedNewtypes</span><span class="w"></span>
<span class="kr">newtype</span><span class="w"> </span><span class="kt">T6</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w">             </span><span class="c1">-- good</span><span class="w"></span>
<span class="kr">newtype</span><span class="w"> </span><span class="kt">T7</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">TYPE</span><span class="w"> </span><span class="p">(</span><span class="kt">F</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w">     </span><span class="c1">-- good</span><span class="w"></span>
<span class="kr">newtype</span><span class="w"> </span><span class="kt">T8</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w">            </span><span class="c1">-- bad</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">DF</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">DF</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w">             </span><span class="c1">-- good</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">DF</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">TYPE</span><span class="w"> </span><span class="kt">LiftedRep</span><span class="w">  </span><span class="c1">-- good</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kr">instance</span><span class="w"> </span><span class="kt">DF</span><span class="w"> </span><span class="kt">Char</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="kt">Int</span><span class="w">           </span><span class="c1">-- bad</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">DF2</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">k</span><span class="w">                   </span><span class="c1">-- good</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">DF2</span><span class="w"> </span><span class="kt">Type</span><span class="w">                     </span><span class="c1">-- good</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">DF2</span><span class="w"> </span><span class="kt">Bool</span><span class="w">                     </span><span class="c1">-- bad</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kr">family</span><span class="w"> </span><span class="kt">DF2</span><span class="w"> </span><span class="p">(</span><span class="kt">G</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="w">                  </span><span class="c1">-- bad for 2 reasons:</span><span class="w"></span>
<span class="w">                                         </span><span class="c1">--  a type family can&#39;t be in a pattern, and</span><span class="w"></span>
<span class="w">                                         </span><span class="c1">--  the kind fails the restrictions here</span><span class="w"></span>
</pre></div>
</div>
<span class="target" id="index-2"></span></section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="levity_polymorphism.html" class="btn btn-neutral float-right" title="6.4.12. Levity polymorphism" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="data_kinds.html" class="btn btn-neutral float-left" title="6.4.10. Datatype promotion" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>