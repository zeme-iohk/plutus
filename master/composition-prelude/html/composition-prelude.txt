-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Higher-order function combinators
--   
--   Replacement for <a>composition</a> or <a>composition-extra</a>,
--   exporting everything in one module.
@package composition-prelude
@version 3.0.0.2

module Control.Composition
(.*) :: (c -> d) -> (a -> b -> c) -> a -> b -> d
infixr 8 .*
(.**) :: (d -> e) -> (a -> b -> c -> d) -> a -> b -> c -> e
infixr 8 .**
(.***) :: (e -> f) -> (a -> b -> c -> d -> e) -> a -> b -> c -> d -> f
infixr 8 .***

(.****) :: (f -> g) -> (a -> b -> c -> d -> e -> f) -> a -> b -> c -> d -> e -> g
infixr 8 .****

(.*****) :: (g -> h) -> (a -> b -> c -> d -> e -> f -> g) -> a -> b -> c -> d -> e -> f -> h
infixr 8 .*****

(.******) :: (h -> i) -> (a -> b -> c -> d -> e -> f -> g -> h) -> a -> b -> c -> d -> e -> f -> g -> i
infixr 8 .******

-- | Backwards function composition. This is a specialization of
--   <a>&lt;&amp;&gt;</a>, but it has a different fixity.
(-.) :: (a -> b) -> (b -> c) -> a -> c
infixr 8 -.

(.@) :: (b -> c) -> (a -> c -> d) -> a -> b -> d
infixr 8 .@

(.@@) :: (c -> d) -> (a -> b -> d -> e) -> a -> b -> c -> e
infixr 8 .@@

(.@@@) :: (d -> e) -> (a -> b -> c -> e -> f) -> a -> b -> c -> d -> f
infixr 8 .@@@

(.@@@@) :: (e -> f) -> (a -> b -> c -> d -> f -> g) -> a -> b -> c -> d -> e -> g
infixr 8 .@@@@

(.@@@@@) :: (f -> g) -> (a -> b -> c -> d -> e -> g -> h) -> a -> b -> c -> d -> e -> f -> h
infixr 8 .@@@@@

-- | A monadic version of <a>.*</a>. Compare <a>&lt;=&lt;</a>.
--   
--   As an example, one could use this to rewrite
--   
--   <pre>
--   \x y z -&gt; f (g x y z) z
--   </pre>
--   
--   to
--   
--   <pre>
--   f &lt;=*&lt; g
--   </pre>
(<=*<) :: Monad m => (c -> m d) -> (a -> b -> m c) -> a -> b -> m d
infixr 1 <=*<

-- | The bleeding fish operator
(<=**<) :: Monad m => (d -> m e) -> (a -> b -> c -> m d) -> a -> b -> c -> m e
infixr 1 <=**<

(>=**>) :: Monad m => (a -> b -> c -> m d) -> (d -> m e) -> a -> b -> c -> m e
infixr 1 >=**>

-- | Compare <a>&gt;=&gt;</a>.
(>=*>) :: Monad m => (a -> b -> m c) -> (c -> m d) -> a -> b -> m d
infixr 1 >=*>

(<-=*<) :: Monad m => (b -> m c) -> (a -> c -> m d) -> a -> b -> m d
infixr 1 <-=*<

(>-=*>) :: Monad m => (a -> c -> m d) -> (b -> m c) -> a -> b -> m d
infixr 1 >-=*>

(<-=**<) :: Monad m => (c -> m d) -> (a -> b -> d -> m e) -> a -> b -> c -> m e
infixr 1 <-=**<

(>-=**>) :: Monad m => (a -> b -> d -> m e) -> (c -> m d) -> a -> b -> c -> m e
infixr 1 >-=**>

-- | Can be used to rewrite
--   
--   <pre>
--   \g -&gt; f . g . h
--   </pre>
--   
--   to
--   
--   <pre>
--   between f h
--   </pre>
between :: (c -> d) -> (a -> b) -> (b -> c) -> a -> d
(~@~) :: (c -> d) -> (a -> b) -> (b -> c) -> a -> d
infixl 8 ~@~
betweenM :: Monad m => (c -> m d) -> (a -> m b) -> (b -> m c) -> a -> m d
(<~@~<) :: Monad m => (c -> m d) -> (a -> m b) -> (b -> m c) -> a -> m d
infixl 8 <~@~<

-- | Backwards function application. This is an infix synonym for
--   <a>flip</a>
(-$) :: (a -> b -> c) -> b -> a -> c
infixl 8 -$
bisequence' :: (Traversable t, Applicative f) => t (a -> b -> f c) -> a -> b -> t (f c)

-- | Infix version of <a>join</a>
--   
--   As an example, one could use this to rewrite
--   
--   <pre>
--   between (char '"') (char '"')
--   </pre>
--   
--   to
--   
--   <pre>
--   between .$ (char '"')
--   </pre>
--   
--   Or
--   
--   <pre>
--   fromEither :: Either a a -&gt; a
--   fromEither = either id id
--   </pre>
--   
--   to
--   
--   <pre>
--   fromEither :: Either a a -&gt; a
--   fromEither = either .$ id
--   </pre>
(.$) :: Monad m => m (m a) -> m a
infixl 3 .$
axe :: (Traversable t, Applicative f) => t (a -> f ()) -> a -> f ()
biaxe :: (Traversable t, Applicative f) => t (a -> b -> f ()) -> a -> b -> f ()

thread :: Foldable t => t (a -> a) -> a -> a
threadM :: (Monad m, Foldable t, Applicative m) => t (a -> m a) -> a -> m a
both :: (a -> b) -> (a, a) -> (b, b)

dup :: a -> (a, a)

-- | Infix synonym for <a>both</a>
(+>) :: (a -> b) -> (a, a) -> (b, b)
infixr 6 +>

-- | Pronounced 'appose'. Synonym for <a>on</a>
(&:) :: (b -> b -> c) -> (a -> b) -> a -> a -> c
infixl 0 &:

-- | Right-to-left composition of Kleisli arrows.
--   <tt>(<a>&gt;=&gt;</a>)</tt>, with the arguments flipped.
--   
--   Note how this operator resembles function composition
--   <tt>(<a>.</a>)</tt>:
--   
--   <pre>
--   (.)   ::            (b -&gt;   c) -&gt; (a -&gt;   b) -&gt; a -&gt;   c
--   (&lt;=&lt;) :: Monad m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c
--   </pre>
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
infixr 1 <=<

-- | Left-to-right composition of Kleisli arrows.
--   
--   '<tt>(bs <a>&gt;=&gt;</a> cs) a</tt>' can be understood as the
--   <tt>do</tt> expression
--   
--   <pre>
--   do b &lt;- bs a
--      cs b
--   </pre>
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
infixr 1 >=>

-- | A variant of <a>&lt;*&gt;</a> with the arguments reversed.
(<**>) :: Applicative f => f a -> f (a -> b) -> f b
infixl 4 <**>

-- | <a>&amp;</a> is a reverse application operator. This provides
--   notational convenience. Its precedence is one higher than that of the
--   forward application operator <a>$</a>, which allows <a>&amp;</a> to be
--   nested in <a>$</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 &amp; (+1) &amp; show
--   "6"
--   </pre>
(&) :: a -> (a -> b) -> b
infixl 1 &

-- | Flipped version of <a>&lt;$&gt;</a>.
--   
--   <pre>
--   (<a>&lt;&amp;&gt;</a>) = <a>flip</a> <a>fmap</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Apply <tt>(+1)</tt> to a list, a <a>Just</a> and a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 &lt;&amp;&gt; (+1)
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&amp;&gt; (+1)
--   [2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 3 &lt;&amp;&gt; (+1)
--   Right 4
--   </pre>
(<&>) :: Functor f => f a -> (a -> b) -> f b
infixl 1 <&>

-- | <tt><a>fix</a> f</tt> is the least fixed point of the function
--   <tt>f</tt>, i.e. the least defined <tt>x</tt> such that <tt>f x =
--   x</tt>.
--   
--   For example, we can write the factorial function using direct
--   recursion as
--   
--   <pre>
--   &gt;&gt;&gt; let fac n = if n &lt;= 1 then 1 else n * fac (n-1) in fac 5
--   120
--   </pre>
--   
--   This uses the fact that Haskell’s <tt>let</tt> introduces recursive
--   bindings. We can rewrite this definition using <a>fix</a>,
--   
--   <pre>
--   &gt;&gt;&gt; fix (\rec n -&gt; if n &lt;= 1 then 1 else n * rec (n-1)) 5
--   120
--   </pre>
--   
--   Instead of making a recursive call, we introduce a dummy parameter
--   <tt>rec</tt>; when used within <a>fix</a>, this parameter then refers
--   to <a>fix</a>’s argument, hence the recursion is reintroduced.
fix :: (a -> a) -> a

-- | <tt><a>on</a> b u x y</tt> runs the binary function <tt>b</tt>
--   <i>on</i> the results of applying unary function <tt>u</tt> to two
--   arguments <tt>x</tt> and <tt>y</tt>. From the opposite perspective, it
--   transforms two inputs and combines the outputs.
--   
--   <pre>
--   ((+) `<a>on</a>` f) x y = f x + f y
--   </pre>
--   
--   Typical usage: <tt><a>sortBy</a> (<a>compare</a> `on`
--   <a>fst</a>)</tt>.
--   
--   Algebraic properties:
--   
--   <ul>
--   <li><pre>(*) `on` <a>id</a> = (*) -- (if (*) ∉ {⊥, <a>const</a>
--   ⊥})</pre></li>
--   <li><pre>((*) `on` f) `on` g = (*) `on` (f . g)</pre></li>
--   <li><pre><a>flip</a> on f . <a>flip</a> on g = <a>flip</a> on (g .
--   f)</pre></li>
--   </ul>
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
infixl 0 `on`
