-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Containers with monoidal accumulation
--   
--   Containers with merging via monoidal accumulation. The <a>Monoid</a>
--   instances provided by the <tt>containers</tt> and
--   <tt>unordered-containers</tt> packages merge structures in a
--   left-biased manner instead of using the underlying monoidal structure
--   of the value.
--   
--   This package wraps the types provided by these packages, but provides
--   <tt>Monoid</tt> instances implemented in terms of the value type's
--   <a>mappend</a>. For instance, the <tt>Monoid</tt> <tt>Map</tt>
--   instance looks like,
--   
--   <pre>
--   instance (Ord k, Semigroup a) =&gt; Monoid (MonoidalMap k a)
--   </pre>
@package monoidal-containers
@version 0.6.3.0


-- | This module provides a <a>HashMap</a> variant which uses the value's
--   <a>Monoid</a> instance to accumulate conflicting entries when merging
--   <tt>Map</tt>s.
--   
--   While some functions mirroring those of <a>HashMap</a> are provided
--   here for convenience, more specialized needs will likely want to use
--   either the <a>Newtype</a> or <a>Wrapped</a> instances to manipulate
--   the underlying <tt>Map</tt>.
module Data.HashMap.Monoidal

-- | A <tt>HashMap</tt> with monoidal accumulation
newtype MonoidalHashMap k a
MonoidalHashMap :: HashMap k a -> MonoidalHashMap k a
[getMonoidalHashMap] :: MonoidalHashMap k a -> HashMap k a

-- | <i>O(n*log n)</i>. Return a list of this map's elements. The list is
--   produced lazily. The order of its elements is unspecified.
toList :: MonoidalHashMap k a -> [(k, a)]

-- | <i>O(n*log n)</i>. Construct a map with the supplied mappings. If the
--   list contains duplicate mappings, values will be replaced.
fromList :: (Eq k, Hashable k) => [(k, a)] -> MonoidalHashMap k a

-- | <i>O(n*log n)</i>. Construct a map with the supplied mappings. If the
--   list contains duplicate mappings, values will be merged using the
--   provided combining function.
fromListWith :: (Eq k, Hashable k) => (a -> a -> a) -> [(k, a)] -> MonoidalHashMap k a

-- | <i>O(1)</i>. A map with a single element.
singleton :: (Eq k, Hashable k) => k -> a -> MonoidalHashMap k a

-- | <i>O(1)</i>. The number of elements in the map.
size :: MonoidalHashMap k a -> Int

-- | <i>O(log n)</i>. Is the key a member of the map? See also
--   <a>notMember</a>.
member :: (Eq k, Hashable k) => k -> MonoidalHashMap k a -> Bool

-- | <i>O(log n)</i>. Is the key not a member of the map? See also
--   <a>member</a>.
notMember :: (Eq k, Hashable k) => k -> MonoidalHashMap k a -> Bool

-- | <i>O(log n)</i> Return the value to which the specified key is mapped,
--   or <a>Nothing</a> if this map contains no mapping for the key.
lookup :: (Eq k, Hashable k) => k -> MonoidalHashMap k v -> Maybe v

-- | <i>O(log n)</i> Return the value to which the specified key is mapped,
--   or mempty if this map contains no mapping for the key.
lookupM :: (Eq k, Hashable k, Monoid v) => k -> MonoidalHashMap k v -> v

-- | <i>O(n)</i>. Return a list of this map's values. The list is produced
--   lazily.
elems :: MonoidalHashMap k a -> [a]

-- | <i>O(n)</i>. Return all keys of the map in ascending order. Subject to
--   list fusion.
keys :: MonoidalHashMap k a -> [k]

-- | <i>O(log n)</i>. Delete a key and its value from the map. When the key
--   is not a member of the map, the original map is returned.
delete :: (Eq k, Hashable k) => k -> MonoidalHashMap k a -> MonoidalHashMap k a

-- | <i>O(n)</i>. Map a function to each key of a map, if it will result in
--   duplicated mappings, their values will be merged in unspecified order
mapKeys :: (Hashable k, Eq k, Hashable k', Eq k') => (k -> k') -> MonoidalHashMap k a -> MonoidalHashMap k' a

-- | <i>O(log n)</i>. Insert a value on some key, if it exists replace the
--   value.
insert :: (Hashable k, Eq k) => k -> a -> MonoidalHashMap k a -> MonoidalHashMap k a

-- | <i>O(log n)</i>. Insert a value on some key, if it exists apply the
--   combining function.
insertWith :: (Hashable k, Eq k) => (a -> a -> a) -> k -> a -> MonoidalHashMap k a -> MonoidalHashMap k a

-- | <i>O(log n)</i>. Modify a value on some key with a function, if value
--   under key doesn't exist -- use mempty.
modify :: (Monoid a, Hashable k, Eq k) => (a -> a) -> k -> MonoidalHashMap k a -> MonoidalHashMap k a

-- | <i>O(log n)</i>. Modify a value on some key with a function, providing
--   a default value if that key doesn't exist.
modifyDef :: (Hashable k, Eq k) => a -> (a -> a) -> k -> MonoidalHashMap k a -> MonoidalHashMap k a

-- | <i>O(n)</i> Transform this map by applying a function to every value.
map :: (v1 -> v2) -> MonoidalHashMap k v1 -> MonoidalHashMap k v2

-- | <i>O(n)</i> Filter this map by retaining only elements satisfying a
--   predicate.
filterWithKey :: (k -> v -> Bool) -> MonoidalHashMap k v -> MonoidalHashMap k v
instance Data.Hashable.Class.Hashable k => Witherable.Filterable (Data.HashMap.Monoidal.MonoidalHashMap k)
instance Data.Hashable.Class.Hashable k => Data.Semialign.Internal.Zip (Data.HashMap.Monoidal.MonoidalHashMap k)
instance Data.Hashable.Class.Hashable k => Data.Semialign.Internal.Unalign (Data.HashMap.Monoidal.MonoidalHashMap k)
instance Data.Hashable.Class.Hashable k => Data.Semialign.Internal.Semialign (Data.HashMap.Monoidal.MonoidalHashMap k)
instance Data.Hashable.Class.Hashable k => Data.Hashable.Class.Hashable1 (Data.HashMap.Monoidal.MonoidalHashMap k)
instance GHC.Classes.Eq k => Data.Functor.Classes.Eq1 (Data.HashMap.Monoidal.MonoidalHashMap k)
instance Data.Hashable.Class.Hashable k => Data.Semialign.Internal.Align (Data.HashMap.Monoidal.MonoidalHashMap k)
instance (Data.Hashable.Class.Hashable k, Data.Hashable.Class.Hashable a) => Data.Hashable.Class.Hashable (Data.HashMap.Monoidal.MonoidalHashMap k a)
instance (Data.Data.Data k, Data.Data.Data a, Data.Hashable.Class.Hashable k) => Data.Data.Data (Data.HashMap.Monoidal.MonoidalHashMap k a)
instance Data.Traversable.Traversable (Data.HashMap.Monoidal.MonoidalHashMap k)
instance Data.Foldable.Foldable (Data.HashMap.Monoidal.MonoidalHashMap k)
instance (Control.DeepSeq.NFData k, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Data.HashMap.Monoidal.MonoidalHashMap k a)
instance (GHC.Classes.Eq k, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.HashMap.Monoidal.MonoidalHashMap k a)
instance GHC.Base.Functor (Data.HashMap.Monoidal.MonoidalHashMap k)
instance (Data.Hashable.Class.Hashable k, GHC.Read.Read k, GHC.Read.Read a) => GHC.Read.Read (Data.HashMap.Monoidal.MonoidalHashMap k a)
instance (GHC.Show.Show k, GHC.Show.Show a) => GHC.Show.Show (Data.HashMap.Monoidal.MonoidalHashMap k a)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Control.Lens.At.Ixed (Data.HashMap.Monoidal.MonoidalHashMap k a)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Control.Lens.At.At (Data.HashMap.Monoidal.MonoidalHashMap k a)
instance Control.Lens.Each.Each (Data.HashMap.Monoidal.MonoidalHashMap k a) (Data.HashMap.Monoidal.MonoidalHashMap k b) a b
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => WithIndex.FunctorWithIndex k (Data.HashMap.Monoidal.MonoidalHashMap k)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => WithIndex.FoldableWithIndex k (Data.HashMap.Monoidal.MonoidalHashMap k)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => WithIndex.TraversableWithIndex k (Data.HashMap.Monoidal.MonoidalHashMap k)
instance Control.Lens.Empty.AsEmpty (Data.HashMap.Monoidal.MonoidalHashMap k a)
instance Control.Lens.Wrapped.Wrapped (Data.HashMap.Monoidal.MonoidalHashMap k a)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Control.Lens.Wrapped.Rewrapped (Data.HashMap.Internal.HashMap k a) (Data.HashMap.Monoidal.MonoidalHashMap k a)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Control.Lens.Wrapped.Rewrapped (Data.HashMap.Monoidal.MonoidalHashMap k a) (Data.HashMap.Internal.HashMap k a)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k, GHC.Base.Semigroup a) => GHC.Base.Semigroup (Data.HashMap.Monoidal.MonoidalHashMap k a)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k, GHC.Base.Semigroup a) => GHC.Base.Monoid (Data.HashMap.Monoidal.MonoidalHashMap k a)
instance Control.Newtype.Newtype (Data.HashMap.Monoidal.MonoidalHashMap k a) (Data.HashMap.Internal.HashMap k a)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k, GHC.Base.Semigroup a) => GHC.Exts.IsList (Data.HashMap.Monoidal.MonoidalHashMap k a)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Witherable.Witherable (Data.HashMap.Monoidal.MonoidalHashMap k)


-- | This module provides a <a>IntMap</a> variant which uses the value's
--   <a>Monoid</a> instance to accumulate conflicting entries when merging
--   <tt>Map</tt>s.
--   
--   While some functions mirroring those of <a>IntMap</a> are provided
--   here for convenience, more specialized needs will likely want to use
--   either the <a>Newtype</a> or <a>Wrapped</a> instances to manipulate
--   the underlying <tt>Map</tt>.
module Data.IntMap.Monoidal

-- | An <tt>IntMap</tt> with monoidal accumulation
newtype MonoidalIntMap a
MonoidalIntMap :: IntMap a -> MonoidalIntMap a
[getMonoidalIntMap] :: MonoidalIntMap a -> IntMap a

-- | <i>O(1)</i>. A map with a single element.
singleton :: Int -> a -> MonoidalIntMap a

-- | <i>O(1)</i>. The number of elements in the map.
size :: MonoidalIntMap a -> Int

-- | <i>O(log n)</i>. Is the key a member of the map? See also
--   <a>notMember</a>.
member :: Int -> MonoidalIntMap a -> Bool

-- | <i>O(log n)</i>. Is the key not a member of the map? See also
--   <a>member</a>.
notMember :: Int -> MonoidalIntMap a -> Bool

-- | <i>O(log n)</i>. The expression <tt>(<a>findWithDefault</a> def k
--   map)</tt> returns the value at key <tt>k</tt> or returns default value
--   <tt>def</tt> when the key is not in the map.
findWithDefault :: forall a. a -> Int -> MonoidalIntMap a -> a

-- | <i>O(n)</i>. Return all elements of the map and their keys
assocs :: MonoidalIntMap a -> [(Int, a)]

-- | <i>O(n)</i>. Return all elements of the map in the ascending order of
--   their keys. Subject to list fusion.
elems :: MonoidalIntMap a -> [a]

-- | <i>O(n)</i>. Return all keys of the map in ascending order. Subject to
--   list fusion.
keys :: MonoidalIntMap a -> [Int]
(!) :: forall a. MonoidalIntMap a -> Int -> a
infixl 9 !
(\\) :: forall a b. MonoidalIntMap a -> MonoidalIntMap b -> MonoidalIntMap a
infixl 9 \\
adjust :: forall a. (a -> a) -> Int -> MonoidalIntMap a -> MonoidalIntMap a
adjustWithKey :: forall a. (Int -> a -> a) -> Int -> MonoidalIntMap a -> MonoidalIntMap a
alter :: forall a. (Maybe a -> Maybe a) -> Int -> MonoidalIntMap a -> MonoidalIntMap a

-- | <i>O(log n)</i>. Delete a key and its value from the map. When the key
--   is not a member of the map, the original map is returned.
delete :: Int -> MonoidalIntMap a -> MonoidalIntMap a
deleteFindMax :: forall a. MonoidalIntMap a -> ((Int, a), MonoidalIntMap a)
deleteFindMin :: forall a. MonoidalIntMap a -> ((Int, a), MonoidalIntMap a)
deleteMax :: forall a. MonoidalIntMap a -> MonoidalIntMap a
deleteMin :: forall a. MonoidalIntMap a -> MonoidalIntMap a
difference :: forall a b. MonoidalIntMap a -> MonoidalIntMap b -> MonoidalIntMap a
differenceWith :: forall a b. (a -> b -> Maybe a) -> MonoidalIntMap a -> MonoidalIntMap b -> MonoidalIntMap a
differenceWithKey :: forall a b. (Int -> a -> b -> Maybe a) -> MonoidalIntMap a -> MonoidalIntMap b -> MonoidalIntMap a
empty :: forall a. MonoidalIntMap a
filter :: forall a. (a -> Bool) -> MonoidalIntMap a -> MonoidalIntMap a
filterWithKey :: forall a. (Int -> a -> Bool) -> MonoidalIntMap a -> MonoidalIntMap a
findMax :: forall a. MonoidalIntMap a -> (Int, a)
findMin :: forall a. MonoidalIntMap a -> (Int, a)
foldMapWithKey :: forall a m. Monoid m => (Int -> a -> m) -> MonoidalIntMap a -> m
foldl :: forall a b. (a -> b -> a) -> a -> MonoidalIntMap b -> a
foldl' :: forall a b. (a -> b -> a) -> a -> MonoidalIntMap b -> a
foldlWithKey :: forall a b. (a -> Int -> b -> a) -> a -> MonoidalIntMap b -> a
foldlWithKey' :: forall a b. (a -> Int -> b -> a) -> a -> MonoidalIntMap b -> a
foldr :: forall a b. (a -> b -> b) -> b -> MonoidalIntMap a -> b
foldr' :: forall a b. (a -> b -> b) -> b -> MonoidalIntMap a -> b
foldrWithKey :: forall a b. (Int -> a -> b -> b) -> b -> MonoidalIntMap a -> b
foldrWithKey' :: forall a b. (Int -> a -> b -> b) -> b -> MonoidalIntMap a -> b
fromAscList :: forall a. [(Int, a)] -> MonoidalIntMap a
fromAscListWith :: forall a. (a -> a -> a) -> [(Int, a)] -> MonoidalIntMap a
fromAscListWithKey :: forall a. (Int -> a -> a -> a) -> [(Int, a)] -> MonoidalIntMap a
fromDistinctAscList :: forall a. [(Int, a)] -> MonoidalIntMap a
fromDistinctList :: forall a. [(Int, a)] -> MonoidalIntMap a
fromList :: forall a. [(Int, a)] -> MonoidalIntMap a
fromListWith :: forall a. (a -> a -> a) -> [(Int, a)] -> MonoidalIntMap a
fromListWithKey :: forall a. (Int -> a -> a -> a) -> [(Int, a)] -> MonoidalIntMap a
fromSet :: forall a. (Int -> a) -> IntSet -> MonoidalIntMap a
insert :: forall a. Int -> a -> MonoidalIntMap a -> MonoidalIntMap a
insertLookupWithKey :: forall a. (Int -> a -> a -> a) -> Int -> a -> MonoidalIntMap a -> (Maybe a, MonoidalIntMap a)
insertWith :: forall a. (a -> a -> a) -> Int -> a -> MonoidalIntMap a -> MonoidalIntMap a
insertWithKey :: forall a. (Int -> a -> a -> a) -> Int -> a -> MonoidalIntMap a -> MonoidalIntMap a
intersectionWith :: forall a b c. (a -> b -> c) -> MonoidalIntMap a -> MonoidalIntMap b -> MonoidalIntMap c
intersectionWithKey :: forall a b c. (Int -> a -> b -> c) -> MonoidalIntMap a -> MonoidalIntMap b -> MonoidalIntMap c
isProperSubmapOf :: forall a. Eq a => MonoidalIntMap a -> MonoidalIntMap a -> Bool
isProperSubmapOfBy :: forall a b. (a -> b -> Bool) -> MonoidalIntMap a -> MonoidalIntMap b -> Bool
isSubmapOf :: forall a. Eq a => MonoidalIntMap a -> MonoidalIntMap a -> Bool
isSubmapOfBy :: forall a b. (a -> b -> Bool) -> MonoidalIntMap a -> MonoidalIntMap b -> Bool
keysSet :: forall a. MonoidalIntMap a -> IntSet
lookup :: forall a. Int -> MonoidalIntMap a -> Maybe a
lookupGE :: forall a. Int -> MonoidalIntMap a -> Maybe (Int, a)
lookupGT :: forall a. Int -> MonoidalIntMap a -> Maybe (Int, a)
lookupLE :: forall a. Int -> MonoidalIntMap a -> Maybe (Int, a)
lookupLT :: forall a. Int -> MonoidalIntMap a -> Maybe (Int, a)
map :: (a -> b) -> MonoidalIntMap a -> MonoidalIntMap b
mapAccum :: forall a b c. (a -> b -> (a, c)) -> a -> MonoidalIntMap b -> (a, MonoidalIntMap c)
mapAccumRWithKey :: forall a b c. (a -> Int -> b -> (a, c)) -> a -> MonoidalIntMap b -> (a, MonoidalIntMap c)
mapAccumWithKey :: forall a b c. (a -> Int -> b -> (a, c)) -> a -> MonoidalIntMap b -> (a, MonoidalIntMap c)
mapEither :: forall a b c. (a -> Either b c) -> MonoidalIntMap a -> (MonoidalIntMap b, MonoidalIntMap c)
mapEitherWithKey :: forall a b c. (Int -> a -> Either b c) -> MonoidalIntMap a -> (MonoidalIntMap b, MonoidalIntMap c)
mapKeys :: forall a. (Int -> Int) -> MonoidalIntMap a -> MonoidalIntMap a
mapKeysMonotonic :: forall a. (Int -> Int) -> MonoidalIntMap a -> MonoidalIntMap a
mapKeysWith :: forall a. (a -> a -> a) -> (Int -> Int) -> MonoidalIntMap a -> MonoidalIntMap a
mapMaybe :: forall a b. (a -> Maybe b) -> MonoidalIntMap a -> MonoidalIntMap b
mapMaybeWithKey :: forall a b. (Int -> a -> Maybe b) -> MonoidalIntMap a -> MonoidalIntMap b
mapWithKey :: forall a b. (Int -> a -> b) -> MonoidalIntMap a -> MonoidalIntMap b
maxView :: forall a. MonoidalIntMap a -> Maybe (a, MonoidalIntMap a)
maxViewWithKey :: forall a. MonoidalIntMap a -> Maybe ((Int, a), MonoidalIntMap a)
mergeWithKey :: forall a b c. (Int -> a -> b -> Maybe c) -> (MonoidalIntMap a -> MonoidalIntMap c) -> (MonoidalIntMap b -> MonoidalIntMap c) -> MonoidalIntMap a -> MonoidalIntMap b -> MonoidalIntMap c
minView :: forall a. MonoidalIntMap a -> Maybe (a, MonoidalIntMap a)
minViewWithKey :: forall a. MonoidalIntMap a -> Maybe ((Int, a), MonoidalIntMap a)
null :: forall a. MonoidalIntMap a -> Bool
partition :: forall a. (a -> Bool) -> MonoidalIntMap a -> (MonoidalIntMap a, MonoidalIntMap a)
partitionWithKey :: forall a. (Int -> a -> Bool) -> MonoidalIntMap a -> (MonoidalIntMap a, MonoidalIntMap a)
split :: forall a. Int -> MonoidalIntMap a -> (MonoidalIntMap a, MonoidalIntMap a)
splitLookup :: forall a. Int -> MonoidalIntMap a -> (MonoidalIntMap a, Maybe a, MonoidalIntMap a)
splitRoot :: forall a. MonoidalIntMap a -> [MonoidalIntMap a]
toAscList :: forall a. MonoidalIntMap a -> [(Int, a)]
toDescList :: forall a. MonoidalIntMap a -> [(Int, a)]
toList :: forall a. MonoidalIntMap a -> [(Int, a)]
traverseWithKey :: Applicative t => (Int -> a -> t b) -> MonoidalIntMap a -> t (MonoidalIntMap b)
unionWith :: forall a. (a -> a -> a) -> MonoidalIntMap a -> MonoidalIntMap a -> MonoidalIntMap a
unionWithKey :: forall a. (Int -> a -> a -> a) -> MonoidalIntMap a -> MonoidalIntMap a -> MonoidalIntMap a
unionsWith :: forall a. (a -> a -> a) -> [MonoidalIntMap a] -> MonoidalIntMap a
update :: forall a. (a -> Maybe a) -> Int -> MonoidalIntMap a -> MonoidalIntMap a
updateLookupWithKey :: forall a. (Int -> a -> Maybe a) -> Int -> MonoidalIntMap a -> (Maybe a, MonoidalIntMap a)
updateMax :: forall a. (a -> Maybe a) -> MonoidalIntMap a -> MonoidalIntMap a
updateMaxWithKey :: forall a. (Int -> a -> Maybe a) -> MonoidalIntMap a -> MonoidalIntMap a
updateMin :: forall a. (a -> Maybe a) -> MonoidalIntMap a -> MonoidalIntMap a
updateMinWithKey :: forall a. (Int -> a -> Maybe a) -> MonoidalIntMap a -> MonoidalIntMap a
updateWithKey :: forall a. (Int -> a -> Maybe a) -> Int -> MonoidalIntMap a -> MonoidalIntMap a
instance Witherable.Filterable Data.IntMap.Monoidal.MonoidalIntMap
instance Data.Semialign.Internal.Zip Data.IntMap.Monoidal.MonoidalIntMap
instance Data.Semialign.Internal.Unalign Data.IntMap.Monoidal.MonoidalIntMap
instance Data.Semialign.Internal.Semialign Data.IntMap.Monoidal.MonoidalIntMap
instance Data.Semialign.Internal.Align Data.IntMap.Monoidal.MonoidalIntMap
instance Data.Data.Data a => Data.Data.Data (Data.IntMap.Monoidal.MonoidalIntMap a)
instance Data.Aeson.Types.ToJSON.ToJSON1 Data.IntMap.Monoidal.MonoidalIntMap
instance Data.Aeson.Types.FromJSON.FromJSON1 Data.IntMap.Monoidal.MonoidalIntMap
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Data.IntMap.Monoidal.MonoidalIntMap a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Data.IntMap.Monoidal.MonoidalIntMap a)
instance Data.Traversable.Traversable Data.IntMap.Monoidal.MonoidalIntMap
instance Data.Foldable.Foldable Data.IntMap.Monoidal.MonoidalIntMap
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.IntMap.Monoidal.MonoidalIntMap a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.IntMap.Monoidal.MonoidalIntMap a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.IntMap.Monoidal.MonoidalIntMap a)
instance GHC.Base.Functor Data.IntMap.Monoidal.MonoidalIntMap
instance GHC.Read.Read a => GHC.Read.Read (Data.IntMap.Monoidal.MonoidalIntMap a)
instance GHC.Show.Show a => GHC.Show.Show (Data.IntMap.Monoidal.MonoidalIntMap a)
instance Data.Functor.Classes.Eq1 Data.IntMap.Monoidal.MonoidalIntMap
instance Data.Functor.Classes.Ord1 Data.IntMap.Monoidal.MonoidalIntMap
instance Data.Functor.Classes.Show1 Data.IntMap.Monoidal.MonoidalIntMap
instance Control.Lens.At.Ixed (Data.IntMap.Monoidal.MonoidalIntMap a)
instance Control.Lens.At.At (Data.IntMap.Monoidal.MonoidalIntMap a)
instance Control.Lens.Each.Each (Data.IntMap.Monoidal.MonoidalIntMap a) (Data.IntMap.Monoidal.MonoidalIntMap b) a b
instance WithIndex.FunctorWithIndex GHC.Types.Int Data.IntMap.Monoidal.MonoidalIntMap
instance WithIndex.FoldableWithIndex GHC.Types.Int Data.IntMap.Monoidal.MonoidalIntMap
instance WithIndex.TraversableWithIndex GHC.Types.Int Data.IntMap.Monoidal.MonoidalIntMap
instance Control.Lens.Traversal.TraverseMin GHC.Types.Int Data.IntMap.Monoidal.MonoidalIntMap
instance Control.Lens.Traversal.TraverseMax GHC.Types.Int Data.IntMap.Monoidal.MonoidalIntMap
instance Control.Lens.Empty.AsEmpty (Data.IntMap.Monoidal.MonoidalIntMap a)
instance Control.Lens.Wrapped.Wrapped (Data.IntMap.Monoidal.MonoidalIntMap a)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.IntMap.Monoidal.MonoidalIntMap a)
instance GHC.Base.Semigroup a => GHC.Base.Monoid (Data.IntMap.Monoidal.MonoidalIntMap a)
instance Control.Newtype.Newtype (Data.IntMap.Monoidal.MonoidalIntMap a) (Data.IntMap.Internal.IntMap a)
instance GHC.Base.Semigroup a => GHC.Exts.IsList (Data.IntMap.Monoidal.MonoidalIntMap a)
instance Witherable.Witherable Data.IntMap.Monoidal.MonoidalIntMap


-- | This module provides a <a>IntMap</a> variant which uses the value's
--   <a>Monoid</a> instance to accumulate conflicting entries when merging
--   <tt>Map</tt>s.
--   
--   While some functions mirroring those of <a>IntMap</a> are provided
--   here for convenience, more specialized needs will likely want to use
--   either the <a>Newtype</a> or <a>Wrapped</a> instances to manipulate
--   the underlying <tt>Map</tt>.
module Data.IntMap.Monoidal.Strict

-- | An <tt>IntMap</tt> with monoidal accumulation
newtype MonoidalIntMap a
MonoidalIntMap :: IntMap a -> MonoidalIntMap a
[getMonoidalIntMap] :: MonoidalIntMap a -> IntMap a

-- | <i>O(1)</i>. A map with a single element.
singleton :: Int -> a -> MonoidalIntMap a

-- | <i>O(1)</i>. The number of elements in the map.
size :: MonoidalIntMap a -> Int

-- | <i>O(log n)</i>. Is the key a member of the map? See also
--   <a>notMember</a>.
member :: Int -> MonoidalIntMap a -> Bool

-- | <i>O(log n)</i>. Is the key not a member of the map? See also
--   <a>member</a>.
notMember :: Int -> MonoidalIntMap a -> Bool

-- | <i>O(log n)</i>. The expression <tt>(<a>findWithDefault</a> def k
--   map)</tt> returns the value at key <tt>k</tt> or returns default value
--   <tt>def</tt> when the key is not in the map.
findWithDefault :: forall a. a -> Int -> MonoidalIntMap a -> a

-- | <i>O(n)</i>. Return all elements of the map and their keys
assocs :: MonoidalIntMap a -> [(Int, a)]

-- | <i>O(n)</i>. Return all elements of the map in the ascending order of
--   their keys. Subject to list fusion.
elems :: MonoidalIntMap a -> [a]

-- | <i>O(n)</i>. Return all keys of the map in ascending order. Subject to
--   list fusion.
keys :: MonoidalIntMap a -> [Int]
(!) :: forall a. MonoidalIntMap a -> Int -> a
infixl 9 !
(\\) :: forall a b. MonoidalIntMap a -> MonoidalIntMap b -> MonoidalIntMap a
infixl 9 \\
adjust :: forall a. (a -> a) -> Int -> MonoidalIntMap a -> MonoidalIntMap a
adjustWithKey :: forall a. (Int -> a -> a) -> Int -> MonoidalIntMap a -> MonoidalIntMap a
alter :: forall a. (Maybe a -> Maybe a) -> Int -> MonoidalIntMap a -> MonoidalIntMap a

-- | <i>O(log n)</i>. Delete a key and its value from the map. When the key
--   is not a member of the map, the original map is returned.
delete :: Int -> MonoidalIntMap a -> MonoidalIntMap a
deleteFindMax :: forall a. MonoidalIntMap a -> ((Int, a), MonoidalIntMap a)
deleteFindMin :: forall a. MonoidalIntMap a -> ((Int, a), MonoidalIntMap a)
deleteMax :: forall a. MonoidalIntMap a -> MonoidalIntMap a
deleteMin :: forall a. MonoidalIntMap a -> MonoidalIntMap a
difference :: forall a b. MonoidalIntMap a -> MonoidalIntMap b -> MonoidalIntMap a
differenceWith :: forall a b. (a -> b -> Maybe a) -> MonoidalIntMap a -> MonoidalIntMap b -> MonoidalIntMap a
differenceWithKey :: forall a b. (Int -> a -> b -> Maybe a) -> MonoidalIntMap a -> MonoidalIntMap b -> MonoidalIntMap a
empty :: forall a. MonoidalIntMap a
filter :: forall a. (a -> Bool) -> MonoidalIntMap a -> MonoidalIntMap a
filterWithKey :: forall a. (Int -> a -> Bool) -> MonoidalIntMap a -> MonoidalIntMap a
findMax :: forall a. MonoidalIntMap a -> (Int, a)
findMin :: forall a. MonoidalIntMap a -> (Int, a)
foldMapWithKey :: forall a m. Monoid m => (Int -> a -> m) -> MonoidalIntMap a -> m
foldl :: forall a b. (a -> b -> a) -> a -> MonoidalIntMap b -> a
foldl' :: forall a b. (a -> b -> a) -> a -> MonoidalIntMap b -> a
foldlWithKey :: forall a b. (a -> Int -> b -> a) -> a -> MonoidalIntMap b -> a
foldlWithKey' :: forall a b. (a -> Int -> b -> a) -> a -> MonoidalIntMap b -> a
foldr :: forall a b. (a -> b -> b) -> b -> MonoidalIntMap a -> b
foldr' :: forall a b. (a -> b -> b) -> b -> MonoidalIntMap a -> b
foldrWithKey :: forall a b. (Int -> a -> b -> b) -> b -> MonoidalIntMap a -> b
foldrWithKey' :: forall a b. (Int -> a -> b -> b) -> b -> MonoidalIntMap a -> b
fromAscList :: forall a. [(Int, a)] -> MonoidalIntMap a
fromAscListWith :: forall a. (a -> a -> a) -> [(Int, a)] -> MonoidalIntMap a
fromAscListWithKey :: forall a. (Int -> a -> a -> a) -> [(Int, a)] -> MonoidalIntMap a
fromDistinctAscList :: forall a. [(Int, a)] -> MonoidalIntMap a
fromDistinctList :: forall a. [(Int, a)] -> MonoidalIntMap a
fromList :: forall a. [(Int, a)] -> MonoidalIntMap a
fromListWith :: forall a. (a -> a -> a) -> [(Int, a)] -> MonoidalIntMap a
fromListWithKey :: forall a. (Int -> a -> a -> a) -> [(Int, a)] -> MonoidalIntMap a
fromSet :: forall a. (Int -> a) -> IntSet -> MonoidalIntMap a
insert :: forall a. Int -> a -> MonoidalIntMap a -> MonoidalIntMap a
insertLookupWithKey :: forall a. (Int -> a -> a -> a) -> Int -> a -> MonoidalIntMap a -> (Maybe a, MonoidalIntMap a)
insertWith :: forall a. (a -> a -> a) -> Int -> a -> MonoidalIntMap a -> MonoidalIntMap a
insertWithKey :: forall a. (Int -> a -> a -> a) -> Int -> a -> MonoidalIntMap a -> MonoidalIntMap a
intersectionWith :: forall a b c. (a -> b -> c) -> MonoidalIntMap a -> MonoidalIntMap b -> MonoidalIntMap c
intersectionWithKey :: forall a b c. (Int -> a -> b -> c) -> MonoidalIntMap a -> MonoidalIntMap b -> MonoidalIntMap c
isProperSubmapOf :: forall a. Eq a => MonoidalIntMap a -> MonoidalIntMap a -> Bool
isProperSubmapOfBy :: forall a b. (a -> b -> Bool) -> MonoidalIntMap a -> MonoidalIntMap b -> Bool
isSubmapOf :: forall a. Eq a => MonoidalIntMap a -> MonoidalIntMap a -> Bool
isSubmapOfBy :: forall a b. (a -> b -> Bool) -> MonoidalIntMap a -> MonoidalIntMap b -> Bool
keysSet :: forall a. MonoidalIntMap a -> IntSet
lookup :: forall a. Int -> MonoidalIntMap a -> Maybe a
lookupGE :: forall a. Int -> MonoidalIntMap a -> Maybe (Int, a)
lookupGT :: forall a. Int -> MonoidalIntMap a -> Maybe (Int, a)
lookupLE :: forall a. Int -> MonoidalIntMap a -> Maybe (Int, a)
lookupLT :: forall a. Int -> MonoidalIntMap a -> Maybe (Int, a)
map :: (a -> b) -> MonoidalIntMap a -> MonoidalIntMap b
mapAccum :: forall a b c. (a -> b -> (a, c)) -> a -> MonoidalIntMap b -> (a, MonoidalIntMap c)
mapAccumRWithKey :: forall a b c. (a -> Int -> b -> (a, c)) -> a -> MonoidalIntMap b -> (a, MonoidalIntMap c)
mapAccumWithKey :: forall a b c. (a -> Int -> b -> (a, c)) -> a -> MonoidalIntMap b -> (a, MonoidalIntMap c)
mapEither :: forall a b c. (a -> Either b c) -> MonoidalIntMap a -> (MonoidalIntMap b, MonoidalIntMap c)
mapEitherWithKey :: forall a b c. (Int -> a -> Either b c) -> MonoidalIntMap a -> (MonoidalIntMap b, MonoidalIntMap c)
mapKeys :: forall a. (Int -> Int) -> MonoidalIntMap a -> MonoidalIntMap a
mapKeysMonotonic :: forall a. (Int -> Int) -> MonoidalIntMap a -> MonoidalIntMap a
mapKeysWith :: forall a. (a -> a -> a) -> (Int -> Int) -> MonoidalIntMap a -> MonoidalIntMap a
mapMaybe :: forall a b. (a -> Maybe b) -> MonoidalIntMap a -> MonoidalIntMap b
mapMaybeWithKey :: forall a b. (Int -> a -> Maybe b) -> MonoidalIntMap a -> MonoidalIntMap b
mapWithKey :: forall a b. (Int -> a -> b) -> MonoidalIntMap a -> MonoidalIntMap b
maxView :: forall a. MonoidalIntMap a -> Maybe (a, MonoidalIntMap a)
maxViewWithKey :: forall a. MonoidalIntMap a -> Maybe ((Int, a), MonoidalIntMap a)
mergeWithKey :: forall a b c. (Int -> a -> b -> Maybe c) -> (MonoidalIntMap a -> MonoidalIntMap c) -> (MonoidalIntMap b -> MonoidalIntMap c) -> MonoidalIntMap a -> MonoidalIntMap b -> MonoidalIntMap c
minView :: forall a. MonoidalIntMap a -> Maybe (a, MonoidalIntMap a)
minViewWithKey :: forall a. MonoidalIntMap a -> Maybe ((Int, a), MonoidalIntMap a)
null :: forall a. MonoidalIntMap a -> Bool
partition :: forall a. (a -> Bool) -> MonoidalIntMap a -> (MonoidalIntMap a, MonoidalIntMap a)
partitionWithKey :: forall a. (Int -> a -> Bool) -> MonoidalIntMap a -> (MonoidalIntMap a, MonoidalIntMap a)
split :: forall a. Int -> MonoidalIntMap a -> (MonoidalIntMap a, MonoidalIntMap a)
splitLookup :: forall a. Int -> MonoidalIntMap a -> (MonoidalIntMap a, Maybe a, MonoidalIntMap a)
splitRoot :: forall a. MonoidalIntMap a -> [MonoidalIntMap a]
toAscList :: forall a. MonoidalIntMap a -> [(Int, a)]
toDescList :: forall a. MonoidalIntMap a -> [(Int, a)]
toList :: forall a. MonoidalIntMap a -> [(Int, a)]
traverseWithKey :: Applicative t => (Int -> a -> t b) -> MonoidalIntMap a -> t (MonoidalIntMap b)
unionWith :: forall a. (a -> a -> a) -> MonoidalIntMap a -> MonoidalIntMap a -> MonoidalIntMap a
unionWithKey :: forall a. (Int -> a -> a -> a) -> MonoidalIntMap a -> MonoidalIntMap a -> MonoidalIntMap a
unionsWith :: forall a. (a -> a -> a) -> [MonoidalIntMap a] -> MonoidalIntMap a
update :: forall a. (a -> Maybe a) -> Int -> MonoidalIntMap a -> MonoidalIntMap a
updateLookupWithKey :: forall a. (Int -> a -> Maybe a) -> Int -> MonoidalIntMap a -> (Maybe a, MonoidalIntMap a)
updateMax :: forall a. (a -> Maybe a) -> MonoidalIntMap a -> MonoidalIntMap a
updateMaxWithKey :: forall a. (Int -> a -> Maybe a) -> MonoidalIntMap a -> MonoidalIntMap a
updateMin :: forall a. (a -> Maybe a) -> MonoidalIntMap a -> MonoidalIntMap a
updateMinWithKey :: forall a. (Int -> a -> Maybe a) -> MonoidalIntMap a -> MonoidalIntMap a
updateWithKey :: forall a. (Int -> a -> Maybe a) -> Int -> MonoidalIntMap a -> MonoidalIntMap a
instance Witherable.Filterable Data.IntMap.Monoidal.Strict.MonoidalIntMap
instance Data.Semialign.Internal.Zip Data.IntMap.Monoidal.Strict.MonoidalIntMap
instance Data.Semialign.Internal.Unalign Data.IntMap.Monoidal.Strict.MonoidalIntMap
instance Data.Semialign.Internal.Semialign Data.IntMap.Monoidal.Strict.MonoidalIntMap
instance Data.Semialign.Internal.Align Data.IntMap.Monoidal.Strict.MonoidalIntMap
instance Data.Data.Data a => Data.Data.Data (Data.IntMap.Monoidal.Strict.MonoidalIntMap a)
instance Data.Aeson.Types.ToJSON.ToJSON1 Data.IntMap.Monoidal.Strict.MonoidalIntMap
instance Data.Aeson.Types.FromJSON.FromJSON1 Data.IntMap.Monoidal.Strict.MonoidalIntMap
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Data.IntMap.Monoidal.Strict.MonoidalIntMap a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Data.IntMap.Monoidal.Strict.MonoidalIntMap a)
instance Data.Traversable.Traversable Data.IntMap.Monoidal.Strict.MonoidalIntMap
instance Data.Foldable.Foldable Data.IntMap.Monoidal.Strict.MonoidalIntMap
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.IntMap.Monoidal.Strict.MonoidalIntMap a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.IntMap.Monoidal.Strict.MonoidalIntMap a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.IntMap.Monoidal.Strict.MonoidalIntMap a)
instance GHC.Base.Functor Data.IntMap.Monoidal.Strict.MonoidalIntMap
instance GHC.Read.Read a => GHC.Read.Read (Data.IntMap.Monoidal.Strict.MonoidalIntMap a)
instance GHC.Show.Show a => GHC.Show.Show (Data.IntMap.Monoidal.Strict.MonoidalIntMap a)
instance Data.Functor.Classes.Eq1 Data.IntMap.Monoidal.Strict.MonoidalIntMap
instance Data.Functor.Classes.Ord1 Data.IntMap.Monoidal.Strict.MonoidalIntMap
instance Data.Functor.Classes.Show1 Data.IntMap.Monoidal.Strict.MonoidalIntMap
instance Control.Lens.At.Ixed (Data.IntMap.Monoidal.Strict.MonoidalIntMap a)
instance Control.Lens.At.At (Data.IntMap.Monoidal.Strict.MonoidalIntMap a)
instance Control.Lens.Each.Each (Data.IntMap.Monoidal.Strict.MonoidalIntMap a) (Data.IntMap.Monoidal.Strict.MonoidalIntMap b) a b
instance WithIndex.FunctorWithIndex GHC.Types.Int Data.IntMap.Monoidal.Strict.MonoidalIntMap
instance WithIndex.FoldableWithIndex GHC.Types.Int Data.IntMap.Monoidal.Strict.MonoidalIntMap
instance WithIndex.TraversableWithIndex GHC.Types.Int Data.IntMap.Monoidal.Strict.MonoidalIntMap
instance Control.Lens.Traversal.TraverseMin GHC.Types.Int Data.IntMap.Monoidal.Strict.MonoidalIntMap
instance Control.Lens.Traversal.TraverseMax GHC.Types.Int Data.IntMap.Monoidal.Strict.MonoidalIntMap
instance Control.Lens.Empty.AsEmpty (Data.IntMap.Monoidal.Strict.MonoidalIntMap a)
instance Control.Lens.Wrapped.Wrapped (Data.IntMap.Monoidal.Strict.MonoidalIntMap a)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.IntMap.Monoidal.Strict.MonoidalIntMap a)
instance GHC.Base.Semigroup a => GHC.Base.Monoid (Data.IntMap.Monoidal.Strict.MonoidalIntMap a)
instance Control.Newtype.Newtype (Data.IntMap.Monoidal.Strict.MonoidalIntMap a) (Data.IntMap.Internal.IntMap a)
instance GHC.Base.Semigroup a => GHC.Exts.IsList (Data.IntMap.Monoidal.Strict.MonoidalIntMap a)
instance Witherable.Witherable Data.IntMap.Monoidal.Strict.MonoidalIntMap


-- | This module provides a <a>Map</a> variant which uses the value's
--   <a>Monoid</a> instance to accumulate conflicting entries when merging
--   <tt>Map</tt>s.
--   
--   While some functions mirroring those of <a>Map</a> are provided here
--   for convenience, more specialized needs will likely want to use either
--   the <a>Newtype</a> or <a>Wrapped</a> instances to manipulate the
--   underlying <tt>Map</tt>.
module Data.Map.Monoidal

-- | A <tt>Map</tt> with monoidal accumulation
newtype MonoidalMap k a
MonoidalMap :: Map k a -> MonoidalMap k a
[getMonoidalMap] :: MonoidalMap k a -> Map k a

-- | <i>O(1)</i>. A map with a single element.
singleton :: k -> a -> MonoidalMap k a

-- | <i>O(1)</i>. The number of elements in the map.
size :: MonoidalMap k a -> Int

-- | <i>O(log n)</i>. Is the key a member of the map? See also
--   <a>notMember</a>.
member :: Ord k => k -> MonoidalMap k a -> Bool

-- | <i>O(log n)</i>. Is the key not a member of the map? See also
--   <a>member</a>.
notMember :: Ord k => k -> MonoidalMap k a -> Bool

-- | <i>O(log n)</i>. The expression <tt>(<a>findWithDefault</a> def k
--   map)</tt> returns the value at key <tt>k</tt> or returns default value
--   <tt>def</tt> when the key is not in the map.
findWithDefault :: Ord k => a -> k -> MonoidalMap k a -> a

-- | <i>O(n)</i>. Return all elements of the map and their keys
assocs :: MonoidalMap k a -> [(k, a)]

-- | <i>O(n)</i>. Return all elements of the map in the ascending order of
--   their keys. Subject to list fusion.
elems :: MonoidalMap k a -> [a]

-- | <i>O(n)</i>. Return all keys of the map in ascending order. Subject to
--   list fusion.
keys :: MonoidalMap k a -> [k]
(!?) :: forall k a. Ord k => MonoidalMap k a -> k -> Maybe a
infixl 9 !?
(!) :: forall k a. Ord k => MonoidalMap k a -> k -> a
infixl 9 !
(\\) :: forall k a b. Ord k => MonoidalMap k a -> MonoidalMap k b -> MonoidalMap k a
infixl 9 \\
adjust :: forall k a. Ord k => (a -> a) -> k -> MonoidalMap k a -> MonoidalMap k a
adjustWithKey :: forall k a. Ord k => (k -> a -> a) -> k -> MonoidalMap k a -> MonoidalMap k a
alter :: forall k a. Ord k => (Maybe a -> Maybe a) -> k -> MonoidalMap k a -> MonoidalMap k a

-- | <i>O(log n)</i>. Delete a key and its value from the map. When the key
--   is not a member of the map, the original map is returned.
delete :: Ord k => k -> MonoidalMap k a -> MonoidalMap k a
deleteAt :: forall k a. Int -> MonoidalMap k a -> MonoidalMap k a
take :: forall k a. Int -> MonoidalMap k a -> MonoidalMap k a
drop :: forall k a. Int -> MonoidalMap k a -> MonoidalMap k a
splitAt :: forall k a. Int -> MonoidalMap k a -> (MonoidalMap k a, MonoidalMap k a)
lookupMin :: forall k a. MonoidalMap k a -> Maybe (k, a)
lookupMax :: forall k a. MonoidalMap k a -> Maybe (k, a)
deleteFindMax :: forall k a. MonoidalMap k a -> ((k, a), MonoidalMap k a)
deleteFindMin :: forall k a. MonoidalMap k a -> ((k, a), MonoidalMap k a)
deleteMax :: forall k a. MonoidalMap k a -> MonoidalMap k a
deleteMin :: forall k a. MonoidalMap k a -> MonoidalMap k a
difference :: forall k a b. Ord k => MonoidalMap k a -> MonoidalMap k b -> MonoidalMap k a
differenceWith :: forall k a b. Ord k => (a -> b -> Maybe a) -> MonoidalMap k a -> MonoidalMap k b -> MonoidalMap k a
differenceWithKey :: forall k a b. Ord k => (k -> a -> b -> Maybe a) -> MonoidalMap k a -> MonoidalMap k b -> MonoidalMap k a
elemAt :: forall k a. Int -> MonoidalMap k a -> (k, a)
empty :: forall k a. MonoidalMap k a
filter :: forall k a. (a -> Bool) -> MonoidalMap k a -> MonoidalMap k a
filterWithKey :: forall k a. (k -> a -> Bool) -> MonoidalMap k a -> MonoidalMap k a
restrictKeys :: forall k a. Ord k => MonoidalMap k a -> Set k -> MonoidalMap k a
withoutKeys :: forall k a. Ord k => MonoidalMap k a -> Set k -> MonoidalMap k a
findIndex :: forall k a. Ord k => k -> MonoidalMap k a -> Int
findMax :: forall k a. MonoidalMap k a -> (k, a)
findMin :: forall k a. MonoidalMap k a -> (k, a)
foldMapWithKey :: forall k a m. Monoid m => (k -> a -> m) -> MonoidalMap k a -> m
foldl :: forall k a b. (a -> b -> a) -> a -> MonoidalMap k b -> a
foldl' :: forall k a b. (a -> b -> a) -> a -> MonoidalMap k b -> a
foldlWithKey :: forall k a b. (a -> k -> b -> a) -> a -> MonoidalMap k b -> a
foldlWithKey' :: forall k a b. (a -> k -> b -> a) -> a -> MonoidalMap k b -> a
foldr :: forall k a b. (a -> b -> b) -> b -> MonoidalMap k a -> b
foldr' :: forall k a b. (a -> b -> b) -> b -> MonoidalMap k a -> b
foldrWithKey :: forall k a b. (k -> a -> b -> b) -> b -> MonoidalMap k a -> b
foldrWithKey' :: forall k a b. (k -> a -> b -> b) -> b -> MonoidalMap k a -> b
fromAscList :: forall k a. Eq k => [(k, a)] -> MonoidalMap k a
fromAscListWith :: forall k a. Eq k => (a -> a -> a) -> [(k, a)] -> MonoidalMap k a
fromAscListWithKey :: forall k a. Eq k => (k -> a -> a -> a) -> [(k, a)] -> MonoidalMap k a
fromDistinctAscList :: forall k a. [(k, a)] -> MonoidalMap k a
fromDistinctList :: forall k a. Ord k => [(k, a)] -> MonoidalMap k a
fromDescList :: forall k a. Eq k => [(k, a)] -> MonoidalMap k a
fromDescListWith :: forall k a. Eq k => (a -> a -> a) -> [(k, a)] -> MonoidalMap k a
fromDescListWithKey :: forall k a. Eq k => (k -> a -> a -> a) -> [(k, a)] -> MonoidalMap k a
fromDistinctDescList :: forall k a. [(k, a)] -> MonoidalMap k a
fromList :: forall k a. Ord k => [(k, a)] -> MonoidalMap k a
fromListWith :: forall k a. Ord k => (a -> a -> a) -> [(k, a)] -> MonoidalMap k a
fromListWithKey :: forall k a. Ord k => (k -> a -> a -> a) -> [(k, a)] -> MonoidalMap k a
fromSet :: forall k a. (k -> a) -> Set k -> MonoidalMap k a
insert :: forall k a. Ord k => k -> a -> MonoidalMap k a -> MonoidalMap k a
insertLookupWithKey :: forall k a. Ord k => (k -> a -> a -> a) -> k -> a -> MonoidalMap k a -> (Maybe a, MonoidalMap k a)
insertWith :: forall k a. Ord k => (a -> a -> a) -> k -> a -> MonoidalMap k a -> MonoidalMap k a
insertWithKey :: forall k a. Ord k => (k -> a -> a -> a) -> k -> a -> MonoidalMap k a -> MonoidalMap k a
intersectionWith :: forall k a b c. Ord k => (a -> b -> c) -> MonoidalMap k a -> MonoidalMap k b -> MonoidalMap k c
intersectionWithKey :: forall k a b c. Ord k => (k -> a -> b -> c) -> MonoidalMap k a -> MonoidalMap k b -> MonoidalMap k c
isProperSubmapOf :: forall k a. (Ord k, Eq a) => MonoidalMap k a -> MonoidalMap k a -> Bool
isProperSubmapOfBy :: forall k a b. Ord k => (a -> b -> Bool) -> MonoidalMap k a -> MonoidalMap k b -> Bool
isSubmapOf :: forall k a. (Ord k, Eq a) => MonoidalMap k a -> MonoidalMap k a -> Bool
isSubmapOfBy :: forall k a b. Ord k => (a -> b -> Bool) -> MonoidalMap k a -> MonoidalMap k b -> Bool
keysSet :: forall k a. MonoidalMap k a -> Set k
lookup :: forall k a. Ord k => k -> MonoidalMap k a -> Maybe a
lookupGE :: forall k a. Ord k => k -> MonoidalMap k a -> Maybe (k, a)
lookupGT :: forall k a. Ord k => k -> MonoidalMap k a -> Maybe (k, a)
lookupIndex :: forall k a. Ord k => k -> MonoidalMap k a -> Maybe Int
lookupLE :: forall k a. Ord k => k -> MonoidalMap k a -> Maybe (k, a)
lookupLT :: forall k a. Ord k => k -> MonoidalMap k a -> Maybe (k, a)
map :: (a -> b) -> MonoidalMap k a -> MonoidalMap k b
mapAccum :: forall k a b c. (a -> b -> (a, c)) -> a -> MonoidalMap k b -> (a, MonoidalMap k c)
mapAccumRWithKey :: forall k a b c. (a -> k -> b -> (a, c)) -> a -> MonoidalMap k b -> (a, MonoidalMap k c)
mapAccumWithKey :: forall k a b c. (a -> k -> b -> (a, c)) -> a -> MonoidalMap k b -> (a, MonoidalMap k c)
mapEither :: forall k a b c. (a -> Either b c) -> MonoidalMap k a -> (MonoidalMap k b, MonoidalMap k c)
mapEitherWithKey :: forall k a b c. (k -> a -> Either b c) -> MonoidalMap k a -> (MonoidalMap k b, MonoidalMap k c)
mapKeys :: forall k1 k2 a. Ord k2 => (k1 -> k2) -> MonoidalMap k1 a -> MonoidalMap k2 a

-- | <i>O(n)</i>. <tt><a>mapKeysMonotonic</a> f s == <a>mapKeys</a> f
--   s</tt>, but works only when <tt>f</tt> is strictly increasing (both
--   monotonic and injective). That is, for any values <tt>x</tt> and
--   <tt>y</tt>, if <tt>x</tt> &lt; <tt>y</tt> then <tt>f x</tt> &lt; <tt>f
--   y</tt> and <tt>f</tt> is injective (i.e. it never maps two input keys
--   to the same output key). <i>The precondition is not checked.</i>
--   Semi-formally, we have:
--   
--   <pre>
--   and [x &lt; y ==&gt; f x &lt; f y | x &lt;- ls, y &lt;- ls]
--                       ==&gt; mapKeysMonotonic f s == mapKeys f s
--       where ls = keys s
--   </pre>
--   
--   This means that <tt>f</tt> maps distinct original keys to distinct
--   resulting keys. This function has better performance than
--   <a>mapKeys</a>.
--   
--   <pre>
--   mapKeysMonotonic (\ k -&gt; k * 2) (fromList [(5,"a"), (3,"b")]) == fromList [(6, "b"), (10, "a")]
--   valid (mapKeysMonotonic (\ k -&gt; k * 2) (fromList [(5,"a"), (3,"b")])) == True
--   valid (mapKeysMonotonic (\ _ -&gt; 1)     (fromList [(5,"a"), (3,"b")])) == False
--   </pre>
mapKeysMonotonic :: forall k1 k2 a. (k1 -> k2) -> MonoidalMap k1 a -> MonoidalMap k2 a
mapKeysWith :: forall k1 k2 a. Ord k2 => (a -> a -> a) -> (k1 -> k2) -> MonoidalMap k1 a -> MonoidalMap k2 a
mapMaybe :: forall k a b. (a -> Maybe b) -> MonoidalMap k a -> MonoidalMap k b
mapMaybeWithKey :: forall k a b. (k -> a -> Maybe b) -> MonoidalMap k a -> MonoidalMap k b
mapWithKey :: forall k a b. (k -> a -> b) -> MonoidalMap k a -> MonoidalMap k b
maxView :: forall k a. MonoidalMap k a -> Maybe (a, MonoidalMap k a)
maxViewWithKey :: forall k a. MonoidalMap k a -> Maybe ((k, a), MonoidalMap k a)
mergeWithKey :: forall k a b c. Ord k => (k -> a -> b -> Maybe c) -> (MonoidalMap k a -> MonoidalMap k c) -> (MonoidalMap k b -> MonoidalMap k c) -> MonoidalMap k a -> MonoidalMap k b -> MonoidalMap k c
minView :: forall k a. MonoidalMap k a -> Maybe (a, MonoidalMap k a)
minViewWithKey :: forall k a. MonoidalMap k a -> Maybe ((k, a), MonoidalMap k a)
null :: forall k a. MonoidalMap k a -> Bool
partition :: forall k a. (a -> Bool) -> MonoidalMap k a -> (MonoidalMap k a, MonoidalMap k a)
partitionWithKey :: forall k a. (k -> a -> Bool) -> MonoidalMap k a -> (MonoidalMap k a, MonoidalMap k a)
takeWhileAntitone :: forall k a. (k -> Bool) -> MonoidalMap k a -> MonoidalMap k a
dropWhileAntitone :: forall k a. (k -> Bool) -> MonoidalMap k a -> MonoidalMap k a
spanAntitone :: forall k a. (k -> Bool) -> MonoidalMap k a -> (MonoidalMap k a, MonoidalMap k a)
split :: forall k a. Ord k => k -> MonoidalMap k a -> (MonoidalMap k a, MonoidalMap k a)
splitLookup :: forall k a. Ord k => k -> MonoidalMap k a -> (MonoidalMap k a, Maybe a, MonoidalMap k a)
splitRoot :: forall k a. MonoidalMap k a -> [MonoidalMap k a]
toAscList :: forall k a. MonoidalMap k a -> [(k, a)]
toDescList :: forall k a. MonoidalMap k a -> [(k, a)]
toList :: forall k a. MonoidalMap k a -> [(k, a)]
traverseWithKey :: Applicative t => (k -> a -> t b) -> MonoidalMap k a -> t (MonoidalMap k b)
traverseMaybeWithKey :: forall f k a b. Applicative f => (k -> a -> f (Maybe b)) -> MonoidalMap k a -> f (MonoidalMap k b)
unionWith :: forall k a. Ord k => (a -> a -> a) -> MonoidalMap k a -> MonoidalMap k a -> MonoidalMap k a
unionWithKey :: forall k a. Ord k => (k -> a -> a -> a) -> MonoidalMap k a -> MonoidalMap k a -> MonoidalMap k a
unionsWith :: forall k a. Ord k => (a -> a -> a) -> [MonoidalMap k a] -> MonoidalMap k a
update :: forall k a. Ord k => (a -> Maybe a) -> k -> MonoidalMap k a -> MonoidalMap k a
updateAt :: forall k a. (k -> a -> Maybe a) -> Int -> MonoidalMap k a -> MonoidalMap k a
updateLookupWithKey :: forall k a. Ord k => (k -> a -> Maybe a) -> k -> MonoidalMap k a -> (Maybe a, MonoidalMap k a)
updateMax :: forall k a. (a -> Maybe a) -> MonoidalMap k a -> MonoidalMap k a
updateMaxWithKey :: forall k a. (k -> a -> Maybe a) -> MonoidalMap k a -> MonoidalMap k a
updateMin :: forall k a. (a -> Maybe a) -> MonoidalMap k a -> MonoidalMap k a
updateMinWithKey :: forall k a. (k -> a -> Maybe a) -> MonoidalMap k a -> MonoidalMap k a
updateWithKey :: forall k a. Ord k => (k -> a -> Maybe a) -> k -> MonoidalMap k a -> MonoidalMap k a
valid :: forall k a. Ord k => MonoidalMap k a -> Bool
instance Witherable.Filterable (Data.Map.Monoidal.MonoidalMap k)
instance GHC.Classes.Ord k => Data.Semialign.Internal.Zip (Data.Map.Monoidal.MonoidalMap k)
instance GHC.Classes.Ord k => Data.Semialign.Internal.Unalign (Data.Map.Monoidal.MonoidalMap k)
instance GHC.Classes.Ord k => Data.Semialign.Internal.Semialign (Data.Map.Monoidal.MonoidalMap k)
instance GHC.Classes.Ord k => Data.Semialign.Internal.Align (Data.Map.Monoidal.MonoidalMap k)
instance (Data.Data.Data k, Data.Data.Data a, GHC.Classes.Ord k) => Data.Data.Data (Data.Map.Monoidal.MonoidalMap k a)
instance Data.Aeson.Types.ToJSON.ToJSONKey k => Data.Aeson.Types.ToJSON.ToJSON1 (Data.Map.Monoidal.MonoidalMap k)
instance (Data.Aeson.Types.FromJSON.FromJSONKey k, GHC.Classes.Ord k) => Data.Aeson.Types.FromJSON.FromJSON1 (Data.Map.Monoidal.MonoidalMap k)
instance (Data.Aeson.Types.ToJSON.ToJSON a, Data.Aeson.Types.ToJSON.ToJSONKey k) => Data.Aeson.Types.ToJSON.ToJSON (Data.Map.Monoidal.MonoidalMap k a)
instance (Data.Aeson.Types.FromJSON.FromJSONKey k, GHC.Classes.Ord k, Data.Aeson.Types.FromJSON.FromJSON a) => Data.Aeson.Types.FromJSON.FromJSON (Data.Map.Monoidal.MonoidalMap k a)
instance Data.Traversable.Traversable (Data.Map.Monoidal.MonoidalMap k)
instance Data.Foldable.Foldable (Data.Map.Monoidal.MonoidalMap k)
instance (Control.DeepSeq.NFData k, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Data.Map.Monoidal.MonoidalMap k a)
instance (GHC.Classes.Ord k, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Map.Monoidal.MonoidalMap k a)
instance (GHC.Classes.Eq k, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Map.Monoidal.MonoidalMap k a)
instance GHC.Base.Functor (Data.Map.Monoidal.MonoidalMap k)
instance (GHC.Classes.Ord k, GHC.Read.Read k, GHC.Read.Read a) => GHC.Read.Read (Data.Map.Monoidal.MonoidalMap k a)
instance (GHC.Show.Show k, GHC.Show.Show a) => GHC.Show.Show (Data.Map.Monoidal.MonoidalMap k a)
instance GHC.Classes.Ord k => Data.Functor.Classes.Eq1 (Data.Map.Monoidal.MonoidalMap k)
instance GHC.Classes.Ord k => Data.Functor.Classes.Ord1 (Data.Map.Monoidal.MonoidalMap k)
instance GHC.Show.Show k => Data.Functor.Classes.Show1 (Data.Map.Monoidal.MonoidalMap k)
instance GHC.Classes.Ord k => Control.Lens.At.Ixed (Data.Map.Monoidal.MonoidalMap k a)
instance GHC.Classes.Ord k => Control.Lens.At.At (Data.Map.Monoidal.MonoidalMap k a)
instance Control.Lens.Each.Each (Data.Map.Monoidal.MonoidalMap k a) (Data.Map.Monoidal.MonoidalMap k b) a b
instance WithIndex.FunctorWithIndex k (Data.Map.Monoidal.MonoidalMap k)
instance WithIndex.FoldableWithIndex k (Data.Map.Monoidal.MonoidalMap k)
instance WithIndex.TraversableWithIndex k (Data.Map.Monoidal.MonoidalMap k)
instance GHC.Classes.Ord k => Control.Lens.Traversal.TraverseMin k (Data.Map.Monoidal.MonoidalMap k)
instance GHC.Classes.Ord k => Control.Lens.Traversal.TraverseMax k (Data.Map.Monoidal.MonoidalMap k)
instance Control.Lens.Empty.AsEmpty (Data.Map.Monoidal.MonoidalMap k a)
instance Control.Lens.Wrapped.Wrapped (Data.Map.Monoidal.MonoidalMap k a)
instance GHC.Classes.Ord k => Control.Lens.Wrapped.Rewrapped (Data.Map.Internal.Map k a) (Data.Map.Monoidal.MonoidalMap k a)
instance GHC.Classes.Ord k => Control.Lens.Wrapped.Rewrapped (Data.Map.Monoidal.MonoidalMap k a) (Data.Map.Internal.Map k a)
instance (GHC.Classes.Ord k, GHC.Base.Semigroup a) => GHC.Base.Semigroup (Data.Map.Monoidal.MonoidalMap k a)
instance (GHC.Classes.Ord k, GHC.Base.Semigroup a) => GHC.Base.Monoid (Data.Map.Monoidal.MonoidalMap k a)
instance Control.Newtype.Newtype (Data.Map.Monoidal.MonoidalMap k a) (Data.Map.Internal.Map k a)
instance (GHC.Classes.Ord k, GHC.Base.Semigroup a) => GHC.Exts.IsList (Data.Map.Monoidal.MonoidalMap k a)
instance GHC.Classes.Ord k => Witherable.Witherable (Data.Map.Monoidal.MonoidalMap k)


-- | This module provides a <a>Map</a> variant which uses the value's
--   <a>Monoid</a> instance to accumulate conflicting entries when merging
--   <tt>Map</tt>s.
--   
--   While some functions mirroring those of <a>Map</a> are provided here
--   for convenience, more specialized needs will likely want to use either
--   the <a>Newtype</a> or <a>Wrapped</a> instances to manipulate the
--   underlying <tt>Map</tt>.
module Data.Map.Monoidal.Strict

-- | A <tt>Map</tt> with monoidal accumulation
newtype MonoidalMap k a
MonoidalMap :: Map k a -> MonoidalMap k a
[getMonoidalMap] :: MonoidalMap k a -> Map k a

-- | <i>O(1)</i>. A map with a single element.
singleton :: k -> a -> MonoidalMap k a

-- | <i>O(1)</i>. The number of elements in the map.
size :: MonoidalMap k a -> Int

-- | <i>O(log n)</i>. Is the key a member of the map? See also
--   <a>notMember</a>.
member :: Ord k => k -> MonoidalMap k a -> Bool

-- | <i>O(log n)</i>. Is the key not a member of the map? See also
--   <a>member</a>.
notMember :: Ord k => k -> MonoidalMap k a -> Bool

-- | <i>O(log n)</i>. The expression <tt>(<a>findWithDefault</a> def k
--   map)</tt> returns the value at key <tt>k</tt> or returns default value
--   <tt>def</tt> when the key is not in the map.
findWithDefault :: Ord k => a -> k -> MonoidalMap k a -> a

-- | <i>O(n)</i>. Return all elements of the map and their keys
assocs :: MonoidalMap k a -> [(k, a)]

-- | <i>O(n)</i>. Return all elements of the map in the ascending order of
--   their keys. Subject to list fusion.
elems :: MonoidalMap k a -> [a]

-- | <i>O(n)</i>. Return all keys of the map in ascending order. Subject to
--   list fusion.
keys :: MonoidalMap k a -> [k]
(!?) :: forall k a. Ord k => MonoidalMap k a -> k -> Maybe a
infixl 9 !?
(!) :: forall k a. Ord k => MonoidalMap k a -> k -> a
infixl 9 !
(\\) :: forall k a b. Ord k => MonoidalMap k a -> MonoidalMap k b -> MonoidalMap k a
infixl 9 \\
adjust :: forall k a. Ord k => (a -> a) -> k -> MonoidalMap k a -> MonoidalMap k a
adjustWithKey :: forall k a. Ord k => (k -> a -> a) -> k -> MonoidalMap k a -> MonoidalMap k a
alter :: forall k a. Ord k => (Maybe a -> Maybe a) -> k -> MonoidalMap k a -> MonoidalMap k a

-- | <i>O(log n)</i>. Delete a key and its value from the map. When the key
--   is not a member of the map, the original map is returned.
delete :: Ord k => k -> MonoidalMap k a -> MonoidalMap k a
deleteAt :: forall k a. Int -> MonoidalMap k a -> MonoidalMap k a
take :: forall k a. Int -> MonoidalMap k a -> MonoidalMap k a
drop :: forall k a. Int -> MonoidalMap k a -> MonoidalMap k a
splitAt :: forall k a. Int -> MonoidalMap k a -> (MonoidalMap k a, MonoidalMap k a)
lookupMin :: forall k a. MonoidalMap k a -> Maybe (k, a)
lookupMax :: forall k a. MonoidalMap k a -> Maybe (k, a)
deleteFindMax :: forall k a. MonoidalMap k a -> ((k, a), MonoidalMap k a)
deleteFindMin :: forall k a. MonoidalMap k a -> ((k, a), MonoidalMap k a)
deleteMax :: forall k a. MonoidalMap k a -> MonoidalMap k a
deleteMin :: forall k a. MonoidalMap k a -> MonoidalMap k a
difference :: forall k a b. Ord k => MonoidalMap k a -> MonoidalMap k b -> MonoidalMap k a
differenceWith :: forall k a b. Ord k => (a -> b -> Maybe a) -> MonoidalMap k a -> MonoidalMap k b -> MonoidalMap k a
differenceWithKey :: forall k a b. Ord k => (k -> a -> b -> Maybe a) -> MonoidalMap k a -> MonoidalMap k b -> MonoidalMap k a
elemAt :: forall k a. Int -> MonoidalMap k a -> (k, a)
empty :: forall k a. MonoidalMap k a
filter :: forall k a. (a -> Bool) -> MonoidalMap k a -> MonoidalMap k a
filterWithKey :: forall k a. (k -> a -> Bool) -> MonoidalMap k a -> MonoidalMap k a
restrictKeys :: forall k a. Ord k => MonoidalMap k a -> Set k -> MonoidalMap k a
withoutKeys :: forall k a. Ord k => MonoidalMap k a -> Set k -> MonoidalMap k a
findIndex :: forall k a. Ord k => k -> MonoidalMap k a -> Int
findMax :: forall k a. MonoidalMap k a -> (k, a)
findMin :: forall k a. MonoidalMap k a -> (k, a)
foldMapWithKey :: forall k a m. Monoid m => (k -> a -> m) -> MonoidalMap k a -> m
foldl :: forall k a b. (a -> b -> a) -> a -> MonoidalMap k b -> a
foldl' :: forall k a b. (a -> b -> a) -> a -> MonoidalMap k b -> a
foldlWithKey :: forall k a b. (a -> k -> b -> a) -> a -> MonoidalMap k b -> a
foldlWithKey' :: forall k a b. (a -> k -> b -> a) -> a -> MonoidalMap k b -> a
foldr :: forall k a b. (a -> b -> b) -> b -> MonoidalMap k a -> b
foldr' :: forall k a b. (a -> b -> b) -> b -> MonoidalMap k a -> b
foldrWithKey :: forall k a b. (k -> a -> b -> b) -> b -> MonoidalMap k a -> b
foldrWithKey' :: forall k a b. (k -> a -> b -> b) -> b -> MonoidalMap k a -> b
fromAscList :: forall k a. Eq k => [(k, a)] -> MonoidalMap k a
fromAscListWith :: forall k a. Eq k => (a -> a -> a) -> [(k, a)] -> MonoidalMap k a
fromAscListWithKey :: forall k a. Eq k => (k -> a -> a -> a) -> [(k, a)] -> MonoidalMap k a
fromDistinctAscList :: forall k a. [(k, a)] -> MonoidalMap k a
fromDistinctList :: forall k a. Ord k => [(k, a)] -> MonoidalMap k a
fromDescList :: forall k a. Eq k => [(k, a)] -> MonoidalMap k a
fromDescListWith :: forall k a. Eq k => (a -> a -> a) -> [(k, a)] -> MonoidalMap k a
fromDescListWithKey :: forall k a. Eq k => (k -> a -> a -> a) -> [(k, a)] -> MonoidalMap k a
fromDistinctDescList :: forall k a. [(k, a)] -> MonoidalMap k a
fromList :: forall k a. Ord k => [(k, a)] -> MonoidalMap k a
fromListWith :: forall k a. Ord k => (a -> a -> a) -> [(k, a)] -> MonoidalMap k a
fromListWithKey :: forall k a. Ord k => (k -> a -> a -> a) -> [(k, a)] -> MonoidalMap k a
fromSet :: forall k a. (k -> a) -> Set k -> MonoidalMap k a
insert :: forall k a. Ord k => k -> a -> MonoidalMap k a -> MonoidalMap k a
insertLookupWithKey :: forall k a. Ord k => (k -> a -> a -> a) -> k -> a -> MonoidalMap k a -> (Maybe a, MonoidalMap k a)
insertWith :: forall k a. Ord k => (a -> a -> a) -> k -> a -> MonoidalMap k a -> MonoidalMap k a
insertWithKey :: forall k a. Ord k => (k -> a -> a -> a) -> k -> a -> MonoidalMap k a -> MonoidalMap k a
intersectionWith :: forall k a b c. Ord k => (a -> b -> c) -> MonoidalMap k a -> MonoidalMap k b -> MonoidalMap k c
intersectionWithKey :: forall k a b c. Ord k => (k -> a -> b -> c) -> MonoidalMap k a -> MonoidalMap k b -> MonoidalMap k c
isProperSubmapOf :: forall k a. (Ord k, Eq a) => MonoidalMap k a -> MonoidalMap k a -> Bool
isProperSubmapOfBy :: forall k a b. Ord k => (a -> b -> Bool) -> MonoidalMap k a -> MonoidalMap k b -> Bool
isSubmapOf :: forall k a. (Ord k, Eq a) => MonoidalMap k a -> MonoidalMap k a -> Bool
isSubmapOfBy :: forall k a b. Ord k => (a -> b -> Bool) -> MonoidalMap k a -> MonoidalMap k b -> Bool
keysSet :: forall k a. MonoidalMap k a -> Set k
lookup :: forall k a. Ord k => k -> MonoidalMap k a -> Maybe a
lookupGE :: forall k a. Ord k => k -> MonoidalMap k a -> Maybe (k, a)
lookupGT :: forall k a. Ord k => k -> MonoidalMap k a -> Maybe (k, a)
lookupIndex :: forall k a. Ord k => k -> MonoidalMap k a -> Maybe Int
lookupLE :: forall k a. Ord k => k -> MonoidalMap k a -> Maybe (k, a)
lookupLT :: forall k a. Ord k => k -> MonoidalMap k a -> Maybe (k, a)
map :: (a -> b) -> MonoidalMap k a -> MonoidalMap k b
mapAccum :: forall k a b c. (a -> b -> (a, c)) -> a -> MonoidalMap k b -> (a, MonoidalMap k c)
mapAccumRWithKey :: forall k a b c. (a -> k -> b -> (a, c)) -> a -> MonoidalMap k b -> (a, MonoidalMap k c)
mapAccumWithKey :: forall k a b c. (a -> k -> b -> (a, c)) -> a -> MonoidalMap k b -> (a, MonoidalMap k c)
mapEither :: forall k a b c. (a -> Either b c) -> MonoidalMap k a -> (MonoidalMap k b, MonoidalMap k c)
mapEitherWithKey :: forall k a b c. (k -> a -> Either b c) -> MonoidalMap k a -> (MonoidalMap k b, MonoidalMap k c)
mapKeys :: forall k1 k2 a. Ord k2 => (k1 -> k2) -> MonoidalMap k1 a -> MonoidalMap k2 a

-- | <i>O(n)</i>. <tt><a>mapKeysMonotonic</a> f s == <a>mapKeys</a> f
--   s</tt>, but works only when <tt>f</tt> is strictly increasing (both
--   monotonic and injective). That is, for any values <tt>x</tt> and
--   <tt>y</tt>, if <tt>x</tt> &lt; <tt>y</tt> then <tt>f x</tt> &lt; <tt>f
--   y</tt> and <tt>f</tt> is injective (i.e. it never maps two input keys
--   to the same output key). <i>The precondition is not checked.</i>
--   Semi-formally, we have:
--   
--   <pre>
--   and [x &lt; y ==&gt; f x &lt; f y | x &lt;- ls, y &lt;- ls]
--                       ==&gt; mapKeysMonotonic f s == mapKeys f s
--       where ls = keys s
--   </pre>
--   
--   This means that <tt>f</tt> maps distinct original keys to distinct
--   resulting keys. This function has better performance than
--   <a>mapKeys</a>.
--   
--   <pre>
--   mapKeysMonotonic (\ k -&gt; k * 2) (fromList [(5,"a"), (3,"b")]) == fromList [(6, "b"), (10, "a")]
--   valid (mapKeysMonotonic (\ k -&gt; k * 2) (fromList [(5,"a"), (3,"b")])) == True
--   valid (mapKeysMonotonic (\ _ -&gt; 1)     (fromList [(5,"a"), (3,"b")])) == False
--   </pre>
mapKeysMonotonic :: forall k1 k2 a. (k1 -> k2) -> MonoidalMap k1 a -> MonoidalMap k2 a
mapKeysWith :: forall k1 k2 a. Ord k2 => (a -> a -> a) -> (k1 -> k2) -> MonoidalMap k1 a -> MonoidalMap k2 a
mapMaybe :: forall k a b. (a -> Maybe b) -> MonoidalMap k a -> MonoidalMap k b
mapMaybeWithKey :: forall k a b. (k -> a -> Maybe b) -> MonoidalMap k a -> MonoidalMap k b
mapWithKey :: forall k a b. (k -> a -> b) -> MonoidalMap k a -> MonoidalMap k b
maxView :: forall k a. MonoidalMap k a -> Maybe (a, MonoidalMap k a)
maxViewWithKey :: forall k a. MonoidalMap k a -> Maybe ((k, a), MonoidalMap k a)
mergeWithKey :: forall k a b c. Ord k => (k -> a -> b -> Maybe c) -> (MonoidalMap k a -> MonoidalMap k c) -> (MonoidalMap k b -> MonoidalMap k c) -> MonoidalMap k a -> MonoidalMap k b -> MonoidalMap k c
minView :: forall k a. MonoidalMap k a -> Maybe (a, MonoidalMap k a)
minViewWithKey :: forall k a. MonoidalMap k a -> Maybe ((k, a), MonoidalMap k a)
null :: forall k a. MonoidalMap k a -> Bool
partition :: forall k a. (a -> Bool) -> MonoidalMap k a -> (MonoidalMap k a, MonoidalMap k a)
partitionWithKey :: forall k a. (k -> a -> Bool) -> MonoidalMap k a -> (MonoidalMap k a, MonoidalMap k a)
takeWhileAntitone :: forall k a. (k -> Bool) -> MonoidalMap k a -> MonoidalMap k a
dropWhileAntitone :: forall k a. (k -> Bool) -> MonoidalMap k a -> MonoidalMap k a
spanAntitone :: forall k a. (k -> Bool) -> MonoidalMap k a -> (MonoidalMap k a, MonoidalMap k a)
split :: forall k a. Ord k => k -> MonoidalMap k a -> (MonoidalMap k a, MonoidalMap k a)
splitLookup :: forall k a. Ord k => k -> MonoidalMap k a -> (MonoidalMap k a, Maybe a, MonoidalMap k a)
splitRoot :: forall k a. MonoidalMap k a -> [MonoidalMap k a]
toAscList :: forall k a. MonoidalMap k a -> [(k, a)]
toDescList :: forall k a. MonoidalMap k a -> [(k, a)]
toList :: forall k a. MonoidalMap k a -> [(k, a)]
traverseWithKey :: Applicative t => (k -> a -> t b) -> MonoidalMap k a -> t (MonoidalMap k b)
traverseMaybeWithKey :: forall f k a b. Applicative f => (k -> a -> f (Maybe b)) -> MonoidalMap k a -> f (MonoidalMap k b)
unionWith :: forall k a. Ord k => (a -> a -> a) -> MonoidalMap k a -> MonoidalMap k a -> MonoidalMap k a
unionWithKey :: forall k a. Ord k => (k -> a -> a -> a) -> MonoidalMap k a -> MonoidalMap k a -> MonoidalMap k a
unionsWith :: forall k a. Ord k => (a -> a -> a) -> [MonoidalMap k a] -> MonoidalMap k a
update :: forall k a. Ord k => (a -> Maybe a) -> k -> MonoidalMap k a -> MonoidalMap k a
updateAt :: forall k a. (k -> a -> Maybe a) -> Int -> MonoidalMap k a -> MonoidalMap k a
updateLookupWithKey :: forall k a. Ord k => (k -> a -> Maybe a) -> k -> MonoidalMap k a -> (Maybe a, MonoidalMap k a)
updateMax :: forall k a. (a -> Maybe a) -> MonoidalMap k a -> MonoidalMap k a
updateMaxWithKey :: forall k a. (k -> a -> Maybe a) -> MonoidalMap k a -> MonoidalMap k a
updateMin :: forall k a. (a -> Maybe a) -> MonoidalMap k a -> MonoidalMap k a
updateMinWithKey :: forall k a. (k -> a -> Maybe a) -> MonoidalMap k a -> MonoidalMap k a
updateWithKey :: forall k a. Ord k => (k -> a -> Maybe a) -> k -> MonoidalMap k a -> MonoidalMap k a
valid :: forall k a. Ord k => MonoidalMap k a -> Bool
instance Witherable.Filterable (Data.Map.Monoidal.Strict.MonoidalMap k)
instance GHC.Classes.Ord k => Data.Semialign.Internal.Zip (Data.Map.Monoidal.Strict.MonoidalMap k)
instance GHC.Classes.Ord k => Data.Semialign.Internal.Unalign (Data.Map.Monoidal.Strict.MonoidalMap k)
instance GHC.Classes.Ord k => Data.Semialign.Internal.Semialign (Data.Map.Monoidal.Strict.MonoidalMap k)
instance GHC.Classes.Ord k => Data.Semialign.Internal.Align (Data.Map.Monoidal.Strict.MonoidalMap k)
instance (Data.Data.Data k, Data.Data.Data a, GHC.Classes.Ord k) => Data.Data.Data (Data.Map.Monoidal.Strict.MonoidalMap k a)
instance Data.Aeson.Types.ToJSON.ToJSONKey k => Data.Aeson.Types.ToJSON.ToJSON1 (Data.Map.Monoidal.Strict.MonoidalMap k)
instance (Data.Aeson.Types.FromJSON.FromJSONKey k, GHC.Classes.Ord k) => Data.Aeson.Types.FromJSON.FromJSON1 (Data.Map.Monoidal.Strict.MonoidalMap k)
instance (Data.Aeson.Types.ToJSON.ToJSON a, Data.Aeson.Types.ToJSON.ToJSONKey k) => Data.Aeson.Types.ToJSON.ToJSON (Data.Map.Monoidal.Strict.MonoidalMap k a)
instance (Data.Aeson.Types.FromJSON.FromJSONKey k, GHC.Classes.Ord k, Data.Aeson.Types.FromJSON.FromJSON a) => Data.Aeson.Types.FromJSON.FromJSON (Data.Map.Monoidal.Strict.MonoidalMap k a)
instance Data.Traversable.Traversable (Data.Map.Monoidal.Strict.MonoidalMap k)
instance Data.Foldable.Foldable (Data.Map.Monoidal.Strict.MonoidalMap k)
instance (Control.DeepSeq.NFData k, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Data.Map.Monoidal.Strict.MonoidalMap k a)
instance (GHC.Classes.Ord k, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Map.Monoidal.Strict.MonoidalMap k a)
instance (GHC.Classes.Eq k, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Map.Monoidal.Strict.MonoidalMap k a)
instance GHC.Base.Functor (Data.Map.Monoidal.Strict.MonoidalMap k)
instance (GHC.Classes.Ord k, GHC.Read.Read k, GHC.Read.Read a) => GHC.Read.Read (Data.Map.Monoidal.Strict.MonoidalMap k a)
instance (GHC.Show.Show k, GHC.Show.Show a) => GHC.Show.Show (Data.Map.Monoidal.Strict.MonoidalMap k a)
instance GHC.Classes.Ord k => Data.Functor.Classes.Eq1 (Data.Map.Monoidal.Strict.MonoidalMap k)
instance GHC.Classes.Ord k => Data.Functor.Classes.Ord1 (Data.Map.Monoidal.Strict.MonoidalMap k)
instance GHC.Show.Show k => Data.Functor.Classes.Show1 (Data.Map.Monoidal.Strict.MonoidalMap k)
instance GHC.Classes.Ord k => Control.Lens.At.Ixed (Data.Map.Monoidal.Strict.MonoidalMap k a)
instance GHC.Classes.Ord k => Control.Lens.At.At (Data.Map.Monoidal.Strict.MonoidalMap k a)
instance Control.Lens.Each.Each (Data.Map.Monoidal.Strict.MonoidalMap k a) (Data.Map.Monoidal.Strict.MonoidalMap k b) a b
instance WithIndex.FunctorWithIndex k (Data.Map.Monoidal.Strict.MonoidalMap k)
instance WithIndex.FoldableWithIndex k (Data.Map.Monoidal.Strict.MonoidalMap k)
instance WithIndex.TraversableWithIndex k (Data.Map.Monoidal.Strict.MonoidalMap k)
instance GHC.Classes.Ord k => Control.Lens.Traversal.TraverseMin k (Data.Map.Monoidal.Strict.MonoidalMap k)
instance GHC.Classes.Ord k => Control.Lens.Traversal.TraverseMax k (Data.Map.Monoidal.Strict.MonoidalMap k)
instance Control.Lens.Empty.AsEmpty (Data.Map.Monoidal.Strict.MonoidalMap k a)
instance Control.Lens.Wrapped.Wrapped (Data.Map.Monoidal.Strict.MonoidalMap k a)
instance GHC.Classes.Ord k => Control.Lens.Wrapped.Rewrapped (Data.Map.Internal.Map k a) (Data.Map.Monoidal.Strict.MonoidalMap k a)
instance GHC.Classes.Ord k => Control.Lens.Wrapped.Rewrapped (Data.Map.Monoidal.Strict.MonoidalMap k a) (Data.Map.Internal.Map k a)
instance (GHC.Classes.Ord k, GHC.Base.Semigroup a) => GHC.Base.Semigroup (Data.Map.Monoidal.Strict.MonoidalMap k a)
instance (GHC.Classes.Ord k, GHC.Base.Semigroup a) => GHC.Base.Monoid (Data.Map.Monoidal.Strict.MonoidalMap k a)
instance Control.Newtype.Newtype (Data.Map.Monoidal.Strict.MonoidalMap k a) (Data.Map.Internal.Map k a)
instance (GHC.Classes.Ord k, GHC.Base.Semigroup a) => GHC.Exts.IsList (Data.Map.Monoidal.Strict.MonoidalMap k a)
instance GHC.Classes.Ord k => Witherable.Witherable (Data.Map.Monoidal.Strict.MonoidalMap k)
