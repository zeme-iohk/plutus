

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6.7.4. Pattern synonyms &mdash; Glasgow Haskell Compiler 9.2.5 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.5 User&#39;s Guide"
          href="../_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6.8. Class and instances declarations" href="typeclasses.html" />
    <link rel="prev" title="6.7.3. n+k patterns" href="nk_patterns.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="../runghc.html">4. Using runghc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">5. Using GHC</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../exts.html">6. Language extensions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">6.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="syntax.html">6.2. Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="import_export.html">6.3. Import and export</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">6.4. Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="records.html">6.5. Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="deriving.html">6.6. Deriving mechanism</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="patterns.html">6.7. Patterns</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="pattern_guards.html">6.7.1. Pattern guards</a></li>
<li class="toctree-l3"><a class="reference internal" href="view_patterns.html">6.7.2. View patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="nk_patterns.html">6.7.3. n+k patterns</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">6.7.4. Pattern synonyms</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#record-pattern-synonyms">6.7.4.1. Record Pattern Synonyms</a></li>
<li class="toctree-l4"><a class="reference internal" href="#syntax-and-scoping-of-pattern-synonyms">6.7.4.2. Syntax and scoping of pattern synonyms</a></li>
<li class="toctree-l4"><a class="reference internal" href="#import-and-export-of-pattern-synonyms">6.7.4.3. Import and export of pattern synonyms</a></li>
<li class="toctree-l4"><a class="reference internal" href="#typing-of-pattern-synonyms">6.7.4.4. Typing of pattern synonyms</a></li>
<li class="toctree-l4"><a class="reference internal" href="#matching-of-pattern-synonyms">6.7.4.5. Matching of pattern synonyms</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pragmas-for-pattern-synonyms">6.7.4.6. Pragmas for pattern synonyms</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="typeclasses.html">6.8. Class and instances declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="literals.html">6.9. Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="constraints.html">6.10. Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="type_signatures.html">6.11. Type signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="bindings.html">6.12. Bindings and generalisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="template_haskell.html">6.13. Template Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="strict.html">6.14. Bang patterns and Strict Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel.html">6.15. Parallel and Concurrent</a></li>
<li class="toctree-l2"><a class="reference internal" href="primitives.html">6.16. Unboxed types and primitive operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffi.html">6.17. Foreign function interface (FFI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="safe_haskell.html">6.18. Safe Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc.html">6.19. Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="pragmas.html">6.20. Pragmas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../exts.html"><span class="section-number">6. </span>Language extensions</a> &raquo;</li>
        
          <li><a href="patterns.html"><span class="section-number">6.7. </span>Patterns</a> &raquo;</li>
        
      <li><span class="section-number">6.7.4. </span>Pattern synonyms</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/exts/pattern_synonyms.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="pattern-synonyms">
<span id="id1"></span><h1><span class="section-number">6.7.4. </span>Pattern synonyms<a class="headerlink" href="#pattern-synonyms" title="Permalink to this heading">¶</a></h1>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-PatternSynonyms">
<span id="ghc-flag--XPatternSynonyms"></span><span id="extension-NoPatternSynonyms"></span><span class="sig-name descname"><span class="pre">PatternSynonyms</span></span><a class="headerlink" href="#extension-PatternSynonyms" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>7.8.1</p>
</dd>
</dl>
<p>Allow the definition of pattern synonyms.</p>
</dd></dl>

<p>Pattern synonyms are enabled by the language extension <a class="reference internal" href="#extension-PatternSynonyms"><code class="xref std std-extension docutils literal notranslate"><span class="pre">PatternSynonyms</span></code></a>, which is
required for defining them, but <em>not</em> for using them. More information and
examples of pattern synonyms can be found on the <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/pattern-synonyms">Wiki page</a>.</p>
<p>Pattern synonyms enable giving names to parametrized pattern schemes.
They can also be thought of as abstract constructors that don’t have a
bearing on data representation. For example, in a programming language
implementation, we might represent types of the language as follows:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">App</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="p">[</span><span class="kt">Type</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Here are some examples of using said representation. Consider a few
types of the <code class="docutils literal notranslate"><span class="pre">Type</span></code> universe encoded like this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">App</span><span class="w"> </span><span class="s">&quot;-&gt;&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">]</span><span class="w">          </span><span class="c1">-- t1 -&gt; t2</span><span class="w"></span>
<span class="kt">App</span><span class="w"> </span><span class="s">&quot;Int&quot;</span><span class="w"> </span><span class="kt">[]</span><span class="w">               </span><span class="c1">-- Int</span><span class="w"></span>
<span class="kt">App</span><span class="w"> </span><span class="s">&quot;Maybe&quot;</span><span class="w"> </span><span class="p">[</span><span class="kt">App</span><span class="w"> </span><span class="s">&quot;Int&quot;</span><span class="w"> </span><span class="kt">[]</span><span class="p">]</span><span class="w"> </span><span class="c1">-- Maybe Int</span><span class="w"></span>
</pre></div>
</div>
<p>This representation is very generic in that no types are given special
treatment. However, some functions might need to handle some known types
specially, for example the following two functions collect all argument
types of (nested) arrow types, and recognize the <code class="docutils literal notranslate"><span class="pre">Int</span></code> type,
respectively:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">collectArgs</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Type</span><span class="p">]</span><span class="w"></span>
<span class="nf">collectArgs</span><span class="w"> </span><span class="p">(</span><span class="kt">App</span><span class="w"> </span><span class="s">&quot;-&gt;&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">])</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">collectArgs</span><span class="w"> </span><span class="n">t2</span><span class="w"></span>
<span class="nf">collectArgs</span><span class="w"> </span><span class="kr">_</span><span class="w">                   </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span><span class="w"></span>

<span class="nf">isInt</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="nf">isInt</span><span class="w"> </span><span class="p">(</span><span class="kt">App</span><span class="w"> </span><span class="s">&quot;Int&quot;</span><span class="w"> </span><span class="kt">[]</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">True</span><span class="w"></span>
<span class="nf">isInt</span><span class="w"> </span><span class="kr">_</span><span class="w">              </span><span class="ow">=</span><span class="w"> </span><span class="kt">False</span><span class="w"></span>
</pre></div>
</div>
<p>Matching on <code class="docutils literal notranslate"><span class="pre">App</span></code> directly is both hard to read and error prone to
write. And the situation is even worse when the matching is nested:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">isIntEndo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="nf">isIntEndo</span><span class="w"> </span><span class="p">(</span><span class="kt">App</span><span class="w"> </span><span class="s">&quot;-&gt;&quot;</span><span class="w"> </span><span class="p">[</span><span class="kt">App</span><span class="w"> </span><span class="s">&quot;Int&quot;</span><span class="w"> </span><span class="kt">[]</span><span class="p">,</span><span class="w"> </span><span class="kt">App</span><span class="w"> </span><span class="s">&quot;Int&quot;</span><span class="w"> </span><span class="kt">[]</span><span class="p">])</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">True</span><span class="w"></span>
<span class="nf">isIntEndo</span><span class="w"> </span><span class="kr">_</span><span class="w">                                       </span><span class="ow">=</span><span class="w"> </span><span class="kt">False</span><span class="w"></span>
</pre></div>
</div>
<p>Pattern synonyms permit abstracting from the representation to expose
matchers that behave in a constructor-like manner with respect to
pattern matching. We can create pattern synonyms for the known types we
care about, without committing the representation to them (note that
these don’t have to be defined in the same module as the <code class="docutils literal notranslate"><span class="pre">Type</span></code> type):</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pattern</span><span class="w"> </span><span class="kt">Arrow</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">App</span><span class="w"> </span><span class="s">&quot;-&gt;&quot;</span><span class="w">    </span><span class="p">[</span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">]</span><span class="w"></span>
<span class="nf">pattern</span><span class="w"> </span><span class="kt">Int</span><span class="w">         </span><span class="ow">=</span><span class="w"> </span><span class="kt">App</span><span class="w"> </span><span class="s">&quot;Int&quot;</span><span class="w">   </span><span class="kt">[]</span><span class="w"></span>
<span class="nf">pattern</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">t</span><span class="w">     </span><span class="ow">=</span><span class="w"> </span><span class="kt">App</span><span class="w"> </span><span class="s">&quot;Maybe&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Which enables us to rewrite our functions in a much cleaner style:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">collectArgs</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Type</span><span class="p">]</span><span class="w"></span>
<span class="nf">collectArgs</span><span class="w"> </span><span class="p">(</span><span class="kt">Arrow</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="n">t2</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">collectArgs</span><span class="w"> </span><span class="n">t2</span><span class="w"></span>
<span class="nf">collectArgs</span><span class="w"> </span><span class="kr">_</span><span class="w">             </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span><span class="w"></span>

<span class="nf">isInt</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="nf">isInt</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">True</span><span class="w"></span>
<span class="nf">isInt</span><span class="w"> </span><span class="kr">_</span><span class="w">   </span><span class="ow">=</span><span class="w"> </span><span class="kt">False</span><span class="w"></span>

<span class="nf">isIntEndo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="nf">isIntEndo</span><span class="w"> </span><span class="p">(</span><span class="kt">Arrow</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">True</span><span class="w"></span>
<span class="nf">isIntEndo</span><span class="w"> </span><span class="kr">_</span><span class="w">               </span><span class="ow">=</span><span class="w"> </span><span class="kt">False</span><span class="w"></span>
</pre></div>
</div>
<p>In general there are three kinds of pattern synonyms. Unidirectional,
bidirectional and explicitly bidirectional. The examples given so far are
examples of bidirectional pattern synonyms. A bidirectional synonym
behaves the same as an ordinary data constructor. We can use it in a pattern
context to deconstruct values and in an expression context to construct values.
For example, we can construct the value <cite>intEndo</cite> using the pattern synonyms
<cite>Arrow</cite> and <cite>Int</cite> as defined previously.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">intEndo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="nf">intEndo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Arrow</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
</pre></div>
</div>
<p>This example is equivalent to the much more complicated construction if we had
directly used the <cite>Type</cite> constructors.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">intEndo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"></span>
<span class="nf">intEndo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">App</span><span class="w"> </span><span class="s">&quot;-&gt;&quot;</span><span class="w"> </span><span class="p">[</span><span class="kt">App</span><span class="w"> </span><span class="s">&quot;Int&quot;</span><span class="w"> </span><span class="kt">[]</span><span class="p">,</span><span class="w"> </span><span class="kt">App</span><span class="w"> </span><span class="s">&quot;Int&quot;</span><span class="w"> </span><span class="kt">[]</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Unidirectional synonyms can only be used in a pattern context and are
defined as follows:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pattern</span><span class="w"> </span><span class="kt">Head</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="w"></span>
</pre></div>
</div>
<p>In this case, <code class="docutils literal notranslate"><span class="pre">Head</span></code> ⟨x⟩ cannot be used in expressions, only patterns,
since it wouldn’t specify a value for the ⟨xs⟩ on the right-hand side. However,
we can define an explicitly bidirectional pattern synonym by separately
specifying how to construct and deconstruct a type. The syntax for
doing this is as follows:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pattern</span><span class="w"> </span><span class="kt">HeadC</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">HeadC</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>We can then use <code class="docutils literal notranslate"><span class="pre">HeadC</span></code> in both expression and pattern contexts. In a pattern
context it will match the head of any list with length at least one. In an
expression context it will construct a singleton list.</p>
<p>Explicitly bidirectional pattern synonyms offer greater flexibility than
implicitly bidirectional ones in terms of the syntax that is permitted. For
instance, the following is not a legal implicitly bidirectional pattern
synonym:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pattern</span><span class="w"> </span><span class="kt">StrictJust</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="o">!</span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>This is illegal because the use of <a class="reference internal" href="strict.html#extension-BangPatterns"><code class="xref std std-extension docutils literal notranslate"><span class="pre">BangPatterns</span></code></a> on the right-hand
sides prevents it from being a well formed expression. However, constructing a
strict pattern synonym is quite possible with an explicitly bidirectional
pattern synonym:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pattern</span><span class="w"> </span><span class="kt">StrictJust</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="o">!</span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">StrictJust</span><span class="w"> </span><span class="o">!</span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>Constructing an explicitly bidirectional pattern synonym also:</p>
<ul class="simple">
<li><p>can create different data constructors from the underlying data type,
not just the one appearing in the pattern match;</p></li>
<li><p>can call any functions or conditional logic, especially validation,
of course providing it constructs a result of the right type;</p></li>
<li><p>can use guards on the lhs of the <code class="docutils literal notranslate"><span class="pre">=</span></code>;</p></li>
<li><p>can have multiple equations.</p></li>
</ul>
<p>For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">PosNeg</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Pos</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Neg</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">pattern</span><span class="w"> </span><span class="kt">Smarter</span><span class="p">{</span><span class="w"> </span><span class="n">nonneg</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="kt">Pos</span><span class="w"> </span><span class="n">nonneg</span><span class="w">  </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">Smarter</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="p">(</span><span class="kt">Pos</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="p">(</span><span class="kt">Neg</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Or using guards:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pattern</span><span class="w"> </span><span class="kt">Smarter</span><span class="p">{</span><span class="w"> </span><span class="n">nonneg</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="kt">Pos</span><span class="w"> </span><span class="n">nonneg</span><span class="w">  </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">Smarter</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w">    </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="kt">Pos</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="kt">Neg</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>There is an extensive Haskell folk art of <a class="reference external" href="https://wiki.haskell.org/Smart_constructor">smart constructors</a>,
essentially functions that wrap validation around a constructor,
and avoid exposing its representation.
The downside is that the underlying constructor can’t be used as a matcher.
Pattern synonyms can be used as genuinely smart constructors, for both validation and matching.</p>
<p>The table below summarises where each kind of pattern synonym can be used.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Context</p></th>
<th class="head"><p>Unidirectional</p></th>
<th class="head"><p>Bidirectional</p></th>
<th class="head"><p>Explicitly Bidirectional</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Pattern</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p>Expression</p></td>
<td><p>No</p></td>
<td><p>Yes (Inferred)</p></td>
<td><p>Yes (Explicit)</p></td>
</tr>
</tbody>
</table>
<section id="record-pattern-synonyms">
<span id="record-patsyn"></span><h2><span class="section-number">6.7.4.1. </span>Record Pattern Synonyms<a class="headerlink" href="#record-pattern-synonyms" title="Permalink to this heading">¶</a></h2>
<p>It is also possible to define pattern synonyms which behave just like record
constructors. The syntax for doing this is as follows:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pattern</span><span class="w"> </span><span class="kt">Point</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="w"></span>
<span class="nf">pattern</span><span class="w"> </span><span class="kt">Point</span><span class="p">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">}</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>The idea is that we can then use <code class="docutils literal notranslate"><span class="pre">Point</span></code> just as if we had defined a new
datatype <code class="docutils literal notranslate"><span class="pre">MyPoint</span></code> with two fields <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">MyPoint</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Whilst a normal pattern synonym can be used in two ways, there are then seven
ways in which to use <code class="docutils literal notranslate"><span class="pre">Point</span></code>. Precisely the ways in which a normal record
constructor can be used.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Usage</p></th>
<th class="head"><p>Example</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>As a constructor</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">zero</span> <span class="pre">=</span> <span class="pre">Point</span> <span class="pre">0</span> <span class="pre">0</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>As a constructor with record syntax</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">zero</span> <span class="pre">=</span> <span class="pre">Point</span> <span class="pre">{</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">0}</span></code></p></td>
</tr>
<tr class="row-even"><td><p>In a pattern context</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">isZero</span> <span class="pre">(Point</span> <span class="pre">0</span> <span class="pre">0)</span> <span class="pre">=</span> <span class="pre">True</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>In a pattern context with record syntax</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">isZero</span> <span class="pre">(Point</span> <span class="pre">{</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">0</span> <span class="pre">}</span></code></p></td>
</tr>
<tr class="row-even"><td><p>In a pattern context with field puns</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">getX</span> <span class="pre">(Point</span> <span class="pre">{x})</span> <span class="pre">=</span> <span class="pre">x</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>In a record update</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">0)</span> <span class="pre">{</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">}</span> <span class="pre">==</span> <span class="pre">(1,0)</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Using record selectors</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">(0,0)</span> <span class="pre">==</span> <span class="pre">0</span></code></p></td>
</tr>
</tbody>
</table>
<p>For a unidirectional record pattern synonym we define record selectors but do
not allow record updates or construction.</p>
<p>The syntax and semantics of pattern synonyms are elaborated in the
following subsections.
There are also lots more details in the <a class="reference external" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/08/pattern-synonyms-Haskell16.pdf">paper</a>.</p>
<p>See the <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/pattern-synonyms">Wiki page</a> for more
details.</p>
</section>
<section id="syntax-and-scoping-of-pattern-synonyms">
<h2><span class="section-number">6.7.4.2. </span>Syntax and scoping of pattern synonyms<a class="headerlink" href="#syntax-and-scoping-of-pattern-synonyms" title="Permalink to this heading">¶</a></h2>
<p>A pattern synonym declaration can be either unidirectional,
bidirectional or explicitly bidirectional.
The syntax for unidirectional pattern synonyms is:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pattern</span><span class="w"> </span><span class="n">pat_lhs</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">pat</span><span class="w"></span>
</pre></div>
</div>
<p>the syntax for bidirectional pattern synonyms is:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pattern</span><span class="w"> </span><span class="n">pat_lhs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">pat</span><span class="w"></span>
</pre></div>
</div>
<p>and the syntax for explicitly bidirectional pattern synonyms is:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pattern</span><span class="w"> </span><span class="n">pat_lhs</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">pat</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">pat_lhs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">expr</span><span class="w">                      </span><span class="c1">-- lhs restricted, see below</span><span class="w"></span>
</pre></div>
</div>
<p>We can define either prefix, infix or record pattern synonyms by modifying
the form of <cite>pat_lhs</cite>. The syntax for these is as follows:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Prefix</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Name</span> <span class="pre">args</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Infix</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">arg1</span> <span class="pre">`Name`</span> <span class="pre">arg2</span></code>
or <code class="docutils literal notranslate"><span class="pre">arg1</span> <span class="pre">op</span> <span class="pre">arg2</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Record</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Name{arg1,arg2,...,argn}</span></code></p></td>
</tr>
</tbody>
</table>
<p>The <cite>pat_lhs</cite> for explicitly bidirectional construction cannot use Record syntax.
(Because the rhs <em>expr</em> might be constructing different data constructors.)
It can use guards with multiple equations.</p>
<p>Pattern synonym declarations can only occur in the top level of a
module. In particular, they are not allowed as local definitions.</p>
<p>The variables in the left-hand side of the definition are bound by the
pattern on the right-hand side. For bidirectional pattern
synonyms, all the variables of the right-hand side must also occur on
the left-hand side; also, wildcard patterns and view patterns are not
allowed. For unidirectional and explicitly bidirectional pattern
synonyms, there is no restriction on the right-hand side pattern.</p>
<p>Pattern synonyms cannot be defined recursively.</p>
<p><a class="reference internal" href="pragmas.html#complete-pragma"><span class="std std-ref">COMPLETE pragmas</span></a> can be specified in order to tell
the pattern match exhaustiveness checker that a set of pattern synonyms is
complete.</p>
</section>
<section id="import-and-export-of-pattern-synonyms">
<span id="patsyn-impexp"></span><h2><span class="section-number">6.7.4.3. </span>Import and export of pattern synonyms<a class="headerlink" href="#import-and-export-of-pattern-synonyms" title="Permalink to this heading">¶</a></h2>
<p>The name of the pattern synonym is in the same namespace as proper data
constructors. Like normal data constructors, pattern synonyms can be imported
and exported through association with a type constructor or independently.</p>
<p>To export them on their own, in an export or import specification, you must
prefix pattern names with the <code class="docutils literal notranslate"><span class="pre">pattern</span></code> keyword, e.g.:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">Example</span><span class="w"> </span><span class="p">(</span><span class="nf">pattern</span><span class="w"> </span><span class="kt">Zero</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">MyNum</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkNum</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>

<span class="nf">pattern</span><span class="w"> </span><span class="kt">Zero</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">MyNum</span><span class="w"></span>
<span class="nf">pattern</span><span class="w"> </span><span class="kt">Zero</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkNum</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
</pre></div>
</div>
<p>Without the <code class="docutils literal notranslate"><span class="pre">pattern</span></code> prefix, <code class="docutils literal notranslate"><span class="pre">Zero</span></code> would be interpreted as a
type constructor in the export list.</p>
<p>You may also use the <code class="docutils literal notranslate"><span class="pre">pattern</span></code> keyword in an import/export
specification to import or export an ordinary data constructor. For
example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span><span class="w"> </span><span class="nn">Data.Maybe</span><span class="p">(</span><span class="w"> </span><span class="n">pattern</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>would bring into scope the data constructor <code class="docutils literal notranslate"><span class="pre">Just</span></code> from the <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>
type, without also bringing the type constructor <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> into scope.</p>
<p>As of GHC 8.0.1 you may also “bundle” pattern synonyms with an exported type
constructor, making that pattern appear as a data constructor of that type. To
bundle a pattern synonym, we list the pattern synonym in the export list of a
module which exports the type constructor.  For example, to bundle <code class="docutils literal notranslate"><span class="pre">Zero</span></code>
with <code class="docutils literal notranslate"><span class="pre">MyNum</span></code> we could write the following:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">Example</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">MyNum</span><span class="p">(</span><span class="kt">Zero</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
</pre></div>
</div>
<p>If a module was then to import <code class="docutils literal notranslate"><span class="pre">MyNum</span></code> from <code class="docutils literal notranslate"><span class="pre">Example</span></code>, it would also import
the pattern synonym <code class="docutils literal notranslate"><span class="pre">Zero</span></code>.</p>
<p>It is also possible to use the special token <code class="docutils literal notranslate"><span class="pre">..</span></code> in an export list to mean
all currently bundled constructors. For example, we could write:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">Example</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">MyNum</span><span class="p">(</span><span class="o">..</span><span class="p">,</span><span class="w"> </span><span class="kt">Zero</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
</pre></div>
</div>
<p>in which case, <code class="docutils literal notranslate"><span class="pre">Example</span></code> would export the type constructor <code class="docutils literal notranslate"><span class="pre">MyNum</span></code> with
the data constructor <code class="docutils literal notranslate"><span class="pre">MkNum</span></code> and also the pattern synonym <code class="docutils literal notranslate"><span class="pre">Zero</span></code>.</p>
<p>Bundled pattern synonyms are type checked to ensure that they are of the same
type as the type constructor which they are bundled with. A pattern synonym
<code class="docutils literal notranslate"><span class="pre">P</span></code> can not be bundled with a type constructor <code class="docutils literal notranslate"><span class="pre">T</span></code> if <code class="docutils literal notranslate"><span class="pre">P</span></code>'s type is visibly
incompatible with <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
<p>A module which imports <code class="docutils literal notranslate"><span class="pre">MyNum(..)</span></code> from <code class="docutils literal notranslate"><span class="pre">Example</span></code> and then re-exports
<code class="docutils literal notranslate"><span class="pre">MyNum(..)</span></code> will also export any pattern synonyms bundled with <code class="docutils literal notranslate"><span class="pre">MyNum</span></code> in
<code class="docutils literal notranslate"><span class="pre">Example</span></code>. A more complete specification can be found on the
<a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/pattern-synonyms/associating-synonyms">wiki.</a></p>
</section>
<section id="typing-of-pattern-synonyms">
<span id="patsyn-typing"></span><h2><span class="section-number">6.7.4.4. </span>Typing of pattern synonyms<a class="headerlink" href="#typing-of-pattern-synonyms" title="Permalink to this heading">¶</a></h2>
<p>Given a pattern synonym definition of the form</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pattern</span><span class="w"> </span><span class="kt">P</span><span class="w"> </span><span class="n">var1</span><span class="w"> </span><span class="n">var2</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="n">varN</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">pat</span><span class="w"></span>
</pre></div>
</div>
<p>it is assigned a <em>pattern type</em> of the form</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pattern</span><span class="w"> </span><span class="kt">P</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">CReq</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">CProv</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">tN</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">t</span><span class="w"></span>
</pre></div>
</div>
<p>where ⟨CReq⟩ and ⟨CProv⟩ are type contexts, and ⟨t1⟩, ⟨t2⟩, …, ⟨tN⟩
and ⟨t⟩ are types. Notice the unusual form of the type, with two
contexts ⟨CReq⟩ and ⟨CProv⟩:</p>
<ul class="simple">
<li><p>⟨CReq⟩ are the constraints <em>required</em> to match the pattern.</p></li>
<li><p>⟨CProv⟩ are the constraints <em>made available (provided)</em> by a
successful pattern match.</p></li>
</ul>
<p>For example, consider</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">MkT</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Show</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"></span>

<span class="nf">f1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Num</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="nf">f1</span><span class="w"> </span><span class="p">(</span><span class="kt">MkT</span><span class="w"> </span><span class="mi">42</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="n">x</span><span class="w"></span>

<span class="nf">pattern</span><span class="w"> </span><span class="kt">ExNumPat</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Num</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">Show</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">pattern</span><span class="w"> </span><span class="kt">ExNumPat</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkT</span><span class="w"> </span><span class="mi">42</span><span class="w"> </span><span class="n">x</span><span class="w"></span>

<span class="nf">f2</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">Num</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="nf">f2</span><span class="w"> </span><span class="p">(</span><span class="kt">ExNumPat</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">f1</span></code> does not use pattern synonyms. To match against the numeric
pattern <code class="docutils literal notranslate"><span class="pre">42</span></code> <em>requires</em> the caller to satisfy the constraints
<code class="docutils literal notranslate"><span class="pre">(Num</span> <span class="pre">a,</span> <span class="pre">Eq</span> <span class="pre">a)</span></code>, so they appear in <code class="docutils literal notranslate"><span class="pre">f1</span></code>’s type. The call to <code class="docutils literal notranslate"><span class="pre">show</span></code>
generates a <code class="docutils literal notranslate"><span class="pre">(Show</span> <span class="pre">b)</span></code> constraint, where <code class="docutils literal notranslate"><span class="pre">b</span></code> is an existentially
type variable bound by the pattern match on <code class="docutils literal notranslate"><span class="pre">MkT</span></code>. But the same
pattern match also <em>provides</em> the constraint <code class="docutils literal notranslate"><span class="pre">(Show</span> <span class="pre">b)</span></code> (see <code class="docutils literal notranslate"><span class="pre">MkT</span></code>’s
type), and so all is well.</p>
<p>Exactly the same reasoning applies to <code class="docutils literal notranslate"><span class="pre">ExNumPat</span></code>: matching against
<code class="docutils literal notranslate"><span class="pre">ExNumPat</span></code> <em>requires</em> the constraints <code class="docutils literal notranslate"><span class="pre">(Num</span> <span class="pre">a,</span> <span class="pre">Eq</span> <span class="pre">a)</span></code>, and
<em>provides</em> the constraint <code class="docutils literal notranslate"><span class="pre">(Show</span> <span class="pre">b)</span></code>.</p>
<p>Note also the following points</p>
<ul>
<li><p>In the common case where <code class="docutils literal notranslate"><span class="pre">CProv</span></code> is empty, (i.e., <code class="docutils literal notranslate"><span class="pre">()</span></code>), it can be
omitted altogether in the above pattern type signature for <code class="docutils literal notranslate"><span class="pre">P</span></code>.</p></li>
<li><p>However, if <code class="docutils literal notranslate"><span class="pre">CProv</span></code> is non-empty, while <code class="docutils literal notranslate"><span class="pre">CReq</span></code> is, the above pattern type
signature for <code class="docutils literal notranslate"><span class="pre">P</span></code> must be specified as</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">P</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="nb">()</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">CProv</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">tN</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">t</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>The GHCi <a class="reference internal" href="../ghci.html#ghci-cmd-info"><code class="xref std std-ghci-cmd docutils literal notranslate"><span class="pre">:info</span></code></a> command shows pattern types in this format.</p></li>
<li><p>You may specify an explicit <em>pattern signature</em>, as we did for
<code class="docutils literal notranslate"><span class="pre">ExNumPat</span></code> above, to specify the type of a pattern, just as you can
for a function. As usual, the type signature can be less polymorphic
than the inferred type. For example</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Inferred type would be &#39;a -&gt; [a]&#39;</span><span class="w"></span>
<span class="nf">pattern</span><span class="w"> </span><span class="kt">SinglePair</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">)]</span><span class="w"></span>
<span class="nf">pattern</span><span class="w"> </span><span class="kt">SinglePair</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Just like signatures on value-level bindings, pattern synonym signatures can
apply to more than one pattern. For instance,</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pattern</span><span class="w"> </span><span class="kt">Left&#39;</span><span class="p">,</span><span class="w"> </span><span class="kt">Right&#39;</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Either</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">pattern</span><span class="w"> </span><span class="kt">Left&#39;</span><span class="w"> </span><span class="n">x</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kt">Left</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="nf">pattern</span><span class="w"> </span><span class="kt">Right&#39;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Right</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>The rules for lexically-scoped type variables (see
<a class="reference internal" href="scoped_type_variables.html#scoped-type-variables"><span class="std std-ref">Lexically scoped type variables</span></a>) apply to pattern-synonym signatures.
As those rules specify, only the type variables from an explicit,
syntactically-visible outer <cite>forall</cite> (the universals) scope over
the definition of the pattern synonym; the existentials, bound by
the inner forall, do not.  For example</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">   </span><span class="kt">MkT</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="ow">-&gt;</span><span class="kt">Int</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"></span>

<span class="nf">pattern</span><span class="w"> </span><span class="kt">P</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">b</span><span class="o">.</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="ow">-&gt;</span><span class="kt">Int</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">pattern</span><span class="w"> </span><span class="kt">P</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="kt">MkT</span><span class="w"> </span><span class="kt">True</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">(</span><span class="n">v</span><span class="ow">::</span><span class="n">a</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Here the universal type variable <cite>a</cite> scopes over the definition of <cite>P</cite>,
but the existential <cite>b</cite> does not.  (c.f. discussion on #14998.)</p>
</li>
<li><p>For a bidirectional pattern synonym, a use of the pattern synonym as
an expression has the type</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kt">CReq</span><span class="p">,</span><span class="w"> </span><span class="kt">CProv</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">tN</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">t</span><span class="w"></span>
</pre></div>
</div>
<p>So in the previous example, when used in an expression, <code class="docutils literal notranslate"><span class="pre">ExNumPat</span></code>
has type</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">ExNumPat</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Num</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">Show</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">t</span><span class="w"></span>
</pre></div>
</div>
<p>Notice that this is a tiny bit more restrictive than the expression
<code class="docutils literal notranslate"><span class="pre">MkT</span> <span class="pre">42</span> <span class="pre">x</span></code> which would not require <code class="docutils literal notranslate"><span class="pre">(Eq</span> <span class="pre">a)</span></code>.</p>
</li>
<li><p>Consider these two pattern synonyms:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">S</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">   </span><span class="kt">S1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">S</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>

<span class="nf">pattern</span><span class="w"> </span><span class="kt">P1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="nf">pattern</span><span class="w"> </span><span class="kt">P1</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="n">b</span><span class="w"></span>

<span class="nf">pattern</span><span class="w"> </span><span class="kt">P2</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="nb">()</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="kt">Bool</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">S</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="nf">pattern</span><span class="w"> </span><span class="kt">P2</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">S1</span><span class="w"> </span><span class="n">b</span><span class="w"></span>

<span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="p">(</span><span class="kt">P1</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;no no no&quot;</span><span class="w">     </span><span class="c1">-- Type-incorrect</span><span class="w"></span>

<span class="nf">g</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">S</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="nf">g</span><span class="w"> </span><span class="p">(</span><span class="kt">P2</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;yes yes yes&quot;</span><span class="w">  </span><span class="c1">-- Fine</span><span class="w"></span>
</pre></div>
</div>
<p>Pattern <code class="docutils literal notranslate"><span class="pre">P1</span></code> can only match against a value of type <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">Bool</span></code>,
so function <code class="docutils literal notranslate"><span class="pre">f</span></code> is rejected because the type signature is
<code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">a</span></code>. (To see this, imagine expanding the pattern synonym.)</p>
<p>On the other hand, function <code class="docutils literal notranslate"><span class="pre">g</span></code> works fine, because matching
against <code class="docutils literal notranslate"><span class="pre">P2</span></code> (which wraps the GADT <code class="docutils literal notranslate"><span class="pre">S</span></code>) provides the local
equality <code class="docutils literal notranslate"><span class="pre">(a~Bool)</span></code>. If you were to give an explicit pattern
signature <code class="docutils literal notranslate"><span class="pre">P2</span> <span class="pre">::</span> <span class="pre">Bool</span> <span class="pre">-&gt;</span> <span class="pre">S</span> <span class="pre">Bool</span></code>, then <code class="docutils literal notranslate"><span class="pre">P2</span></code> would become less
polymorphic, and would behave exactly like <code class="docutils literal notranslate"><span class="pre">P1</span></code> so that <code class="docutils literal notranslate"><span class="pre">g</span></code> would
then be rejected.</p>
<p>In short, if you want GADT-like behaviour for pattern synonyms, then
(unlike concrete data constructors like <code class="docutils literal notranslate"><span class="pre">S1</span></code>) you must write
its type with explicit provided equalities. For a concrete data
constructor like <code class="docutils literal notranslate"><span class="pre">S1</span></code> you can write its type signature as either
<code class="docutils literal notranslate"><span class="pre">S1</span> <span class="pre">::</span> <span class="pre">Bool</span> <span class="pre">-&gt;</span> <span class="pre">S</span> <span class="pre">Bool</span></code> or <code class="docutils literal notranslate"><span class="pre">S1</span> <span class="pre">::</span> <span class="pre">(b~Bool)</span> <span class="pre">=&gt;</span> <span class="pre">Bool</span> <span class="pre">-&gt;</span> <span class="pre">S</span> <span class="pre">b</span></code>; the
two are equivalent. Not so for pattern synonyms: the two forms are
different, in order to distinguish the two cases above. (See
<a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/9953">#9953</a> for discussion of this choice.)</p>
</li>
</ul>
</section>
<section id="matching-of-pattern-synonyms">
<h2><span class="section-number">6.7.4.5. </span>Matching of pattern synonyms<a class="headerlink" href="#matching-of-pattern-synonyms" title="Permalink to this heading">¶</a></h2>
<p>A pattern synonym occurrence in a pattern is evaluated by first matching
against the pattern synonym itself, and then on the argument patterns.</p>
<p>More precisely, the semantics of pattern matching is given in
<a class="reference external" href="https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17">Section 3.17 of the Haskell 2010 report</a>.   To the informal semantics in Section 3.17.2 we add this extra rule:</p>
<ul class="simple">
<li><p>If the pattern is a constructor pattern <code class="docutils literal notranslate"><span class="pre">(P</span> <span class="pre">p1</span> <span class="pre">...</span> <span class="pre">pn)</span></code>, where <code class="docutils literal notranslate"><span class="pre">P</span></code> is
a pattern synonym defined by <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">x1</span> <span class="pre">...</span> <span class="pre">xn</span> <span class="pre">=</span> <span class="pre">p</span></code> or <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">x1</span> <span class="pre">...</span> <span class="pre">xn</span> <span class="pre">&lt;-</span> <span class="pre">p</span></code>, then:</p>
<ol class="loweralpha simple">
<li><p>Match the value <code class="docutils literal notranslate"><span class="pre">v</span></code> against <code class="docutils literal notranslate"><span class="pre">p</span></code>. If this match fails or diverges,
so does the whole (pattern synonym) match.   Otherwise the match
against <code class="docutils literal notranslate"><span class="pre">p</span></code> must bind the variables <code class="docutils literal notranslate"><span class="pre">x1</span> <span class="pre">...</span> <span class="pre">xn</span></code>; let them be bound to values <code class="docutils literal notranslate"><span class="pre">v1</span> <span class="pre">...</span> <span class="pre">vn</span></code>.</p></li>
<li><p>Match <code class="docutils literal notranslate"><span class="pre">v1</span></code> against <code class="docutils literal notranslate"><span class="pre">p1</span></code>, <code class="docutils literal notranslate"><span class="pre">v2</span></code> against <code class="docutils literal notranslate"><span class="pre">p2</span></code> and so on.
If any of these matches fail or diverge, so does the whole match.</p></li>
<li><p>If all the matches against the <code class="docutils literal notranslate"><span class="pre">pi</span></code> succeed, the match succeeds,
binding the variables bound by the <code class="docutils literal notranslate"><span class="pre">pi</span></code> . (The <code class="docutils literal notranslate"><span class="pre">xi</span></code> are not
bound; they remain local to the pattern synonym declaration.)</p></li>
</ol>
</li>
</ul>
<p>For example, in the following program, <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">f'</span></code> are equivalent:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pattern</span><span class="w"> </span><span class="kt">Pair</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w"></span>

<span class="nf">f</span><span class="w"> </span><span class="p">(</span><span class="kt">Pair</span><span class="w"> </span><span class="kt">True</span><span class="w"> </span><span class="kt">True</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">True</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="kr">_</span><span class="w">                </span><span class="ow">=</span><span class="w"> </span><span class="kt">False</span><span class="w"></span>

<span class="nf">f&#39;</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">True</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">True</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">True</span><span class="w"></span>
<span class="nf">f&#39;</span><span class="w"> </span><span class="kr">_</span><span class="w">                              </span><span class="ow">=</span><span class="w"> </span><span class="kt">False</span><span class="w"></span>
</pre></div>
</div>
<p>Note that the strictness of <code class="docutils literal notranslate"><span class="pre">f</span></code> differs from that of <code class="docutils literal notranslate"><span class="pre">g</span></code> defined
below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>g [True, True] = True
g _            = False

*Main&gt; f (False:undefined)
*** Exception: Prelude.undefined
*Main&gt; g (False:undefined)
False
</pre></div>
</div>
</section>
<section id="pragmas-for-pattern-synonyms">
<h2><span class="section-number">6.7.4.6. </span>Pragmas for pattern synonyms<a class="headerlink" href="#pragmas-for-pattern-synonyms" title="Permalink to this heading">¶</a></h2>
<p>The <a class="reference internal" href="pragmas.html#inlinable-pragma"><span class="std std-ref">INLINABLE pragma</span></a>, <a class="reference internal" href="pragmas.html#inline-pragma"><span class="std std-ref">INLINE pragma</span></a> and <a class="reference internal" href="pragmas.html#noinline-pragma"><span class="std std-ref">NOINLINE pragma</span></a> are supported for pattern
synonyms. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">patternInlinablePattern</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"></span>
<span class="cm">{-# INLINABLE InlinablePattern #-}</span><span class="w"></span>
<span class="nf">pattern</span><span class="w"> </span><span class="kt">InlinedPattern</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"></span>
<span class="cm">{-# INLINE InlinedPattern #-}</span><span class="w"></span>
<span class="nf">pattern</span><span class="w"> </span><span class="kt">NonInlinedPattern</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"></span>
<span class="cm">{-# NOINLINE NonInlinedPattern #-}</span><span class="w"></span>
</pre></div>
</div>
<p>As with other <code class="docutils literal notranslate"><span class="pre">INLINABLE</span></code>, <code class="docutils literal notranslate"><span class="pre">INLINE</span></code> and <code class="docutils literal notranslate"><span class="pre">NOINLINE</span></code> pragmas, it’s possible to specify
to which phase the pragma applies:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pattern</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"></span>
<span class="cm">{-# NOINLINE[1] Q #-}</span><span class="w"></span>
</pre></div>
</div>
<p>The pragmas are applied both when the pattern is used as a matcher, and as a
data constructor. For explicitly bidirectional pattern synonyms, the pragma
must be at top level, not nested in the where clause. For example, this won’t compile:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pattern</span><span class="w"> </span><span class="kt">HeadC</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">HeadC</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="cm">{-# INLINE HeadC #-}</span><span class="w"></span>
</pre></div>
</div>
<p>but this will:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pattern</span><span class="w"> </span><span class="kt">HeadC</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">HeadC</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"></span>
<span class="cm">{-# INLINE HeadC #-}</span><span class="w"></span>
</pre></div>
</div>
<p>When no pragma is provided for a pattern, the inlining decision is made by
GHC’s own inlining heuristics.</p>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="typeclasses.html" class="btn btn-neutral float-right" title="6.8. Class and instances declarations" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="nk_patterns.html" class="btn btn-neutral float-left" title="6.7.3. n+k patterns" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>