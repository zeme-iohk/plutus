-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Bin: binary natural numbers.
--   
--   This package provides <i>binary natural numbers</i> (<a>Data.Bin</a>);
--   also utilities to work on the type level with <tt>DataKinds</tt>
--   (<a>Data.Type.Bin</a>).
--   
--   <pre>
--   data Bin
--       = BZ       -- ^ zero
--       | BP BinP  -- ^ non-zero
--   
--   data BinP
--       = BE       -- ^ one
--       | B0 BinP  -- ^ double
--       | B1 BinP  -- ^ double plus 1
--   </pre>
--   
--   There are <i>ordinals</i> in <a>Data.Bin.Pos</a> module, as well as
--   fixed width integers in <a>Data.Wrd</a>.
--   
--   Another implementation is at
--   <a>https://hackage.haskell.org/package/nat</a>, this differs in
--   naming, and provides promoted variant.
@package bin
@version 0.1.2


-- | Positive binary natural numbers, <a>BinP</a>.
--   
--   This module is designed to be imported qualified.
module Data.BinP

-- | Non-zero binary natural numbers.
--   
--   We could have called this type <tt>Bin1</tt>, but that's used as type
--   alias for promoted <tt><tt>BP</tt> <a>BE</a></tt> in
--   <a>Data.Type.Bin</a>.
data BinP

-- | one
BE :: BinP

-- | mult2
B0 :: BinP -> BinP

-- | mult2 plus 1
B1 :: BinP -> BinP

-- | Fold <a>BinP</a>.
cata :: a -> (a -> a) -> (a -> a) -> BinP -> a

-- | <a>toNatural</a> for <a>BinP</a>.
toNatural :: BinP -> Natural

-- | <a>fromNatural</a> for <a>BinP</a>.
--   
--   Throws when given 0.
fromNatural :: Natural -> BinP

-- | Convert from <a>BinP</a> to <a>Nat</a>.
toNat :: BinP -> Nat

-- | <a>show</a> displaying a structure of <a>BinP</a>.
--   
--   <pre>
--   &gt;&gt;&gt; explicitShow 11
--   "B1 (B1 (B0 BE))"
--   </pre>
explicitShow :: BinP -> String

-- | <a>showsPrec</a> displaying a structure of <a>BinP</a>.
explicitShowsPrec :: Int -> BinP -> ShowS
predMaybe :: BinP -> Maybe BinP
binP1 :: BinP
binP2 :: BinP
binP3 :: BinP
binP4 :: BinP
binP5 :: BinP
binP6 :: BinP
binP7 :: BinP
binP8 :: BinP
binP9 :: BinP
instance Data.Data.Data Data.BinP.BinP
instance GHC.Classes.Eq Data.BinP.BinP
instance GHC.Classes.Ord Data.BinP.BinP
instance GHC.Show.Show Data.BinP.BinP
instance GHC.Num.Num Data.BinP.BinP
instance GHC.Real.Real Data.BinP.BinP
instance GHC.Real.Integral Data.BinP.BinP
instance GHC.Enum.Enum Data.BinP.BinP
instance Control.DeepSeq.NFData Data.BinP.BinP
instance Data.Hashable.Class.Hashable Data.BinP.BinP
instance GHC.Bits.Bits Data.BinP.BinP
instance Test.QuickCheck.Arbitrary.Arbitrary Data.BinP.BinP
instance Test.QuickCheck.Arbitrary.CoArbitrary Data.BinP.BinP
instance Test.QuickCheck.Function.Function Data.BinP.BinP


-- | Binary natural numbers, <a>Bin</a>.
--   
--   This module is designed to be imported qualified.
module Data.Bin

-- | Binary natural numbers.
--   
--   Numbers are represented in little-endian order, the representation is
--   unique.
--   
--   <pre>
--   &gt;&gt;&gt; mapM_ (putStrLn .  explicitShow) [0 .. 7]
--   BZ
--   BP BE
--   BP (B0 BE)
--   BP (B1 BE)
--   BP (B0 (B0 BE))
--   BP (B1 (B0 BE))
--   BP (B0 (B1 BE))
--   BP (B1 (B1 BE))
--   </pre>
data Bin

-- | zero
BZ :: Bin

-- | non-zero
BP :: BinP -> Bin

-- | Convert <a>Bin</a> to <a>Natural</a>
--   
--   <pre>
--   &gt;&gt;&gt; toNatural 0
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toNatural 2
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toNatural $ BP $ B0 $ B1 $ BE
--   6
--   </pre>
toNatural :: Bin -> Natural

-- | Convert <a>Natural</a> to <a>Nat</a>
--   
--   <pre>
--   &gt;&gt;&gt; fromNatural 4
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; explicitShow (fromNatural 4)
--   "BP (B0 (B0 BE))"
--   </pre>
fromNatural :: Natural -> Bin

-- | Convert from <a>Bin</a> to <a>Nat</a>.
--   
--   <pre>
--   &gt;&gt;&gt; toNat 5
--   5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; N.explicitShow (toNat 5)
--   "S (S (S (S (S Z))))"
--   </pre>
toNat :: Bin -> Nat

-- | Convert from <a>Nat</a> to <a>Bin</a>.
--   
--   <pre>
--   &gt;&gt;&gt; fromNat 5
--   5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; explicitShow (fromNat 5)
--   "BP (B1 (B0 BE))"
--   </pre>
fromNat :: Nat -> Bin

-- | Fold <a>Bin</a>.
cata :: a -> a -> (a -> a) -> (a -> a) -> Bin -> a

-- | Non-zero binary natural numbers.
--   
--   We could have called this type <tt>Bin1</tt>, but that's used as type
--   alias for promoted <tt><tt>BP</tt> <a>BE</a></tt> in
--   <a>Data.Type.Bin</a>.
data BinP

-- | one
BE :: BinP

-- | mult2
B0 :: BinP -> BinP

-- | mult2 plus 1
B1 :: BinP -> BinP

-- | <a>show</a> displaying a structure of <a>Bin</a>.
--   
--   <pre>
--   &gt;&gt;&gt; explicitShow 0
--   "BZ"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; explicitShow 2
--   "BP (B0 BE)"
--   </pre>
explicitShow :: Bin -> String

-- | <a>showsPrec</a> displaying a structure of <a>Bin</a>.
explicitShowsPrec :: Int -> Bin -> ShowS

-- | This is a total function.
--   
--   <pre>
--   &gt;&gt;&gt; map predP [1..10]
--   [0,1,2,3,4,5,6,7,8,9]
--   </pre>
predP :: BinP -> Bin
mult2 :: Bin -> Bin
mult2Plus1 :: Bin -> BinP
andP :: BinP -> BinP -> Bin
xorP :: BinP -> BinP -> Bin
complementBitP :: BinP -> Int -> Bin
clearBitP :: BinP -> Int -> Bin
bin0 :: Bin
bin1 :: Bin
bin2 :: Bin
bin3 :: Bin
bin4 :: Bin
bin5 :: Bin
bin6 :: Bin
bin7 :: Bin
bin8 :: Bin
bin9 :: Bin
instance Data.Data.Data Data.Bin.Bin
instance GHC.Classes.Ord Data.Bin.Bin
instance GHC.Classes.Eq Data.Bin.Bin
instance GHC.Show.Show Data.Bin.Bin
instance GHC.Num.Num Data.Bin.Bin
instance GHC.Real.Real Data.Bin.Bin
instance GHC.Real.Integral Data.Bin.Bin
instance GHC.Enum.Enum Data.Bin.Bin
instance Control.DeepSeq.NFData Data.Bin.Bin
instance Data.Hashable.Class.Hashable Data.Bin.Bin
instance Test.QuickCheck.Arbitrary.Arbitrary Data.Bin.Bin
instance Test.QuickCheck.Arbitrary.CoArbitrary Data.Bin.Bin
instance Test.QuickCheck.Function.Function Data.Bin.Bin
instance GHC.Bits.Bits Data.Bin.Bin


-- | Fixed-<a>Wrd</a>th (unsigned) integers.
module Data.Wrd

-- | Fixed-width unsigned integers, <a>Wrd</a>s for short.
--   
--   The number is thought to be stored in big-endian format, i.e.
--   most-significant bit first. (as in binary literals).
data Wrd (n :: Nat)
[WE] :: Wrd 'Z
[W0] :: Wrd n -> Wrd ('S n)
[W1] :: Wrd n -> Wrd ('S n)

-- | <a>show</a> displaying a structure of <tt><a>Wrd</a> n</tt>
--   
--   <pre>
--   &gt;&gt;&gt; explicitShow WE
--   "WE"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; explicitShow $ W0 WE
--   "W0 WE"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; explicitShow $ W1 $ W0 $ W1 $ W0 WE
--   "W1 $ W0 $ W1 $ W0 WE"
--   </pre>
explicitShow :: Wrd n -> String

-- | <a>showsPrec</a> displaying a structure of <tt><a>Wrd</a> n</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; explicitShowsPrec 0 (W0 WE) ""
--   "W0 WE"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; explicitShowsPrec 1 (W0 WE) ""
--   "(W0 WE)"
--   </pre>
explicitShowsPrec :: Int -> Wrd n -> ShowS

-- | Convert to <a>Natural</a> number
--   
--   <pre>
--   &gt;&gt;&gt; let u = W0 $ W1 $ W1 $ W1 $ W0 $ W1 $ W0 WE
--   
--   &gt;&gt;&gt; u
--   0b0111010
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toNatural u
--   58
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map toNatural (universe :: [Wrd N.Nat3])
--   [0,1,2,3,4,5,6,7]
--   </pre>
toNatural :: Wrd n -> Natural

-- | All values, i.e. universe of <tt><a>Wrd</a> </tt>.
--   
--   <pre>
--   &gt;&gt;&gt; universe :: [Wrd 'Z]
--   [WE]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; universe :: [Wrd N.Nat3]
--   [0b000,0b001,0b010,0b011,0b100,0b101,0b110,0b111]
--   </pre>
universe :: forall n. SNatI n => [Wrd n]
xor :: Wrd n -> Wrd n -> Wrd n
(.&.) :: Wrd n -> Wrd n -> Wrd n
(.|.) :: Wrd n -> Wrd n -> Wrd n
complement :: Wrd n -> Wrd n

-- | <pre>
--   <a>complement2</a> w = <a>complement</a> w + 1
--   </pre>
complement2 :: Wrd n -> Wrd n
shiftR :: Wrd n -> Int -> Wrd n
shiftL :: Wrd n -> Int -> Wrd n
rotateL :: Wrd n -> Int -> Wrd n
rotateR :: Wrd n -> Int -> Wrd n
popCount :: Wrd n -> Int
setBit :: Wrd n -> Int -> Wrd n
clearBit :: Wrd n -> Int -> Wrd n
complementBit :: Wrd n -> Int -> Wrd n
testBit :: Wrd n -> Int -> Bool
shiftL1 :: Wrd n -> Wrd n
shiftR1 :: Wrd n -> Wrd n
rotateL1 :: Wrd n -> Wrd n
rotateR1 :: Wrd n -> Wrd n
instance GHC.Classes.Eq (Data.Wrd.Wrd n)
instance GHC.Classes.Ord (Data.Wrd.Wrd n)
instance GHC.Show.Show (Data.Wrd.Wrd n)
instance Control.DeepSeq.NFData (Data.Wrd.Wrd n)
instance Data.Hashable.Class.Hashable (Data.Wrd.Wrd n)
instance Data.Type.Nat.SNatI n => GHC.Enum.Bounded (Data.Wrd.Wrd n)
instance Data.Type.Nat.SNatI n => GHC.Num.Num (Data.Wrd.Wrd n)
instance Data.Type.Nat.SNatI n => GHC.Bits.Bits (Data.Wrd.Wrd n)
instance Data.Type.Nat.SNatI n => GHC.Bits.FiniteBits (Data.Wrd.Wrd n)
instance Data.Type.Nat.SNatI n => Test.QuickCheck.Arbitrary.Arbitrary (Data.Wrd.Wrd n)
instance Test.QuickCheck.Arbitrary.CoArbitrary (Data.Wrd.Wrd n)
instance Data.Type.Nat.SNatI n => Test.QuickCheck.Function.Function (Data.Wrd.Wrd n)


-- | Positive binary natural numbers. <tt>DataKinds</tt> stuff.
module Data.Type.BinP

-- | Singleton of <a>BinP</a>.
data SBinP (b :: BinP)
[SBE] :: SBinP 'BE
[SB0] :: SBinPI b => SBinP ('B0 b)
[SB1] :: SBinPI b => SBinP ('B1 b)

-- | Cconvert <a>SBinP</a> to <a>BinP</a>.
sbinpToBinP :: forall n. SBinP n -> BinP

-- | Convert <a>SBinP</a> to <a>Natural</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sbinpToNatural (sbinp :: SBinP BinP8)
--   8
--   </pre>
sbinpToNatural :: forall n. SBinP n -> Natural

-- | Let constraint solver construct <a>SBinP</a>.
class SBinPI (b :: BinP)
sbinp :: SBinPI b => SBinP b

-- | Construct <a>SBinPI</a> dictionary from <a>SBinP</a>.
withSBinP :: SBinP b -> (SBinPI b => r) -> r

-- | Reify <a>BinP</a>.
reify :: forall r. BinP -> (forall b. SBinPI b => Proxy b -> r) -> r

-- | Reflect type-level <a>BinP</a> to the term level.
reflect :: forall b proxy. SBinPI b => proxy b -> BinP

-- | Reflect type-level <a>BinP</a> to the term level <a>Num</a>.
reflectToNum :: forall b proxy a. (SBinPI b, Num a) => proxy b -> a
eqBinP :: forall a b. (SBinPI a, SBinPI b) => Maybe (a :~: b)

type family EqBinP (n :: BinP) (m :: BinP)

-- | Induction on <a>BinP</a>.
induction :: forall b f. SBinPI b => f 'BE -> (forall bb. SBinPI bb => f bb -> f ('B0 bb)) -> (forall bb. SBinPI bb => f bb -> f ('B1 bb)) -> f b
type family Succ (b :: BinP) :: BinP
withSucc :: forall b r. SBinPI b => Proxy b -> (SBinPI (Succ b) => r) -> r
type family Plus (a :: BinP) (b :: BinP) :: BinP
type family ToGHC (b :: BinP) :: Nat
type family FromGHC (n :: Nat) :: BinP
type family ToNat (b :: BinP) :: Nat
type BinP1 = 'BE
type BinP2 = 'B0 BinP1
type BinP3 = 'B1 BinP1
type BinP4 = 'B0 BinP2
type BinP5 = 'B1 BinP2
type BinP6 = 'B0 BinP3
type BinP7 = 'B1 BinP3
type BinP8 = 'B0 BinP4
type BinP9 = 'B1 BinP4
instance GHC.Show.Show (Data.Type.BinP.SBinP b)
instance Data.Type.BinP.SBinPI 'Data.BinP.BE
instance Data.Type.BinP.SBinPI b => Data.Type.BinP.SBinPI ('Data.BinP.B0 b)
instance Data.Type.BinP.SBinPI b => Data.Type.BinP.SBinPI ('Data.BinP.B1 b)
instance Data.Type.Equality.TestEquality @{Data.BinP.BinP} Data.Type.BinP.SBinP
instance Data.Type.BinP.SBinPI b => Data.Boring.Boring (Data.Type.BinP.SBinP b)
instance Data.GADT.Internal.GShow @Data.BinP.BinP Data.Type.BinP.SBinP
instance Control.DeepSeq.NFData (Data.Type.BinP.SBinP n)
instance Data.GADT.DeepSeq.GNFData @Data.BinP.BinP Data.Type.BinP.SBinP
instance Data.GADT.Internal.GEq @Data.BinP.BinP Data.Type.BinP.SBinP


-- | Binary natural numbers. <tt>DataKinds</tt> stuff.
module Data.Type.Bin

-- | Singleton of <a>Bin</a>.
data SBin (b :: Bin)
[SBZ] :: SBin 'BZ
[SBP] :: SBinPI b => SBin ('BP b)

-- | Singleton of <a>BinP</a>.
data SBinP (b :: BinP)
[SBE] :: SBinP 'BE
[SB0] :: SBinPI b => SBinP ('B0 b)
[SB1] :: SBinPI b => SBinP ('B1 b)

-- | Convert <a>SBin</a> to <a>Bin</a>.
sbinToBin :: forall n. SBin n -> Bin

-- | Cconvert <a>SBinP</a> to <a>BinP</a>.
sbinpToBinP :: forall n. SBinP n -> BinP

-- | Convert <a>SBin</a> to <a>Natural</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sbinToNatural (sbin :: SBin Bin9)
--   9
--   </pre>
sbinToNatural :: forall n. SBin n -> Natural

-- | Convert <a>SBinP</a> to <a>Natural</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sbinpToNatural (sbinp :: SBinP BinP8)
--   8
--   </pre>
sbinpToNatural :: forall n. SBinP n -> Natural

-- | Let constraint solver construct <a>SBin</a>.
class SBinI (b :: Bin)
sbin :: SBinI b => SBin b

-- | Let constraint solver construct <a>SBinP</a>.
class SBinPI (b :: BinP)
sbinp :: SBinPI b => SBinP b

-- | Construct <a>SBinI</a> dictionary from <a>SBin</a>.
withSBin :: SBin b -> (SBinI b => r) -> r

-- | Construct <a>SBinPI</a> dictionary from <a>SBinP</a>.
withSBinP :: SBinP b -> (SBinPI b => r) -> r

-- | Reify <a>Bin</a>
--   
--   <pre>
--   &gt;&gt;&gt; reify bin3 reflect
--   3
--   </pre>
reify :: forall r. Bin -> (forall b. SBinI b => Proxy b -> r) -> r

-- | Reflect type-level <a>Bin</a> to the term level.
reflect :: forall b proxy. SBinI b => proxy b -> Bin

-- | Reflect type-level <a>Bin</a> to the term level <a>Num</a>.
reflectToNum :: forall b proxy a. (SBinI b, Num a) => proxy b -> a
eqBin :: forall a b. (SBinI a, SBinI b) => Maybe (a :~: b)

type family EqBin (n :: Bin) (m :: Bin)

-- | Induction on <a>Bin</a>.
induction :: forall b f. SBinI b => f 'BZ -> f ('BP 'BE) -> (forall bb. SBinPI bb => f ('BP bb) -> f ('BP ('B0 bb))) -> (forall bb. SBinPI bb => f ('BP bb) -> f ('BP ('B1 bb))) -> f b

-- | Successor type family.
--   
--   <pre>
--   &gt;&gt;&gt; :kind! Succ Bin5
--   Succ Bin5 :: Bin
--   = 'BP ('B0 ('B1 'BE))
--   </pre>
--   
--   <pre>
--   <a>Succ</a>   :: <a>Bin</a> -&gt; <a>Bin</a>
--   <a>Succ</a>`  :: <a>Bin</a> -&gt; <a>BinP</a>
--   <a>Succ'</a>` :: <a>BinP</a> -&gt; <a>Bin</a>
--   </pre>
type Succ b = 'BP (Succ' b)
type family Succ' (b :: Bin) :: BinP
type Succ'' b = 'BP (Succ b)
withSucc :: forall b r. SBinI b => Proxy b -> (SBinPI (Succ' b) => r) -> r

-- | Predecessor type family..
--   
--   <pre>
--   &gt;&gt;&gt; :kind! Pred BP.BinP1
--   Pred BP.BinP1 :: Bin
--   = 'BZ
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :kind! Pred BP.BinP5 == Bin4
--   Pred BP.BinP5 == Bin4 :: Bool
--   = 'True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :kind! Pred BP.BinP8 == Bin7
--   Pred BP.BinP8 == Bin7 :: Bool
--   = 'True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :kind! Pred BP.BinP6 == Bin5
--   Pred BP.BinP6 == Bin5 :: Bool
--   = 'True
--   </pre>
type family Pred (b :: BinP) :: Bin

-- | Addition.
--   
--   <pre>
--   &gt;&gt;&gt; :kind! Plus Bin3 Bin3 == Bin6
--   Plus Bin3 Bin3 == Bin6 :: Bool
--   = 'True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :kind! Mult2 Bin3 == Bin6
--   Mult2 Bin3 == Bin6 :: Bool
--   = 'True
--   </pre>
type family Plus (a :: Bin) (b :: Bin) :: Bin

-- | Multiply by two.
--   
--   <pre>
--   &gt;&gt;&gt; :kind! Mult2 Bin0 == Bin0
--   Mult2 Bin0 == Bin0 :: Bool
--   = 'True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :kind! Mult2 Bin3 == Bin6
--   Mult2 Bin3 == Bin6 :: Bool
--   = 'True
--   </pre>
type family Mult2 (b :: Bin) :: Bin

-- | Multiply by two and add one.
--   
--   <pre>
--   &gt;&gt;&gt; :kind! Mult2Plus1 Bin0
--   Mult2Plus1 Bin0 :: BinP
--   = 'BE
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :kind! Mult2Plus1 Bin4 == BinP9
--   Mult2Plus1 Bin4 == BinP9 :: Bool
--   = 'True
--   </pre>
type family Mult2Plus1 (b :: Bin) :: BinP

-- | Convert to GHC <a>Nat</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :kind! ToGHC Bin5
--   ToGHC Bin5 :: GHC.Nat...
--   = 5
--   </pre>
type family ToGHC (b :: Bin) :: Nat

-- | Convert from GHC <a>Nat</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :kind! FromGHC 7
--   FromGHC 7 :: Bin
--   = 'BP ('B1 ('B1 'BE))
--   </pre>
type family FromGHC (n :: Nat) :: Bin

-- | Convert to <tt>fin</tt> <a>Nat</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :kind! ToNat Bin5
--   ToNat Bin5 :: Nat
--   = 'S ('S ('S ('S ('S 'Z))))
--   </pre>
type family ToNat (b :: Bin) :: Nat

-- | Convert from <tt>fin</tt> <a>Nat</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :kind! FromNat N.Nat5
--   FromNat N.Nat5 :: Bin
--   = 'BP ('B1 ('B0 'BE))
--   </pre>
type family FromNat (n :: Nat) :: Bin
type Bin0 = 'BZ
type Bin1 = 'BP BinP1
type Bin2 = 'BP BinP2
type Bin3 = 'BP BinP3
type Bin4 = 'BP BinP4
type Bin5 = 'BP BinP5
type Bin6 = 'BP BinP6
type Bin7 = 'BP BinP7
type Bin8 = 'BP BinP8
type Bin9 = 'BP BinP9
instance GHC.Show.Show (Data.Type.Bin.SBin b)
instance Data.Type.Bin.SBinI 'Data.Bin.BZ
instance Data.Type.BinP.SBinPI b => Data.Type.Bin.SBinI ('Data.Bin.BP b)
instance Data.Type.Bin.SBinI b => Data.Boring.Boring (Data.Type.Bin.SBin b)
instance Data.Type.Equality.TestEquality @{Data.Bin.Bin} Data.Type.Bin.SBin
instance Data.GADT.Internal.GShow @Data.Bin.Bin Data.Type.Bin.SBin
instance Control.DeepSeq.NFData (Data.Type.Bin.SBin n)
instance Data.GADT.DeepSeq.GNFData @Data.Bin.Bin Data.Type.Bin.SBin
instance Data.GADT.Internal.GEq @Data.Bin.Bin Data.Type.Bin.SBin

module Data.BinP.PosP

-- | <a>PosP</a> is to <a>BinP</a> is what <tt>Fin</tt> is to <a>Nat</a>,
--   when <tt>n</tt> is <a>Z</a>.
newtype PosP (b :: BinP)
PosP :: PosP' 'Z b -> PosP (b :: BinP)
[unPosP] :: PosP (b :: BinP) -> PosP' 'Z b

-- | <a>PosP'</a> is a structure inside <a>PosP</a>.
data PosP' (n :: Nat) (b :: BinP)
[AtEnd] :: Wrd n -> PosP' n 'BE
[Here] :: Wrd n -> PosP' n ('B1 b)
[There1] :: PosP' ('S n) b -> PosP' n ('B1 b)
[There0] :: PosP' ('S n) b -> PosP' n ('B0 b)

-- | <a>top</a> and <a>pop</a> serve as <tt>FZ</tt> and <tt>FS</tt>, with
--   types specified so type-inference works backwards from the result.
--   
--   <pre>
--   &gt;&gt;&gt; top :: PosP BinP4
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; pop (pop top) :: PosP BinP4
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; pop (pop top) :: PosP BinP9
--   2
--   </pre>
top :: SBinPI b => PosP b

-- | See <a>top</a>.
pop :: (SBinPI a, Pred b ~ 'BP a, Succ a ~ b) => PosP a -> PosP b
explicitShow :: PosP b -> String
explicitShow' :: PosP' n b -> String
explicitShowsPrec :: Int -> PosP b -> ShowS
explicitShowsPrec' :: Int -> PosP' n b -> ShowS

-- | Convert <a>PosP</a> to <a>Natural</a>.
toNatural :: PosP b -> Natural

-- | Convert <a>PosP'</a> to <a>Natural</a>.
toNatural' :: forall n b. SNatI n => PosP' n b -> Natural

-- | Counting to one is boring
--   
--   <pre>
--   &gt;&gt;&gt; boring
--   0
--   </pre>
boring :: PosP 'BE
weakenRight1 :: SBinPI b => PosP b -> PosP (Succ b)
weakenRight1' :: forall b n. SBinP b -> PosP' n b -> PosP' n (Succ b)

-- | <pre>
--   &gt;&gt;&gt; universe :: [PosP BinP9]
--   [0,1,2,3,4,5,6,7,8]
--   </pre>
universe :: forall b. SBinPI b => [PosP b]

-- | This gives a hint, what the <tt>n</tt> parameter means in
--   <a>PosP'</a>.
--   
--   <pre>
--   &gt;&gt;&gt; universe' :: [PosP' N.Nat2 BinP2]
--   [0,1,2,3,4,5,6,7]
--   </pre>
universe' :: forall b n. (SNatI n, SBinPI b) => [PosP' n b]
instance GHC.Classes.Ord (Data.BinP.PosP.PosP b)
instance GHC.Classes.Eq (Data.BinP.PosP.PosP b)
instance GHC.Classes.Eq (Data.BinP.PosP.PosP' n b)
instance (Data.Type.Nat.SNatI n, Data.Type.BinP.SBinPI b) => Test.QuickCheck.Arbitrary.Arbitrary (Data.BinP.PosP.PosP' n b)
instance GHC.Show.Show (Data.BinP.PosP.PosP b)
instance Data.Type.BinP.SBinPI b => GHC.Enum.Bounded (Data.BinP.PosP.PosP b)
instance Control.DeepSeq.NFData (Data.BinP.PosP.PosP b)
instance Data.Type.BinP.SBinPI b => Test.QuickCheck.Arbitrary.Arbitrary (Data.BinP.PosP.PosP b)
instance Test.QuickCheck.Arbitrary.CoArbitrary (Data.BinP.PosP.PosP b)
instance Data.Type.BinP.SBinPI b => Test.QuickCheck.Function.Function (Data.BinP.PosP.PosP b)
instance ((b :: Data.BinP.BinP) GHC.Types.~ ('Data.BinP.BE :: Data.BinP.BinP)) => Data.Boring.Boring (Data.BinP.PosP.PosP b)
instance GHC.Classes.Ord (Data.BinP.PosP.PosP' n b)
instance Data.Type.Nat.SNatI n => GHC.Show.Show (Data.BinP.PosP.PosP' n b)
instance (Data.Type.Nat.SNatI n, Data.Type.BinP.SBinPI b) => GHC.Enum.Bounded (Data.BinP.PosP.PosP' n b)
instance Control.DeepSeq.NFData (Data.BinP.PosP.PosP' n b)
instance Data.Type.Nat.SNatI n => Test.QuickCheck.Arbitrary.CoArbitrary (Data.BinP.PosP.PosP' n b)
instance (Data.Type.Nat.SNatI n, Data.Type.BinP.SBinPI b) => Test.QuickCheck.Function.Function (Data.BinP.PosP.PosP' n b)

module Data.Bin.Pos

-- | <a>Pos</a> is to <a>Bin</a> is what <tt>Fin</tt> is to <tt>Nat</tt>.
--   
--   The name is picked, as the lack of better alternatives.
data Pos (b :: Bin)
[Pos] :: PosP b -> Pos ('BP b)

-- | <a>PosP</a> is to <a>BinP</a> is what <tt>Fin</tt> is to <a>Nat</a>,
--   when <tt>n</tt> is <a>Z</a>.
data PosP (b :: BinP)

-- | <a>top</a> and <a>pop</a> serve as <tt>FZ</tt> and <tt>FS</tt>, with
--   types specified so type-inference works backwards from the result.
--   
--   <pre>
--   &gt;&gt;&gt; top :: Pos Bin4
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; pop (pop top) :: Pos Bin4
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; pop (pop top) :: Pos Bin9
--   2
--   </pre>
top :: SBinPI b => Pos ('BP b)

-- | See <a>top</a>.
pop :: (SBinPI a, Pred b ~ 'BP a, Succ a ~ b) => Pos ('BP a) -> Pos ('BP b)
explicitShow :: Pos b -> String
explicitShowsPrec :: Int -> Pos b -> ShowS

-- | Convert <a>Pos</a> to <a>Natural</a>
--   
--   <pre>
--   &gt;&gt;&gt; map toNatural (universe :: [Pos Bin7])
--   [0,1,2,3,4,5,6]
--   </pre>
toNatural :: Pos b -> Natural

-- | <tt><a>Pos</a> <a>BZ</a></tt> is not inhabited.
absurd :: Pos 'BZ -> b

-- | Counting to one is boring
--   
--   <pre>
--   &gt;&gt;&gt; boring
--   0
--   </pre>
boring :: Pos ('BP 'BE)

-- | Like <tt>FS</tt> for <tt>Fin</tt>.
--   
--   Some tests:
--   
--   <pre>
--   &gt;&gt;&gt; map weakenRight1 $ (universe :: [Pos Bin2])
--   [1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map weakenRight1 $ (universe :: [Pos Bin3])
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map weakenRight1 $ (universe :: [Pos Bin4])
--   [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map weakenRight1 $ (universe :: [Pos Bin5])
--   [1,2,3,4,5]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map weakenRight1 $ (universe :: [Pos Bin6])
--   [1,2,3,4,5,6]
--   </pre>
weakenRight1 :: SBinPI b => Pos ('BP b) -> Pos (Succ'' b)

-- | Universe, i.e. all <tt>[Pos b]</tt>
--   
--   <pre>
--   &gt;&gt;&gt; universe :: [Pos Bin9]
--   [0,1,2,3,4,5,6,7,8]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse_ (putStrLn . explicitShow) (universe :: [Pos Bin5])
--   Pos (PosP (Here WE))
--   Pos (PosP (There1 (There0 (AtEnd 0b00))))
--   Pos (PosP (There1 (There0 (AtEnd 0b01))))
--   Pos (PosP (There1 (There0 (AtEnd 0b10))))
--   Pos (PosP (There1 (There0 (AtEnd 0b11))))
--   </pre>
universe :: forall b. SBinI b => [Pos b]
instance GHC.Classes.Eq (Data.Bin.Pos.Pos b)
instance GHC.Classes.Ord (Data.Bin.Pos.Pos b)
instance GHC.Show.Show (Data.Bin.Pos.Pos b)
instance (Data.Type.BinP.SBinPI n, (b :: Data.Bin.Bin) GHC.Types.~ ('Data.Bin.BP n :: Data.Bin.Bin)) => GHC.Enum.Bounded (Data.Bin.Pos.Pos b)
instance Control.DeepSeq.NFData (Data.Bin.Pos.Pos b)
instance (Data.Type.BinP.SBinPI n, (b :: Data.Bin.Bin) GHC.Types.~ ('Data.Bin.BP n :: Data.Bin.Bin)) => Test.QuickCheck.Arbitrary.Arbitrary (Data.Bin.Pos.Pos b)
instance Test.QuickCheck.Arbitrary.CoArbitrary (Data.Bin.Pos.Pos b)
instance (Data.Type.BinP.SBinPI n, (b :: Data.Bin.Bin) GHC.Types.~ ('Data.Bin.BP n :: Data.Bin.Bin)) => Test.QuickCheck.Function.Function (Data.Bin.Pos.Pos b)
instance ((b :: Data.Bin.Bin) GHC.Types.~ ('Data.Bin.BP 'Data.BinP.BE :: Data.Bin.Bin)) => Data.Boring.Boring (Data.Bin.Pos.Pos b)
instance ((b :: Data.Bin.Bin) GHC.Types.~ ('Data.Bin.BZ :: Data.Bin.Bin)) => Data.Boring.Absurd (Data.Bin.Pos.Pos b)
