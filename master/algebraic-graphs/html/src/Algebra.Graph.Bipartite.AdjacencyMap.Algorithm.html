<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE LambdaCase #-}</span><span>
</span><span id="line-2"></span><span class="hs-comment">----------------------------------------------------------------------------</span><span>
</span><span id="line-3"></span><span class="hs-comment">-- |</span><span>
</span><span id="line-4"></span><span class="hs-comment">-- Module     : Algebra.Graph.Bipartite.AdjacencyMap.Algorithm</span><span>
</span><span id="line-5"></span><span class="hs-comment">-- Copyright  : (c) Andrey Mokhov 2016-2022</span><span>
</span><span id="line-6"></span><span class="hs-comment">-- License    : MIT (see the file LICENSE)</span><span>
</span><span id="line-7"></span><span class="hs-comment">-- Maintainer : andrey.mokhov@gmail.com</span><span>
</span><span id="line-8"></span><span class="hs-comment">-- Stability  : experimental</span><span>
</span><span id="line-9"></span><span class="hs-comment">--</span><span>
</span><span id="line-10"></span><span class="hs-comment">-- __Alga__ is a library for algebraic construction and manipulation of graphs</span><span>
</span><span id="line-11"></span><span class="hs-comment">-- in Haskell. See &lt;https://github.com/snowleopard/alga-paper this paper&gt; for</span><span>
</span><span id="line-12"></span><span class="hs-comment">-- the motivation behind the library, the underlying theory, and</span><span>
</span><span id="line-13"></span><span class="hs-comment">-- implementation details.</span><span>
</span><span id="line-14"></span><span class="hs-comment">--</span><span>
</span><span id="line-15"></span><span class="hs-comment">-- This module provides several basic algorithms on undirected bipartite graphs.</span><span>
</span><span id="line-16"></span><span class="hs-comment">----------------------------------------------------------------------------</span><span>
</span><span id="line-17"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Algebra.Graph.Bipartite.AdjacencyMap.Algorithm</span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-18"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Bipartiteness test</span></span><span>
</span><span id="line-19"></span><span>    </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#OddCycle"><span class="hs-identifier">OddCycle</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#detectParts"><span class="hs-identifier">detectParts</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-20"></span><span>
</span><span id="line-21"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Matchings</span></span><span>
</span><span id="line-22"></span><span>    </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#Matching"><span class="hs-identifier">Matching</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#pairOfLeft"><span class="hs-identifier">pairOfLeft</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#pairOfRight"><span class="hs-identifier">pairOfRight</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#matching"><span class="hs-identifier">matching</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#isMatchingOf"><span class="hs-identifier">isMatchingOf</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#matchingSize"><span class="hs-identifier">matchingSize</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-23"></span><span>    </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#maxMatching"><span class="hs-identifier">maxMatching</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-24"></span><span>
</span><span id="line-25"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Vertex covers</span></span><span>
</span><span id="line-26"></span><span>    </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#VertexCover"><span class="hs-identifier">VertexCover</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#isVertexCoverOf"><span class="hs-identifier">isVertexCoverOf</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#vertexCoverSize"><span class="hs-identifier">vertexCoverSize</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#minVertexCover"><span class="hs-identifier">minVertexCover</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-27"></span><span>
</span><span id="line-28"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Independent sets</span></span><span>
</span><span id="line-29"></span><span>    </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#IndependentSet"><span class="hs-identifier">IndependentSet</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#isIndependentSetOf"><span class="hs-identifier">isIndependentSetOf</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#independentSetSize"><span class="hs-identifier">independentSetSize</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#maxIndependentSet"><span class="hs-identifier">maxIndependentSet</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-30"></span><span>
</span><span id="line-31"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Miscellaneous</span></span><span>
</span><span id="line-32"></span><span>    </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#augmentingPath"><span class="hs-identifier">augmentingPath</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#consistentMatching"><span class="hs-identifier">consistentMatching</span></a></span><span>
</span><span id="line-33"></span><span>    </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-34"></span><span>
</span><span id="line-35"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.html"><span class="hs-identifier">Algebra.Graph.Bipartite.AdjacencyMap</span></a></span><span>
</span><span id="line-36"></span><span>
</span><span id="line-37"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier">Control.Monad</span></a></span><span>             </span><span class="hs-special">(</span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier">guard</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier">when</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-38"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../../../transformers/html/src"><span class="hs-identifier">Control.Monad.Trans.Class</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../../../transformers/html/src"><span class="hs-identifier">lift</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-39"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../../../transformers/html/src"><span class="hs-identifier">Control.Monad.Trans.Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../../../transformers/html/src"><span class="hs-identifier">MaybeT</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-40"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../../../transformers/html/src"><span class="hs-identifier">Control.Monad.Trans.State</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../../../transformers/html/src"><span class="hs-identifier">State</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../../../transformers/html/src"><span class="hs-identifier">runState</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../../../transformers/html/src"><span class="hs-identifier">get</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../../../transformers/html/src"><span class="hs-identifier">put</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../../../transformers/html/src"><span class="hs-identifier">modify</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-41"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier">Control.Monad.ST</span></a></span><span>          </span><span class="hs-special">(</span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier">ST</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier">runST</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-42"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier">Data.Either</span></a></span><span>               </span><span class="hs-special">(</span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier">fromLeft</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-43"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier">Data.Foldable</span></a></span><span>             </span><span class="hs-special">(</span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier">asum</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier">foldl'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-44"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier">Data.Functor</span></a></span><span>              </span><span class="hs-special">(</span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-operator">($&gt;)</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-45"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier">Data.List</span></a></span><span>                 </span><span class="hs-special">(</span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier">sort</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-46"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier">Data.Maybe</span></a></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier">fromJust</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-47"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier">Data.STRef</span></a></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier">STRef</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier">newSTRef</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier">readSTRef</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier">writeSTRef</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier">modifySTRef</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-48"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier">GHC.Generics</span></a></span><span>
</span><span id="line-49"></span><span>
</span><span id="line-50"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="Algebra.Graph.AdjacencyMap.html"><span class="hs-identifier">Algebra.Graph.AdjacencyMap</span></a></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">AM</span></span><span>
</span><span id="line-51"></span><span>
</span><span id="line-52"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="../../../../containers/html/src"><span class="hs-identifier">Data.Map.Strict</span></a></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Map</span></span><span>
</span><span id="line-53"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="../../../../containers/html/src"><span class="hs-identifier">Data.Set</span></a></span><span>        </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Set</span></span><span>
</span><span id="line-54"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="../../../../containers/html/src"><span class="hs-identifier">Data.Sequence</span></a></span><span>   </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Seq</span></span><span>
</span><span id="line-55"></span><span>
</span><span id="line-56"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../../../containers/html/src"><span class="hs-identifier">Data.Map.Strict</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../../../containers/html/src"><span class="hs-identifier">Map</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-57"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../../../containers/html/src"><span class="hs-identifier">Data.Set</span></a></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="../../../../containers/html/src"><span class="hs-identifier">Set</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-58"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../../../containers/html/src"><span class="hs-identifier">Data.Sequence</span></a></span><span>   </span><span class="hs-special">(</span><span class="annot"><a href="../../../../containers/html/src"><span class="hs-identifier">Seq</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../../../containers/html/src"><span class="hs-identifier">ViewL</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../../../containers/html/src"><span class="hs-operator">(|&gt;)</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-59"></span><span>
</span><span id="line-60"></span><span class="hs-comment">-- TODO: Make this representation type-safe</span><span>
</span><span id="line-61"></span><span class="hs-comment">-- | A cycle of odd length. For example, @[1,2,3]@ represents the cycle</span><span>
</span><span id="line-62"></span><span class="hs-comment">-- @1@ @-&gt;@ @2@ @-&gt;@ @3@ @-&gt;@ @1@.</span><span>
</span><span id="line-63"></span><span class="hs-keyword">type</span><span> </span><span id="OddCycle"><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#OddCycle"><span class="hs-identifier hs-var">OddCycle</span></a></span></span><span> </span><span id="local-6989586621679119066"><span class="annot"><a href="#local-6989586621679119066"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679119066"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-64"></span><span>
</span><span id="line-65"></span><span class="hs-keyword">data</span><span> </span><span id="Part"><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#Part"><span class="hs-identifier hs-var">Part</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="LeftPart"><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#LeftPart"><span class="hs-identifier hs-var">LeftPart</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="RightPart"><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#RightPart"><span class="hs-identifier hs-var">RightPart</span></a></span></span><span> </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679119058"><span id="local-6989586621679119060"><span id="local-6989586621679119062"><span class="annot"><span class="annottext">Int -&gt; Part -&gt; ShowS
[Part] -&gt; ShowS
Part -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [Part] -&gt; ShowS
$cshowList :: [Part] -&gt; ShowS
show :: Part -&gt; String
$cshow :: Part -&gt; String
showsPrec :: Int -&gt; Part -&gt; ShowS
$cshowsPrec :: Int -&gt; Part -&gt; ShowS
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></a></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679119053"><span id="local-6989586621679119055"><span class="annot"><span class="annottext">Part -&gt; Part -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Part -&gt; Part -&gt; Bool
$c/= :: Part -&gt; Part -&gt; Bool
== :: Part -&gt; Part -&gt; Bool
$c== :: Part -&gt; Part -&gt; Bool
</span><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-66"></span><span>
</span><span id="line-67"></span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#otherPart"><span class="hs-identifier hs-type">otherPart</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#Part"><span class="hs-identifier hs-type">Part</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#Part"><span class="hs-identifier hs-type">Part</span></a></span><span>
</span><span id="line-68"></span><span id="otherPart"><span class="annot"><span class="annottext">otherPart :: Part -&gt; Part
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#otherPart"><span class="hs-identifier hs-var hs-var">otherPart</span></a></span></span><span> </span><span class="annot"><span class="annottext">Part
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#LeftPart"><span class="hs-identifier hs-var">LeftPart</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Part
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#RightPart"><span class="hs-identifier hs-var">RightPart</span></a></span><span>
</span><span id="line-69"></span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#otherPart"><span class="hs-identifier hs-var">otherPart</span></a></span><span> </span><span class="annot"><span class="annottext">Part
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#RightPart"><span class="hs-identifier hs-var">RightPart</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Part
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#LeftPart"><span class="hs-identifier hs-var">LeftPart</span></a></span><span>
</span><span id="line-70"></span><span>
</span><span id="line-71"></span><span class="hs-comment">-- | Test the bipartiteness of a given &quot;Algebra.Graph.AdjacencyMap&quot;. In case of</span><span>
</span><span id="line-72"></span><span class="hs-comment">-- success, return an 'AdjacencyMap' with the same set of edges and each vertex</span><span>
</span><span id="line-73"></span><span class="hs-comment">-- marked with the part it belongs to. In case of failure, return any cycle of</span><span>
</span><span id="line-74"></span><span class="hs-comment">-- odd length in the graph.</span><span>
</span><span id="line-75"></span><span class="hs-comment">--</span><span>
</span><span id="line-76"></span><span class="hs-comment">-- The returned partition is lexicographically smallest, assuming that vertices</span><span>
</span><span id="line-77"></span><span class="hs-comment">-- of the left part precede all the vertices of the right part.</span><span>
</span><span id="line-78"></span><span class="hs-comment">--</span><span>
</span><span id="line-79"></span><span class="hs-comment">-- The returned cycle is optimal in the following sense: there exists a path</span><span>
</span><span id="line-80"></span><span class="hs-comment">-- that is either empty or ends in a vertex adjacent to the first vertex in the</span><span>
</span><span id="line-81"></span><span class="hs-comment">-- cycle, such that all vertices in @path@ @++@ @cycle@ are distinct and</span><span>
</span><span id="line-82"></span><span class="hs-comment">-- @path@ @++@ @cycle@ is lexicographically smallest among all such pairs of</span><span>
</span><span id="line-83"></span><span class="hs-comment">-- paths and cycles.</span><span>
</span><span id="line-84"></span><span class="hs-comment">--</span><span>
</span><span id="line-85"></span><span class="hs-comment">-- /Note/: since 'AdjacencyMap' represents /undirected/ bipartite graphs, all</span><span>
</span><span id="line-86"></span><span class="hs-comment">-- edges in the input graph are treated as undirected. See the examples and the</span><span>
</span><span id="line-87"></span><span class="hs-comment">-- correctness property for a clarification.</span><span>
</span><span id="line-88"></span><span class="hs-comment">--</span><span>
</span><span id="line-89"></span><span class="hs-comment">-- Complexity: /O((n + m) * log(n))/ time and /O(n + m)/ memory.</span><span>
</span><span id="line-90"></span><span class="hs-comment">--</span><span>
</span><span id="line-91"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-92"></span><span class="hs-comment">-- detectParts 'Algebra.Graph.AdjacencyMap.empty'                                       == Right 'empty'</span><span>
</span><span id="line-93"></span><span class="hs-comment">-- detectParts ('Algebra.Graph.AdjacencyMap.vertex' x)                                  == Right ('leftVertex' x)</span><span>
</span><span id="line-94"></span><span class="hs-comment">-- detectParts ('Algebra.Graph.AdjacencyMap.edge' x x)                                  == Left [x]</span><span>
</span><span id="line-95"></span><span class="hs-comment">-- detectParts ('Algebra.Graph.AdjacencyMap.edge' 1 2)                                  == Right ('edge' 1 2)</span><span>
</span><span id="line-96"></span><span class="hs-comment">-- detectParts (1 * (2 + 3))                               == Right ('edges' [(1,2), (1,3)])</span><span>
</span><span id="line-97"></span><span class="hs-comment">-- detectParts (1 * 2 * 3)                                 == Left [1, 2, 3]</span><span>
</span><span id="line-98"></span><span class="hs-comment">-- detectParts ((1 + 3) * (2 + 4) + 6 * 5)                 == Right ('swap' (1 + 3) * (2 + 4) + 'swap' 5 * 6)</span><span>
</span><span id="line-99"></span><span class="hs-comment">-- detectParts ((1 * 3 * 4) + 2 * (1 + 2))                 == Left [2]</span><span>
</span><span id="line-100"></span><span class="hs-comment">-- detectParts ('Algebra.Graph.AdjacencyMap.clique' [1..10])                            == Left [1, 2, 3]</span><span>
</span><span id="line-101"></span><span class="hs-comment">-- detectParts ('Algebra.Graph.AdjacencyMap.circuit' [1..10])                           == Right ('circuit' [(x, x + 1) | x &lt;- [1,3,5,7,9]])</span><span>
</span><span id="line-102"></span><span class="hs-comment">-- detectParts ('Algebra.Graph.AdjacencyMap.circuit' [1..11])                           == Left [1..11]</span><span>
</span><span id="line-103"></span><span class="hs-comment">-- detectParts ('Algebra.Graph.AdjacencyMap.biclique' [] xs)                            == Right ('vertices' xs [])</span><span>
</span><span id="line-104"></span><span class="hs-comment">-- detectParts ('Algebra.Graph.AdjacencyMap.biclique' ('map' Left (x:xs)) ('map' Right ys)) == Right ('biclique' ('map' Left (x:xs)) ('map' Right ys))</span><span>
</span><span id="line-105"></span><span class="hs-comment">-- 'isRight' (detectParts ('Algebra.Graph.AdjacencyMap.star' x ys))                       == 'notElem' x ys</span><span>
</span><span id="line-106"></span><span class="hs-comment">-- 'isRight' (detectParts ('fromBipartite' ('toBipartite' x)))   == True</span><span>
</span><span id="line-107"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-108"></span><span class="hs-comment">--</span><span>
</span><span id="line-109"></span><span class="hs-comment">-- The correctness of 'detectParts' can be expressed by the following property:</span><span>
</span><span id="line-110"></span><span class="hs-comment">--</span><span>
</span><span id="line-111"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-112"></span><span class="hs-comment">-- let undirected = 'Algebra.Graph.AdjacencyMap.symmetricClosure' input in</span><span>
</span><span id="line-113"></span><span class="hs-comment">-- case detectParts input of</span><span>
</span><span id="line-114"></span><span class="hs-comment">--     Left cycle -&gt; 'mod' (length cycle) 2 == 1 &amp;&amp; 'Algebra.Graph.AdjacencyMap.isSubgraphOf' ('Algebra.Graph.AdjacencyMap.circuit' cycle) undirected</span><span>
</span><span id="line-115"></span><span class="hs-comment">--     Right result -&gt; 'Algebra.Graph.AdjacencyMap.gmap' 'Data.Either.Extra.fromEither' ('fromBipartite' result) == undirected</span><span>
</span><span id="line-116"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-117"></span><span id="local-6989586621679119384"><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#detectParts"><span class="hs-identifier hs-type">detectParts</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Ord</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119384"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Algebra.Graph.AdjacencyMap.html#AdjacencyMap"><span class="hs-identifier hs-type">AM.AdjacencyMap</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119384"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">Either</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#OddCycle"><span class="hs-identifier hs-type">OddCycle</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119384"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.html#AdjacencyMap"><span class="hs-identifier hs-type">AdjacencyMap</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119384"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119384"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-118"></span><span id="detectParts"><span class="annot"><span class="annottext">detectParts :: forall a.
Ord a =&gt;
AdjacencyMap a -&gt; Either (OddCycle a) (AdjacencyMap a a)
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#detectParts"><span class="hs-identifier hs-var hs-var">detectParts</span></a></span></span><span> </span><span id="local-6989586621679119002"><span class="annot"><span class="annottext">AdjacencyMap a
</span><a href="#local-6989586621679119002"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">forall s a. State s a -&gt; s -&gt; (a, s)
</span><a href="../../../../transformers/html/src"><span class="hs-identifier hs-var">runState</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. MaybeT m a -&gt; m (Maybe a)
</span><a href="../../../../transformers/html/src"><span class="hs-identifier hs-var">runMaybeT</span></a></span><span> </span><span class="annot"><span class="annottext">MaybeT (StateT (Map a Part) Identity) (OddCycle a)
</span><a href="#local-6989586621679119000"><span class="hs-identifier hs-var">dfs</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall k a. Map k a
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Map.empty</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-119"></span><span>    </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe (OddCycle a)
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">Nothing</span></a></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679118998"><span class="annot"><span class="annottext">Map a Part
</span><a href="#local-6989586621679118998"><span class="hs-identifier hs-var">partMap</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a b. b -&gt; Either a b
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">Right</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b c.
(Ord a, Ord b, Ord c) =&gt;
(a -&gt; Either b c) -&gt; AdjacencyMap a -&gt; AdjacencyMap b c
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.html#toBipartiteWith"><span class="hs-identifier hs-var">toBipartiteWith</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall {b}. Ord b =&gt; Map b Part -&gt; b -&gt; Either b b
</span><a href="#local-6989586621679118996"><span class="hs-identifier hs-var">toEither</span></a></span><span> </span><span class="annot"><span class="annottext">Map a Part
</span><a href="#local-6989586621679118998"><span class="hs-identifier hs-var">partMap</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">AdjacencyMap a
</span><a href="#local-6989586621679118995"><span class="hs-identifier hs-var">g</span></a></span><span>
</span><span id="line-120"></span><span>    </span><span class="hs-special">(</span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">Just</span></a></span><span> </span><span id="local-6989586621679118994"><span class="annot"><span class="annottext">OddCycle a
</span><a href="#local-6989586621679118994"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Map a Part
</span><span class="hs-identifier">_</span></span><span>      </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a b. a -&gt; Either a b
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">Left</span></a></span><span>  </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall {a}. Eq a =&gt; [a] -&gt; [a]
</span><a href="#local-6989586621679118993"><span class="hs-identifier hs-var">oddCycle</span></a></span><span> </span><span class="annot"><span class="annottext">OddCycle a
</span><a href="#local-6989586621679118994"><span class="hs-identifier hs-var">c</span></a></span><span>
</span><span id="line-121"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-122"></span><span>    </span><span class="hs-comment">-- g :: AM.AdjacencyMap a</span><span>
</span><span id="line-123"></span><span>    </span><span id="local-6989586621679118995"><span class="annot"><span class="annottext">g :: AdjacencyMap a
</span><a href="#local-6989586621679118995"><span class="hs-identifier hs-var hs-var">g</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; AdjacencyMap a -&gt; AdjacencyMap a
</span><a href="Algebra.Graph.AdjacencyMap.html#symmetricClosure"><span class="hs-identifier hs-var">AM.symmetricClosure</span></a></span><span> </span><span class="annot"><span class="annottext">AdjacencyMap a
</span><a href="#local-6989586621679119002"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-124"></span><span>
</span><span id="line-125"></span><span>    </span><span class="hs-comment">-- type PartMap a = Map a Part</span><span>
</span><span id="line-126"></span><span>    </span><span class="hs-comment">-- type PartMonad a = MaybeT (State (PartMap a)) [a]</span><span>
</span><span id="line-127"></span><span>    </span><span class="hs-comment">-- dfs :: PartMonad a</span><span>
</span><span id="line-128"></span><span>    </span><span id="local-6989586621679119000"><span class="annot"><span class="annottext">dfs :: MaybeT (StateT (Map a Part) Identity) (OddCycle a)
</span><a href="#local-6989586621679119000"><span class="hs-identifier hs-var hs-var">dfs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (f :: * -&gt; *) a.
(Foldable t, Alternative f) =&gt;
t (f a) -&gt; f a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">asum</span></a></span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">a -&gt; MaybeT (StateT (Map a Part) Identity) (OddCycle a)
</span><a href="#local-6989586621679118991"><span class="hs-identifier hs-var">processVertex</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118990"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679118990"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118990"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall a. AdjacencyMap a -&gt; [a]
</span><a href="Algebra.Graph.AdjacencyMap.html#vertexList"><span class="hs-identifier hs-var">AM.vertexList</span></a></span><span> </span><span class="annot"><span class="annottext">AdjacencyMap a
</span><a href="#local-6989586621679118995"><span class="hs-identifier hs-var">g</span></a></span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-129"></span><span>
</span><span id="line-130"></span><span>    </span><span class="hs-comment">-- processVertex :: a -&gt; PartMonad a</span><span>
</span><span id="line-131"></span><span>    </span><span id="local-6989586621679118991"><span class="annot"><span class="annottext">processVertex :: a -&gt; MaybeT (StateT (Map a Part) Identity) (OddCycle a)
</span><a href="#local-6989586621679118991"><span class="hs-identifier hs-var hs-var">processVertex</span></a></span></span><span> </span><span id="local-6989586621679118988"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118988"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679118987"><span class="annot"><span class="annottext">Map a Part
</span><a href="#local-6989586621679118987"><span class="hs-identifier hs-var">partMap</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
(MonadTrans t, Monad m) =&gt;
m a -&gt; t m a
</span><a href="../../../../transformers/html/src"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) s. Monad m =&gt; StateT s m s
</span><a href="../../../../transformers/html/src"><span class="hs-identifier hs-var">get</span></a></span><span>
</span><span id="line-132"></span><span>                         </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *). Alternative f =&gt; Bool -&gt; f ()
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">guard</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Bool
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Map.notMember</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118988"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">Map a Part
</span><a href="#local-6989586621679118987"><span class="hs-identifier hs-var">partMap</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-133"></span><span>                         </span><span class="annot"><span class="annottext">Part -&gt; a -&gt; MaybeT (StateT (Map a Part) Identity) (OddCycle a)
</span><a href="#local-6989586621679118985"><span class="hs-identifier hs-var">inVertex</span></a></span><span> </span><span class="annot"><span class="annottext">Part
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#LeftPart"><span class="hs-identifier hs-var">LeftPart</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118988"><span class="hs-identifier hs-var">v</span></a></span><span>
</span><span id="line-134"></span><span>
</span><span id="line-135"></span><span>    </span><span class="hs-comment">-- inVertex :: Part -&gt; a -&gt; PartMonad a</span><span>
</span><span id="line-136"></span><span>    </span><span id="local-6989586621679118985"><span class="annot"><span class="annottext">inVertex :: Part -&gt; a -&gt; MaybeT (StateT (Map a Part) Identity) (OddCycle a)
</span><a href="#local-6989586621679118985"><span class="hs-identifier hs-var hs-var">inVertex</span></a></span></span><span> </span><span id="local-6989586621679118984"><span class="annot"><span class="annottext">Part
</span><a href="#local-6989586621679118984"><span class="hs-identifier hs-var">vertexPart</span></a></span></span><span> </span><span id="local-6989586621679118983"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118983"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118983"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; [a] -&gt; [a]
</span><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-glyph hs-var">:</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">&lt;$&gt;</span></a></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-137"></span><span>        </span><span class="annot"><span class="annottext">forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
(MonadTrans t, Monad m) =&gt;
m a -&gt; t m a
</span><a href="../../../../transformers/html/src"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) s. Monad m =&gt; (s -&gt; s) -&gt; StateT s m ()
</span><a href="../../../../transformers/html/src"><span class="hs-identifier hs-var">modify</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall k a. Ord k =&gt; k -&gt; a -&gt; Map k a -&gt; Map k a
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Map.insert</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118983"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">Part
</span><a href="#local-6989586621679118984"><span class="hs-identifier hs-var">vertexPart</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-138"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679118980"><span class="annot"><span class="annottext">otherVertexPart :: Part
</span><a href="#local-6989586621679118980"><span class="hs-identifier hs-var hs-var">otherVertexPart</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Part -&gt; Part
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#otherPart"><span class="hs-identifier hs-var">otherPart</span></a></span><span> </span><span class="annot"><span class="annottext">Part
</span><a href="#local-6989586621679118984"><span class="hs-identifier hs-var">vertexPart</span></a></span><span>
</span><span id="line-139"></span><span>        </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (f :: * -&gt; *) a.
(Foldable t, Alternative f) =&gt;
t (f a) -&gt; f a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">asum</span></a></span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">Part -&gt; a -&gt; MaybeT (StateT (Map a Part) Identity) (OddCycle a)
</span><a href="#local-6989586621679118979"><span class="hs-identifier hs-var">onEdge</span></a></span><span> </span><span class="annot"><span class="annottext">Part
</span><a href="#local-6989586621679118980"><span class="hs-identifier hs-var">otherVertexPart</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118978"><span class="hs-identifier hs-var">u</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679118978"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118978"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall a. Set a -&gt; [a]
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Set.toAscList</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Ord a =&gt; a -&gt; AdjacencyMap a -&gt; Set a
</span><a href="Algebra.Graph.AdjacencyMap.html#postSet"><span class="hs-identifier hs-var">AM.postSet</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118983"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">AdjacencyMap a
</span><a href="#local-6989586621679118995"><span class="hs-identifier hs-var">g</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-140"></span><span>
</span><span id="line-141"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="#local-6989586621679118979"><span class="hs-pragma hs-type">onEdge</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-142"></span><span>    </span><span class="hs-comment">-- onEdge :: Part -&gt; a -&gt; PartMonad a</span><span>
</span><span id="line-143"></span><span>    </span><span id="local-6989586621679118979"><span class="annot"><span class="annottext">onEdge :: Part -&gt; a -&gt; MaybeT (StateT (Map a Part) Identity) (OddCycle a)
</span><a href="#local-6989586621679118979"><span class="hs-identifier hs-var hs-var">onEdge</span></a></span></span><span> </span><span id="local-6989586621679118975"><span class="annot"><span class="annottext">Part
</span><a href="#local-6989586621679118975"><span class="hs-identifier hs-var">vertexPart</span></a></span></span><span> </span><span id="local-6989586621679118974"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118974"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679118973"><span class="annot"><span class="annottext">Map a Part
</span><a href="#local-6989586621679118973"><span class="hs-identifier hs-var">partMap</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
(MonadTrans t, Monad m) =&gt;
m a -&gt; t m a
</span><a href="../../../../transformers/html/src"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) s. Monad m =&gt; StateT s m s
</span><a href="../../../../transformers/html/src"><span class="hs-identifier hs-var">get</span></a></span><span>
</span><span id="line-144"></span><span>                             </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Maybe a
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Map.lookup</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118974"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">Map a Part
</span><a href="#local-6989586621679118973"><span class="hs-identifier hs-var">partMap</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-145"></span><span>                                 </span><span class="annot"><span class="annottext">Maybe Part
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">Nothing</span></a></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Part -&gt; a -&gt; MaybeT (StateT (Map a Part) Identity) (OddCycle a)
</span><a href="#local-6989586621679118985"><span class="hs-identifier hs-var">inVertex</span></a></span><span> </span><span class="annot"><span class="annottext">Part
</span><a href="#local-6989586621679118975"><span class="hs-identifier hs-var">vertexPart</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118974"><span class="hs-identifier hs-var">v</span></a></span><span>
</span><span id="line-146"></span><span>                                 </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">Just</span></a></span><span> </span><span id="local-6989586621679118971"><span class="annot"><span class="annottext">Part
</span><a href="#local-6989586621679118971"><span class="hs-identifier hs-var">part</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *). Alternative f =&gt; Bool -&gt; f ()
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">guard</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Part
</span><a href="#local-6989586621679118975"><span class="hs-identifier hs-var">vertexPart</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-operator hs-var">/=</span></a></span><span> </span><span class="annot"><span class="annottext">Part
</span><a href="#local-6989586621679118971"><span class="hs-identifier hs-var">part</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-147"></span><span>                                                 </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">return</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118974"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- found a cycle!</span><span>
</span><span id="line-148"></span><span>
</span><span id="line-149"></span><span>    </span><span class="hs-comment">-- toEither :: PartMap a -&gt; a -&gt; Either a a</span><span>
</span><span id="line-150"></span><span>    </span><span id="local-6989586621679118996"><span class="annot"><span class="annottext">toEither :: Map b Part -&gt; b -&gt; Either b b
</span><a href="#local-6989586621679118996"><span class="hs-identifier hs-var hs-var">toEither</span></a></span></span><span> </span><span id="local-6989586621679118965"><span class="annot"><span class="annottext">Map b Part
</span><a href="#local-6989586621679118965"><span class="hs-identifier hs-var">partMap</span></a></span></span><span> </span><span id="local-6989586621679118964"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118964"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">forall a. HasCallStack =&gt; Maybe a -&gt; a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">fromJust</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Maybe a
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Map.lookup</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118964"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">Map b Part
</span><a href="#local-6989586621679118965"><span class="hs-identifier hs-var">partMap</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-151"></span><span>                             </span><span class="annot"><span class="annottext">Part
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#LeftPart"><span class="hs-identifier hs-var">LeftPart</span></a></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a b. a -&gt; Either a b
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">Left</span></a></span><span>  </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118964"><span class="hs-identifier hs-var">v</span></a></span><span>
</span><span id="line-152"></span><span>                             </span><span class="annot"><span class="annottext">Part
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#RightPart"><span class="hs-identifier hs-var">RightPart</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a b. b -&gt; Either a b
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">Right</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118964"><span class="hs-identifier hs-var">v</span></a></span><span>
</span><span id="line-153"></span><span>
</span><span id="line-154"></span><span>    </span><span class="hs-comment">-- oddCycle :: [a] -&gt; [a]</span><span>
</span><span id="line-155"></span><span>    </span><span id="local-6989586621679118993"><span class="annot"><span class="annottext">oddCycle :: [a] -&gt; [a]
</span><a href="#local-6989586621679118993"><span class="hs-identifier hs-var hs-var">oddCycle</span></a></span></span><span> </span><span id="local-6989586621679118961"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679118961"><span class="hs-identifier hs-var">pathToCycle</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. [a] -&gt; [a]
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">init</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. (a -&gt; Bool) -&gt; [a] -&gt; [a]
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">dropWhile</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-operator hs-var">/=</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118958"><span class="hs-identifier hs-var">lastVertex</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679118961"><span class="hs-identifier hs-var">pathToCycle</span></a></span><span>
</span><span id="line-156"></span><span>      </span><span class="hs-keyword">where</span><span>
</span><span id="line-157"></span><span>        </span><span id="local-6989586621679118958"><span class="annot"><span class="annottext">lastVertex :: a
</span><a href="#local-6989586621679118958"><span class="hs-identifier hs-var hs-var">lastVertex</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. [a] -&gt; a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">last</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679118961"><span class="hs-identifier hs-var">pathToCycle</span></a></span><span>
</span><span id="line-158"></span><span>
</span><span id="line-159"></span><span class="hs-comment">-- | A /matching/ is a set of pairwise non-adjacent edges between the two parts</span><span>
</span><span id="line-160"></span><span class="hs-comment">-- of a bipartite graph.</span><span>
</span><span id="line-161"></span><span class="hs-comment">--</span><span>
</span><span id="line-162"></span><span class="hs-comment">-- The 'Show' instance is defined using the 'matching' function, with the edges</span><span>
</span><span id="line-163"></span><span class="hs-comment">-- listed in the ascending order of left vertices.</span><span>
</span><span id="line-164"></span><span class="hs-comment">--</span><span>
</span><span id="line-165"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-166"></span><span class="hs-comment">-- show ('matching' [])                 == &quot;matching []&quot;</span><span>
</span><span id="line-167"></span><span class="hs-comment">-- show ('matching' [(2,\'a\'), (1,\'b\')]) == &quot;matching [(1,\'b\'),(2,\'a\')]&quot;</span><span>
</span><span id="line-168"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-169"></span><span id="local-6989586621679118955"><span id="local-6989586621679118956"></span></span><span class="hs-keyword">data</span><span> </span><span id="Matching"><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#Matching"><span class="hs-identifier hs-var">Matching</span></a></span></span><span> </span><span id="local-6989586621679119311"><span class="annot"><a href="#local-6989586621679119311"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span id="local-6989586621679119310"><span class="annot"><a href="#local-6989586621679119310"><span class="hs-identifier hs-type">b</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Matching"><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#Matching"><span class="hs-identifier hs-var">Matching</span></a></span></span><span> </span><span class="hs-special">{</span><span>
</span><span id="line-170"></span><span>    </span><span class="hs-comment">-- | The map of vertices covered by the matching in the left part to their</span><span>
</span><span id="line-171"></span><span>    </span><span class="hs-comment">-- neighbours in the right part.</span><span>
</span><span id="line-172"></span><span>    </span><span class="hs-comment">-- Complexity: /O(1)/ time.</span><span>
</span><span id="line-173"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-174"></span><span>    </span><span class="hs-comment">-- @</span><span>
</span><span id="line-175"></span><span>    </span><span class="hs-comment">-- pairOfLeft ('matching' [])                 == Map.'Data.Map.Strict.empty'</span><span>
</span><span id="line-176"></span><span>    </span><span class="hs-comment">-- pairOfLeft ('matching' [(2,\'a\'), (1,\'b\')]) == Map.'Data.Map.Strict.fromList' [(1,\'b\'), (2,\'a\')]</span><span>
</span><span id="line-177"></span><span>    </span><span class="hs-comment">-- Map.'Map.size' . pairOfLeft                    == Map.'Map.size' . pairOfRight</span><span>
</span><span id="line-178"></span><span>    </span><span class="hs-comment">-- @</span><span>
</span><span id="line-179"></span><span>    </span><span id="pairOfLeft"><span class="annot"><span class="annottext">forall a b. Matching a b -&gt; Map a b
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#pairOfLeft"><span class="hs-identifier hs-var hs-var">pairOfLeft</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../../../containers/html/src"><span class="hs-identifier hs-type">Map</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119311"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119310"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-180"></span><span>
</span><span id="line-181"></span><span>    </span><span class="hs-comment">-- | The map of vertices covered by the matching in the right part to their</span><span>
</span><span id="line-182"></span><span>    </span><span class="hs-comment">-- neighbours in the left part.</span><span>
</span><span id="line-183"></span><span>    </span><span class="hs-comment">-- Complexity: /O(1)/.</span><span>
</span><span id="line-184"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-185"></span><span>    </span><span class="hs-comment">-- @</span><span>
</span><span id="line-186"></span><span>    </span><span class="hs-comment">-- pairOfRight ('matching' [])                 == Map.'Data.Map.Strict.empty'</span><span>
</span><span id="line-187"></span><span>    </span><span class="hs-comment">-- pairOfRight ('matching' [(2,\'a\'), (1,\'b\')]) == Map.'Data.Map.Strict.fromList' [(\'a\',2), (\'b\',1)]</span><span>
</span><span id="line-188"></span><span>    </span><span class="hs-comment">-- Map.'Map.size' . pairOfRight                    == Map.'Map.size' . pairOfLeft</span><span>
</span><span id="line-189"></span><span>    </span><span class="hs-comment">-- @</span><span>
</span><span id="line-190"></span><span>    </span><span id="pairOfRight"><span class="annot"><span class="annottext">forall a b. Matching a b -&gt; Map b a
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#pairOfRight"><span class="hs-identifier hs-var hs-var">pairOfRight</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../../../containers/html/src"><span class="hs-identifier hs-type">Map</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119310"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119311"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-191"></span><span class="hs-special">}</span><span> </span><span class="hs-keyword">deriving</span><span> </span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall a b x. Rep (Matching a b) x -&gt; Matching a b
forall a b x. Matching a b -&gt; Rep (Matching a b) x
$cto :: forall a b x. Rep (Matching a b) x -&gt; Matching a b
$cfrom :: forall a b x. Matching a b -&gt; Rep (Matching a b) x
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></a></span><span>
</span><span id="line-192"></span><span>
</span><span id="line-193"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679118945"><span id="local-6989586621679118947"><span id="local-6989586621679119303"><span id="local-6989586621679119304"><span class="hs-special">(</span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">Show</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119304"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">Show</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119303"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">Show</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#Matching"><span class="hs-identifier hs-type">Matching</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119304"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119303"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-194"></span><span>    </span><span id="local-6989586621679118942"><span class="annot"><span class="annottext">showsPrec :: Int -&gt; Matching a b -&gt; ShowS
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var hs-var hs-var hs-var">showsPrec</span></a></span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679118940"><span class="annot"><span class="annottext">Matching a b
</span><a href="#local-6989586621679118940"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">showString</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;matching &quot;</span></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Show a =&gt; [a] -&gt; ShowS
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">showList</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall k a. Map k a -&gt; [(k, a)]
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Map.toAscList</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. Matching a b -&gt; Map a b
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#pairOfLeft"><span class="hs-identifier hs-var">pairOfLeft</span></a></span><span> </span><span class="annot"><span class="annottext">Matching a b
</span><a href="#local-6989586621679118940"><span class="hs-identifier hs-var">m</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-195"></span><span>
</span><span id="line-196"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679118933"><span id="local-6989586621679119294"><span id="local-6989586621679119295"><span class="hs-special">(</span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Eq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119295"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Eq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119294"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Eq</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#Matching"><span class="hs-identifier hs-type">Matching</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119295"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119294"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-197"></span><span>    </span><span id="local-6989586621679118930"><span class="annot"><span class="annottext">Matching a b
</span><a href="#local-6989586621679118930"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679118929"><span class="annot"><span class="annottext">== :: Matching a b -&gt; Matching a b -&gt; Bool
</span><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-operator hs-var hs-var hs-var hs-var">==</span></a></span></span><span> </span><span id="local-6989586621679118928"><span class="annot"><span class="annottext">Matching a b
</span><a href="#local-6989586621679118928"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. Matching a b -&gt; Map a b
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#pairOfLeft"><span class="hs-identifier hs-var">pairOfLeft</span></a></span><span> </span><span class="annot"><span class="annottext">Matching a b
</span><a href="#local-6989586621679118930"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-operator hs-var">==</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. Matching a b -&gt; Map a b
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#pairOfLeft"><span class="hs-identifier hs-var">pairOfLeft</span></a></span><span> </span><span class="annot"><span class="annottext">Matching a b
</span><a href="#local-6989586621679118928"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-198"></span><span>
</span><span id="line-199"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679118913"><span id="local-6989586621679118915"><span id="local-6989586621679118917"><span id="local-6989586621679118919"><span id="local-6989586621679118921"><span id="local-6989586621679118923"><span id="local-6989586621679119290"><span id="local-6989586621679119291"><span class="hs-special">(</span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Ord</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119291"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Ord</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119290"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Ord</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#Matching"><span class="hs-identifier hs-type">Matching</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119291"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119290"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span></span></span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-200"></span><span>    </span><span id="local-6989586621679118909"><span class="annot"><span class="annottext">compare :: Matching a b -&gt; Matching a b -&gt; Ordering
</span><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-var hs-var hs-var hs-var">compare</span></a></span></span><span> </span><span id="local-6989586621679118907"><span class="annot"><span class="annottext">Matching a b
</span><a href="#local-6989586621679118907"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679118906"><span class="annot"><span class="annottext">Matching a b
</span><a href="#local-6989586621679118906"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; a -&gt; a -&gt; Ordering
</span><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-var">compare</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. Matching a b -&gt; Map a b
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#pairOfLeft"><span class="hs-identifier hs-var">pairOfLeft</span></a></span><span> </span><span class="annot"><span class="annottext">Matching a b
</span><a href="#local-6989586621679118907"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. Matching a b -&gt; Map a b
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#pairOfLeft"><span class="hs-identifier hs-var">pairOfLeft</span></a></span><span> </span><span class="annot"><span class="annottext">Matching a b
</span><a href="#local-6989586621679118906"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-201"></span><span>
</span><span id="line-202"></span><span id="local-6989586621679119286"><span id="local-6989586621679119287"><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#addEdgeUnsafe"><span class="hs-identifier hs-type">addEdgeUnsafe</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Ord</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119287"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Ord</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119286"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679119287"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679119286"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#Matching"><span class="hs-identifier hs-type">Matching</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119287"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119286"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#Matching"><span class="hs-identifier hs-type">Matching</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119287"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119286"><span class="hs-identifier hs-type">b</span></a></span></span></span><span>
</span><span id="line-203"></span><span id="addEdgeUnsafe"><span class="annot"><span class="annottext">addEdgeUnsafe :: forall a b.
(Ord a, Ord b) =&gt;
a -&gt; b -&gt; Matching a b -&gt; Matching a b
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#addEdgeUnsafe"><span class="hs-identifier hs-var hs-var">addEdgeUnsafe</span></a></span></span><span> </span><span id="local-6989586621679118900"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118900"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="local-6989586621679118899"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118899"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#Matching"><span class="hs-identifier hs-type">Matching</span></a></span><span> </span><span id="local-6989586621679118898"><span class="annot"><span class="annottext">Map a b
</span><a href="#local-6989586621679118898"><span class="hs-identifier hs-var">ab</span></a></span></span><span> </span><span id="local-6989586621679118897"><span class="annot"><span class="annottext">Map b a
</span><a href="#local-6989586621679118897"><span class="hs-identifier hs-var">ba</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. Map a b -&gt; Map b a -&gt; Matching a b
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#Matching"><span class="hs-identifier hs-var">Matching</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall k a. Ord k =&gt; k -&gt; a -&gt; Map k a -&gt; Map k a
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Map.insert</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118900"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118899"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">Map a b
</span><a href="#local-6989586621679118898"><span class="hs-identifier hs-var">ab</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall k a. Ord k =&gt; k -&gt; a -&gt; Map k a -&gt; Map k a
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Map.insert</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118899"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118900"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">Map b a
</span><a href="#local-6989586621679118897"><span class="hs-identifier hs-var">ba</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-204"></span><span>
</span><span id="line-205"></span><span id="local-6989586621679118895"><span id="local-6989586621679118896"><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#addEdge"><span class="hs-identifier hs-type">addEdge</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Ord</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118896"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Ord</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118895"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679118896"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679118895"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#Matching"><span class="hs-identifier hs-type">Matching</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118896"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118895"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#Matching"><span class="hs-identifier hs-type">Matching</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118896"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118895"><span class="hs-identifier hs-type">b</span></a></span></span></span><span>
</span><span id="line-206"></span><span id="addEdge"><span class="annot"><span class="annottext">addEdge :: forall a b.
(Ord a, Ord b) =&gt;
a -&gt; b -&gt; Matching a b -&gt; Matching a b
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#addEdge"><span class="hs-identifier hs-var hs-var">addEdge</span></a></span></span><span> </span><span id="local-6989586621679118881"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118881"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="local-6989586621679118880"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118880"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#Matching"><span class="hs-identifier hs-type">Matching</span></a></span><span> </span><span id="local-6989586621679118879"><span class="annot"><span class="annottext">Map a b
</span><a href="#local-6989586621679118879"><span class="hs-identifier hs-var">ab</span></a></span></span><span> </span><span id="local-6989586621679118878"><span class="annot"><span class="annottext">Map b a
</span><a href="#local-6989586621679118878"><span class="hs-identifier hs-var">ba</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b.
(Ord a, Ord b) =&gt;
a -&gt; b -&gt; Matching a b -&gt; Matching a b
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#addEdgeUnsafe"><span class="hs-identifier hs-var">addEdgeUnsafe</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118881"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118880"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. Map a b -&gt; Map b a -&gt; Matching a b
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#Matching"><span class="hs-identifier hs-var">Matching</span></a></span><span> </span><span class="annot"><span class="annottext">Map a b
</span><a href="#local-6989586621679118877"><span class="hs-identifier hs-var">ab'</span></a></span><span> </span><span class="annot"><span class="annottext">Map b a
</span><a href="#local-6989586621679118876"><span class="hs-identifier hs-var">ba'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-207"></span><span>    </span><span class="hs-keyword">where</span><span>
</span><span id="line-208"></span><span>        </span><span id="local-6989586621679118877"><span class="annot"><span class="annottext">ab' :: Map a b
</span><a href="#local-6989586621679118877"><span class="hs-identifier hs-var hs-var">ab'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118880"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Maybe a
</span><a href="../../../../containers/html/src"><span class="hs-operator hs-var">`Map.lookup`</span></a></span><span> </span><span class="annot"><span class="annottext">Map b a
</span><a href="#local-6989586621679118878"><span class="hs-identifier hs-var">ba</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-209"></span><span>                  </span><span class="annot"><span class="annottext">Maybe a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">Nothing</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Map k a
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Map.delete</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118881"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">Map a b
</span><a href="#local-6989586621679118879"><span class="hs-identifier hs-var">ab</span></a></span><span>
</span><span id="line-210"></span><span>                  </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">Just</span></a></span><span> </span><span id="local-6989586621679118874"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118874"><span class="hs-identifier hs-var">a'</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Map k a
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Map.delete</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118881"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Map k a
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Map.delete</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118874"><span class="hs-identifier hs-var">a'</span></a></span><span> </span><span class="annot"><span class="annottext">Map a b
</span><a href="#local-6989586621679118879"><span class="hs-identifier hs-var">ab</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-211"></span><span>        </span><span id="local-6989586621679118876"><span class="annot"><span class="annottext">ba' :: Map b a
</span><a href="#local-6989586621679118876"><span class="hs-identifier hs-var hs-var">ba'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118881"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Maybe a
</span><a href="../../../../containers/html/src"><span class="hs-operator hs-var">`Map.lookup`</span></a></span><span> </span><span class="annot"><span class="annottext">Map a b
</span><a href="#local-6989586621679118879"><span class="hs-identifier hs-var">ab</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-212"></span><span>                  </span><span class="annot"><span class="annottext">Maybe b
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">Nothing</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Map k a
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Map.delete</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118880"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">Map b a
</span><a href="#local-6989586621679118878"><span class="hs-identifier hs-var">ba</span></a></span><span>
</span><span id="line-213"></span><span>                  </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">Just</span></a></span><span> </span><span id="local-6989586621679118873"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118873"><span class="hs-identifier hs-var">b'</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Map k a
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Map.delete</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118880"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Map k a
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Map.delete</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118873"><span class="hs-identifier hs-var">b'</span></a></span><span> </span><span class="annot"><span class="annottext">Map b a
</span><a href="#local-6989586621679118878"><span class="hs-identifier hs-var">ba</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-214"></span><span>
</span><span id="line-215"></span><span id="local-6989586621679119278"><span id="local-6989586621679119279"><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#leftCovered"><span class="hs-identifier hs-type">leftCovered</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Ord</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119279"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679119279"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#Matching"><span class="hs-identifier hs-type">Matching</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119279"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119278"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Bool</span></a></span></span></span><span>
</span><span id="line-216"></span><span id="leftCovered"><span class="annot"><span class="annottext">leftCovered :: forall a b. Ord a =&gt; a -&gt; Matching a b -&gt; Bool
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#leftCovered"><span class="hs-identifier hs-var hs-var">leftCovered</span></a></span></span><span> </span><span id="local-6989586621679118869"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118869"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Bool
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Map.member</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118869"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. Matching a b -&gt; Map a b
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#pairOfLeft"><span class="hs-identifier hs-var">pairOfLeft</span></a></span><span>
</span><span id="line-217"></span><span>
</span><span id="line-218"></span><span class="hs-comment">-- | Construct a 'Matching' from a list of edges.</span><span>
</span><span id="line-219"></span><span class="hs-comment">-- Complexity: /O(L * log(L))/ time, where /L/ is the length of the given list.</span><span>
</span><span id="line-220"></span><span class="hs-comment">--</span><span>
</span><span id="line-221"></span><span class="hs-comment">-- Edges that appear closer to the end of the list supersede all previous edges.</span><span>
</span><span id="line-222"></span><span class="hs-comment">-- That is, if two edges from the list share a vertex, the one that appears</span><span>
</span><span id="line-223"></span><span class="hs-comment">-- closer to the beginning is ignored.</span><span>
</span><span id="line-224"></span><span class="hs-comment">--</span><span>
</span><span id="line-225"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-226"></span><span class="hs-comment">-- 'pairOfLeft'  (matching [])                     == Map.'Data.Map.Strict.empty'</span><span>
</span><span id="line-227"></span><span class="hs-comment">-- 'pairOfRight' (matching [])                     == Map.'Data.Map.Strict.empty'</span><span>
</span><span id="line-228"></span><span class="hs-comment">-- 'pairOfLeft'  (matching [(2,\'a\'), (1,\'b\')])     == Map.'Data.Map.Strict.fromList' [(2,\'a\'), (1,\'b\')]</span><span>
</span><span id="line-229"></span><span class="hs-comment">-- 'pairOfLeft'  (matching [(1,\'a\'), (1,\'b\')])     == Map.'Data.Map.Strict.singleton' 1 \'b\'</span><span>
</span><span id="line-230"></span><span class="hs-comment">-- matching [(1,\'a\'), (1,\'b\'), (2,\'b\'), (2,\'a\')] == matching [(2,\'a\')]</span><span>
</span><span id="line-231"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-232"></span><span id="local-6989586621679119274"><span id="local-6989586621679119275"><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#matching"><span class="hs-identifier hs-type">matching</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Ord</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119275"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Ord</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119274"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679119275"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679119274"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#Matching"><span class="hs-identifier hs-type">Matching</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119275"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119274"><span class="hs-identifier hs-type">b</span></a></span></span></span><span>
</span><span id="line-233"></span><span id="matching"><span class="annot"><span class="annottext">matching :: forall a b. (Ord a, Ord b) =&gt; [(a, b)] -&gt; Matching a b
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#matching"><span class="hs-identifier hs-var hs-var">matching</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) b a.
Foldable t =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">foldl'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">flip</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b c. (a -&gt; b -&gt; c) -&gt; (a, b) -&gt; c
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">uncurry</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b.
(Ord a, Ord b) =&gt;
a -&gt; b -&gt; Matching a b -&gt; Matching a b
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#addEdge"><span class="hs-identifier hs-var">addEdge</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. Map a b -&gt; Map b a -&gt; Matching a b
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#Matching"><span class="hs-identifier hs-var">Matching</span></a></span><span> </span><span class="annot"><span class="annottext">forall k a. Map k a
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Map.empty</span></a></span><span> </span><span class="annot"><span class="annottext">forall k a. Map k a
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Map.empty</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-234"></span><span>
</span><span id="line-235"></span><span class="hs-comment">-- | Check if a given 'Matching' is a valid /matching/ of a bipartite graph.</span><span>
</span><span id="line-236"></span><span class="hs-comment">-- Complexity: /O(S * log(n))/, where /S/ is the size of the matching.</span><span>
</span><span id="line-237"></span><span class="hs-comment">--</span><span>
</span><span id="line-238"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-239"></span><span class="hs-comment">-- isMatchingOf ('matching' []) x               == True</span><span>
</span><span id="line-240"></span><span class="hs-comment">-- isMatchingOf ('matching' xs) 'empty'           == 'null' xs</span><span>
</span><span id="line-241"></span><span class="hs-comment">-- isMatchingOf ('matching' [(x,y)]) ('edge' x y) == True</span><span>
</span><span id="line-242"></span><span class="hs-comment">-- isMatchingOf ('matching' [(1,2)]) ('edge' 2 1) == False</span><span>
</span><span id="line-243"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-244"></span><span id="local-6989586621679119261"><span id="local-6989586621679119262"><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#isMatchingOf"><span class="hs-identifier hs-type">isMatchingOf</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Ord</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119262"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Ord</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119261"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#Matching"><span class="hs-identifier hs-type">Matching</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119262"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119261"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.html#AdjacencyMap"><span class="hs-identifier hs-type">AdjacencyMap</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119262"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119261"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Bool</span></a></span></span></span><span>
</span><span id="line-245"></span><span id="isMatchingOf"><span class="annot"><span class="annottext">isMatchingOf :: forall a b.
(Ord a, Ord b) =&gt;
Matching a b -&gt; AdjacencyMap a b -&gt; Bool
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#isMatchingOf"><span class="hs-identifier hs-var hs-var">isMatchingOf</span></a></span></span><span> </span><span id="local-6989586621679118853"><span class="annot"><span class="annottext">m :: Matching a b
</span><a href="#local-6989586621679118853"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#Matching"><span class="hs-identifier hs-type">Matching</span></a></span><span> </span><span id="local-6989586621679118852"><span class="annot"><span class="annottext">Map a b
</span><a href="#local-6989586621679118852"><span class="hs-identifier hs-var">ab</span></a></span></span><span> </span><span class="annot"><span class="annottext">Map b a
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679118851"><span class="annot"><span class="annottext">AdjacencyMap a b
</span><a href="#local-6989586621679118851"><span class="hs-identifier hs-var">g</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. (Ord a, Ord b) =&gt; Matching a b -&gt; Bool
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#consistentMatching"><span class="hs-identifier hs-var">consistentMatching</span></a></span><span> </span><span class="annot"><span class="annottext">Matching a b
</span><a href="#local-6989586621679118853"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-246"></span><span>    </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-operator hs-var">&amp;&amp;</span></a></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *). Foldable t =&gt; t Bool -&gt; Bool
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">and</span></a></span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">forall a b. (Ord a, Ord b) =&gt; a -&gt; b -&gt; AdjacencyMap a b -&gt; Bool
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.html#hasEdge"><span class="hs-identifier hs-var">hasEdge</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118847"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118846"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">AdjacencyMap a b
</span><a href="#local-6989586621679118851"><span class="hs-identifier hs-var">g</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679118847"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118847"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679118846"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118846"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall k a. Map k a -&gt; [(k, a)]
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Map.toList</span></a></span><span> </span><span class="annot"><span class="annottext">Map a b
</span><a href="#local-6989586621679118852"><span class="hs-identifier hs-var">ab</span></a></span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-247"></span><span>
</span><span id="line-248"></span><span class="hs-comment">-- | The number of edges in a matching.</span><span>
</span><span id="line-249"></span><span class="hs-comment">-- Complexity: /O(1)/ time.</span><span>
</span><span id="line-250"></span><span class="hs-comment">--</span><span>
</span><span id="line-251"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-252"></span><span class="hs-comment">-- matchingSize ('matching' [])                 == 0</span><span>
</span><span id="line-253"></span><span class="hs-comment">-- matchingSize ('matching' [(2,\'a\'), (1,\'b\')]) == 2</span><span>
</span><span id="line-254"></span><span class="hs-comment">-- matchingSize ('matching' [(1,\'a\'), (1,\'b\')]) == 1</span><span>
</span><span id="line-255"></span><span class="hs-comment">-- matchingSize ('matching' xs)                 &lt;= 'length' xs</span><span>
</span><span id="line-256"></span><span class="hs-comment">-- matchingSize                               == Map.'Data.Map.Strict.size' . 'pairOfLeft'</span><span>
</span><span id="line-257"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-258"></span><span id="local-6989586621679119252"><span id="local-6989586621679119253"><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#matchingSize"><span class="hs-identifier hs-type">matchingSize</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#Matching"><span class="hs-identifier hs-type">Matching</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119253"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119252"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span></span></span><span>
</span><span id="line-259"></span><span id="matchingSize"><span class="annot"><span class="annottext">matchingSize :: forall a b. Matching a b -&gt; Int
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#matchingSize"><span class="hs-identifier hs-var hs-var">matchingSize</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall k a. Map k a -&gt; Int
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Map.size</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. Matching a b -&gt; Map a b
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#pairOfLeft"><span class="hs-identifier hs-var">pairOfLeft</span></a></span><span>
</span><span id="line-260"></span><span>
</span><span id="line-261"></span><span class="hs-comment">-- | Find a /maximum matching/ in a bipartite graph. A matching is maximum if it</span><span>
</span><span id="line-262"></span><span class="hs-comment">-- has the largest possible size.</span><span>
</span><span id="line-263"></span><span class="hs-comment">-- Complexity: /O(m * sqrt(n) * log(n))/ time.</span><span>
</span><span id="line-264"></span><span class="hs-comment">--</span><span>
</span><span id="line-265"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-266"></span><span class="hs-comment">-- maxMatching 'empty'                                          == 'matching' []</span><span>
</span><span id="line-267"></span><span class="hs-comment">-- maxMatching ('vertices' xs ys)                               == 'matching' []</span><span>
</span><span id="line-268"></span><span class="hs-comment">-- maxMatching ('path' [1,2,3,4])                               == 'matching' [(1,2), (3,4)]</span><span>
</span><span id="line-269"></span><span class="hs-comment">-- 'matchingSize' (maxMatching ('circuit' [(1,2), (3,4), (5,6)])) == 3</span><span>
</span><span id="line-270"></span><span class="hs-comment">-- 'matchingSize' (maxMatching ('star' x (y:ys)))                 == 1</span><span>
</span><span id="line-271"></span><span class="hs-comment">-- 'matchingSize' (maxMatching ('biclique' xs ys))                == 'min' ('length' ('Data.List.nub' xs)) ('length' ('Data.List.nub' ys))</span><span>
</span><span id="line-272"></span><span class="hs-comment">-- 'isMatchingOf' (maxMatching x) x                             == True</span><span>
</span><span id="line-273"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-274"></span><span id="local-6989586621679119246"><span id="local-6989586621679119247"><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#maxMatching"><span class="hs-identifier hs-type">maxMatching</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Ord</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119247"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Ord</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119246"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.html#AdjacencyMap"><span class="hs-identifier hs-type">AdjacencyMap</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119247"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119246"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#Matching"><span class="hs-identifier hs-type">Matching</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119247"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119246"><span class="hs-identifier hs-type">b</span></a></span></span></span><span>
</span><span id="line-275"></span><span id="maxMatching"><span class="annot"><span class="annottext">maxMatching :: forall a b. (Ord a, Ord b) =&gt; AdjacencyMap a b -&gt; Matching a b
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#maxMatching"><span class="hs-identifier hs-var hs-var">maxMatching</span></a></span></span><span> </span><span id="local-6989586621679118841"><span class="annot"><span class="annottext">AdjacencyMap a b
</span><a href="#local-6989586621679118841"><span class="hs-identifier hs-var">graph</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. (forall s. ST s a) -&gt; a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">runST</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b s.
(Ord a, Ord b) =&gt;
AdjacencyMap a b -&gt; ST s (Matching a b)
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#maxMatchingHK"><span class="hs-identifier hs-var">maxMatchingHK</span></a></span><span> </span><span class="annot"><span class="annottext">AdjacencyMap a b
</span><a href="#local-6989586621679118841"><span class="hs-identifier hs-var">graph</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-276"></span><span>
</span><span id="line-277"></span><span class="hs-comment">-- TODO: Should we use a more efficient data structure for the queue?</span><span>
</span><span id="line-278"></span><span class="hs-comment">-- TODO: We could try speeding this up by representing vertices with 'Int's.</span><span>
</span><span id="line-279"></span><span class="hs-comment">-- The state maintained by the Hopcroft-Karp algorithm implemented below</span><span>
</span><span id="line-280"></span><span class="hs-keyword">data</span><span> </span><span id="HKState"><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#HKState"><span class="hs-identifier hs-var">HKState</span></a></span></span><span> </span><span id="local-6989586621679119237"><span class="annot"><a href="#local-6989586621679119237"><span class="hs-identifier hs-type">s</span></a></span></span><span> </span><span id="local-6989586621679119236"><span class="annot"><a href="#local-6989586621679119236"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span id="local-6989586621679119235"><span class="annot"><a href="#local-6989586621679119235"><span class="hs-identifier hs-type">b</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="HKState"><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#HKState"><span class="hs-identifier hs-var">HKState</span></a></span></span><span>
</span><span id="line-281"></span><span>    </span><span class="hs-special">{</span><span> </span><span id="distance"><span class="annot"><span class="annottext">forall s a b. HKState s a b -&gt; STRef s (Map a Int)
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#distance"><span class="hs-identifier hs-var hs-var">distance</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">STRef</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119237"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../../../containers/html/src"><span class="hs-identifier hs-type">Map</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119236"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-282"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="curMatching"><span class="annot"><span class="annottext">forall s a b. HKState s a b -&gt; STRef s (Matching a b)
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#curMatching"><span class="hs-identifier hs-var hs-var">curMatching</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">STRef</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119237"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#Matching"><span class="hs-identifier hs-type">Matching</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119236"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119235"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-283"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="queue"><span class="annot"><span class="annottext">forall s a b. HKState s a b -&gt; STRef s (Seq a)
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#queue"><span class="hs-identifier hs-var hs-var">queue</span></a></span></span><span>       </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">STRef</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119237"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../../../containers/html/src"><span class="hs-identifier hs-type">Seq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119236"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-284"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="visited"><span class="annot"><span class="annottext">forall s a b. HKState s a b -&gt; STRef s (Set a)
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#visited"><span class="hs-identifier hs-var hs-var">visited</span></a></span></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">STRef</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119237"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../../../containers/html/src"><span class="hs-identifier hs-type">Set</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119236"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-285"></span><span>
</span><span id="line-286"></span><span class="hs-comment">-- See https://en.wikipedia.org/wiki/Hopcroft-Karp_algorithm</span><span>
</span><span id="line-287"></span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#maxMatchingHK"><span class="hs-identifier hs-type">maxMatchingHK</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679119240"><span class="annot"><a href="#local-6989586621679119240"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span id="local-6989586621679119239"><span class="annot"><a href="#local-6989586621679119239"><span class="hs-identifier hs-type">b</span></a></span></span><span> </span><span id="local-6989586621679119238"><span class="annot"><a href="#local-6989586621679119238"><span class="hs-identifier hs-type">s</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Ord</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119240"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Ord</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119239"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.html#AdjacencyMap"><span class="hs-identifier hs-type">AdjacencyMap</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119240"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119239"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">ST</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119238"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#Matching"><span class="hs-identifier hs-type">Matching</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119240"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119239"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-288"></span><span id="maxMatchingHK"><span class="annot"><span class="annottext">maxMatchingHK :: forall a b s.
(Ord a, Ord b) =&gt;
AdjacencyMap a b -&gt; ST s (Matching a b)
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#maxMatchingHK"><span class="hs-identifier hs-var hs-var">maxMatchingHK</span></a></span></span><span> </span><span id="local-6989586621679118754"><span class="annot"><span class="annottext">AdjacencyMap a b
</span><a href="#local-6989586621679118754"><span class="hs-identifier hs-var">g</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-289"></span><span>    </span><span id="local-6989586621679118753"><span class="annot"><span class="annottext">STRef s (Map a Int)
</span><a href="#local-6989586621679118753"><span class="hs-identifier hs-var">distance</span></a></span></span><span>    </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall a s. a -&gt; ST s (STRef s a)
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">newSTRef</span></a></span><span> </span><span class="annot"><span class="annottext">forall k a. Map k a
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Map.empty</span></a></span><span>
</span><span id="line-290"></span><span>    </span><span id="local-6989586621679118752"><span class="annot"><span class="annottext">STRef s (Matching a b)
</span><a href="#local-6989586621679118752"><span class="hs-identifier hs-var">curMatching</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall a s. a -&gt; ST s (STRef s a)
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">newSTRef</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. Map a b -&gt; Map b a -&gt; Matching a b
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#Matching"><span class="hs-identifier hs-var">Matching</span></a></span><span> </span><span class="annot"><span class="annottext">forall k a. Map k a
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Map.empty</span></a></span><span> </span><span class="annot"><span class="annottext">forall k a. Map k a
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Map.empty</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-291"></span><span>    </span><span id="local-6989586621679118751"><span class="annot"><span class="annottext">STRef s (Seq a)
</span><a href="#local-6989586621679118751"><span class="hs-identifier hs-var">queue</span></a></span></span><span>       </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall a s. a -&gt; ST s (STRef s a)
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">newSTRef</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Seq a
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Seq.empty</span></a></span><span>
</span><span id="line-292"></span><span>    </span><span id="local-6989586621679118749"><span class="annot"><span class="annottext">STRef s (Set a)
</span><a href="#local-6989586621679118749"><span class="hs-identifier hs-var">visited</span></a></span></span><span>     </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall a s. a -&gt; ST s (STRef s a)
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">newSTRef</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Set a
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Set.empty</span></a></span><span>
</span><span id="line-293"></span><span>    </span><span class="annot"><span class="annottext">HKState s a b -&gt; ST s ()
</span><a href="#local-6989586621679118747"><span class="hs-identifier hs-var">runHK</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall s a b.
STRef s (Map a Int)
-&gt; STRef s (Matching a b)
-&gt; STRef s (Seq a)
-&gt; STRef s (Set a)
-&gt; HKState s a b
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#HKState"><span class="hs-identifier hs-var">HKState</span></a></span><span> </span><span class="annot"><span class="annottext">STRef s (Map a Int)
</span><a href="#local-6989586621679118753"><span class="hs-identifier hs-var">distance</span></a></span><span> </span><span class="annot"><span class="annottext">STRef s (Matching a b)
</span><a href="#local-6989586621679118752"><span class="hs-identifier hs-var">curMatching</span></a></span><span> </span><span class="annot"><span class="annottext">STRef s (Seq a)
</span><a href="#local-6989586621679118751"><span class="hs-identifier hs-var">queue</span></a></span><span> </span><span class="annot"><span class="annottext">STRef s (Set a)
</span><a href="#local-6989586621679118749"><span class="hs-identifier hs-var">visited</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-294"></span><span>    </span><span class="annot"><span class="annottext">forall s a. STRef s a -&gt; ST s a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">readSTRef</span></a></span><span> </span><span class="annot"><span class="annottext">STRef s (Matching a b)
</span><a href="#local-6989586621679118752"><span class="hs-identifier hs-var">curMatching</span></a></span><span>
</span><span id="line-295"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-296"></span><span>    </span><span class="annot"><a href="#local-6989586621679118747"><span class="hs-identifier hs-type">runHK</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#HKState"><span class="hs-identifier hs-type">HKState</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119238"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119240"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119239"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">ST</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119238"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-297"></span><span>    </span><span id="local-6989586621679118747"><span class="annot"><span class="annottext">runHK :: HKState s a b -&gt; ST s ()
</span><a href="#local-6989586621679118747"><span class="hs-identifier hs-var hs-var">runHK</span></a></span></span><span> </span><span id="local-6989586621679118746"><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118746"><span class="hs-identifier hs-var">state</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="annot"><span class="annottext">forall s a. STRef s a -&gt; a -&gt; ST s ()
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">writeSTRef</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall s a b. HKState s a b -&gt; STRef s (Map a Int)
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#distance"><span class="hs-identifier hs-var">distance</span></a></span><span> </span><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118746"><span class="hs-identifier hs-var">state</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall k a. Map k a
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Map.empty</span></a></span><span>
</span><span id="line-298"></span><span>                     </span><span id="local-6989586621679118745"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679118745"><span class="hs-identifier hs-var">foundAugmentingPath</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">HKState s a b -&gt; ST s Bool
</span><a href="#local-6989586621679118744"><span class="hs-identifier hs-var">bfs</span></a></span><span> </span><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118746"><span class="hs-identifier hs-var">state</span></a></span><span>
</span><span id="line-299"></span><span>                     </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *). Applicative f =&gt; Bool -&gt; f () -&gt; f ()
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">when</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679118745"><span class="hs-identifier hs-var">foundAugmentingPath</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-300"></span><span>                         </span><span class="annot"><span class="annottext">forall s a. STRef s a -&gt; a -&gt; ST s ()
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">writeSTRef</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall s a b. HKState s a b -&gt; STRef s (Set a)
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#visited"><span class="hs-identifier hs-var">visited</span></a></span><span> </span><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118746"><span class="hs-identifier hs-var">state</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall a. Set a
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Set.empty</span></a></span><span>
</span><span id="line-301"></span><span>                         </span><span class="annot"><span class="annottext">HKState s a b -&gt; ST s ()
</span><a href="#local-6989586621679118743"><span class="hs-identifier hs-var">dfs</span></a></span><span> </span><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118746"><span class="hs-identifier hs-var">state</span></a></span><span>
</span><span id="line-302"></span><span>                         </span><span class="annot"><span class="annottext">HKState s a b -&gt; ST s ()
</span><a href="#local-6989586621679118747"><span class="hs-identifier hs-var">runHK</span></a></span><span> </span><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118746"><span class="hs-identifier hs-var">state</span></a></span><span>
</span><span id="line-303"></span><span>
</span><span id="line-304"></span><span>    </span><span class="annot"><a href="#local-6989586621679118742"><span class="hs-identifier hs-type">currentlyUncovered</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#HKState"><span class="hs-identifier hs-type">HKState</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119238"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119240"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119239"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">ST</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119238"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679119240"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-305"></span><span>    </span><span id="local-6989586621679118742"><span class="annot"><span class="annottext">currentlyUncovered :: HKState s a b -&gt; ST s [a]
</span><a href="#local-6989586621679118742"><span class="hs-identifier hs-var hs-var">currentlyUncovered</span></a></span></span><span> </span><span id="local-6989586621679118741"><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118741"><span class="hs-identifier hs-var">state</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-306"></span><span>        </span><span id="local-6989586621679118740"><span class="annot"><span class="annottext">Matching a b
</span><a href="#local-6989586621679118740"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall s a. STRef s a -&gt; ST s a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">readSTRef</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall s a b. HKState s a b -&gt; STRef s (Matching a b)
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#curMatching"><span class="hs-identifier hs-var">curMatching</span></a></span><span> </span><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118741"><span class="hs-identifier hs-var">state</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-307"></span><span>        </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">return</span></a></span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118739"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679118739"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118739"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall a b. AdjacencyMap a b -&gt; [a]
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.html#leftVertexList"><span class="hs-identifier hs-var">leftVertexList</span></a></span><span> </span><span class="annot"><span class="annottext">AdjacencyMap a b
</span><a href="#local-6989586621679118754"><span class="hs-identifier hs-var">g</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-var">not</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. Ord a =&gt; a -&gt; Matching a b -&gt; Bool
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#leftCovered"><span class="hs-identifier hs-var">leftCovered</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118739"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">Matching a b
</span><a href="#local-6989586621679118740"><span class="hs-identifier hs-var">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-308"></span><span>
</span><span id="line-309"></span><span>
</span><span id="line-310"></span><span>    </span><span class="annot"><a href="#local-6989586621679118744"><span class="hs-identifier hs-type">bfs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#HKState"><span class="hs-identifier hs-type">HKState</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119238"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119240"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119239"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">ST</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119238"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Bool</span></a></span><span>
</span><span id="line-311"></span><span>    </span><span id="local-6989586621679118744"><span class="annot"><span class="annottext">bfs :: HKState s a b -&gt; ST s Bool
</span><a href="#local-6989586621679118744"><span class="hs-identifier hs-var hs-var">bfs</span></a></span></span><span> </span><span id="local-6989586621679118736"><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118736"><span class="hs-identifier hs-var">state</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-312"></span><span>        </span><span id="local-6989586621679118735"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679118735"><span class="hs-identifier hs-var">uncovered</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">HKState s a b -&gt; ST s [a]
</span><a href="#local-6989586621679118742"><span class="hs-identifier hs-var">currentlyUncovered</span></a></span><span> </span><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118736"><span class="hs-identifier hs-var">state</span></a></span><span>
</span><span id="line-313"></span><span>        </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Foldable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m ()
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">mapM_</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">HKState s a b -&gt; Int -&gt; a -&gt; ST s ()
</span><a href="#local-6989586621679118733"><span class="hs-identifier hs-var">enqueue</span></a></span><span> </span><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118736"><span class="hs-identifier hs-var">state</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679118735"><span class="hs-identifier hs-var">uncovered</span></a></span><span>
</span><span id="line-314"></span><span>        </span><span class="annot"><span class="annottext">HKState s a b -&gt; ST s Bool
</span><a href="#local-6989586621679118732"><span class="hs-identifier hs-var">bfsLoop</span></a></span><span> </span><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118736"><span class="hs-identifier hs-var">state</span></a></span><span>
</span><span id="line-315"></span><span>
</span><span id="line-316"></span><span>    </span><span class="annot"><a href="#local-6989586621679118733"><span class="hs-identifier hs-type">enqueue</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#HKState"><span class="hs-identifier hs-type">HKState</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119238"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119240"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119239"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679119240"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">ST</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119238"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-317"></span><span>    </span><span id="local-6989586621679118733"><span class="annot"><span class="annottext">enqueue :: HKState s a b -&gt; Int -&gt; a -&gt; ST s ()
</span><a href="#local-6989586621679118733"><span class="hs-identifier hs-var hs-var">enqueue</span></a></span></span><span> </span><span id="local-6989586621679118731"><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118731"><span class="hs-identifier hs-var">state</span></a></span></span><span> </span><span id="local-6989586621679118730"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679118730"><span class="hs-identifier hs-var">d</span></a></span></span><span> </span><span id="local-6989586621679118729"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118729"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="annot"><span class="annottext">forall s a. STRef s a -&gt; (a -&gt; a) -&gt; ST s ()
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">modifySTRef</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall s a b. HKState s a b -&gt; STRef s (Map a Int)
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#distance"><span class="hs-identifier hs-var">distance</span></a></span><span> </span><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118731"><span class="hs-identifier hs-var">state</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall k a. Ord k =&gt; k -&gt; a -&gt; Map k a -&gt; Map k a
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Map.insert</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118729"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679118730"><span class="hs-identifier hs-var">d</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-318"></span><span>                           </span><span class="annot"><span class="annottext">forall s a. STRef s a -&gt; (a -&gt; a) -&gt; ST s ()
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">modifySTRef</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall s a b. HKState s a b -&gt; STRef s (Seq a)
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#queue"><span class="hs-identifier hs-var">queue</span></a></span><span>    </span><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118731"><span class="hs-identifier hs-var">state</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Seq a -&gt; a -&gt; Seq a
</span><a href="../../../../containers/html/src"><span class="hs-operator hs-var">|&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118729"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-319"></span><span>
</span><span id="line-320"></span><span>    </span><span class="annot"><a href="#local-6989586621679118728"><span class="hs-identifier hs-type">dequeue</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#HKState"><span class="hs-identifier hs-type">HKState</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119238"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119240"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119239"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">ST</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119238"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119240"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-321"></span><span>    </span><span id="local-6989586621679118728"><span class="annot"><span class="annottext">dequeue :: HKState s a b -&gt; ST s (Maybe a)
</span><a href="#local-6989586621679118728"><span class="hs-identifier hs-var hs-var">dequeue</span></a></span></span><span> </span><span id="local-6989586621679118727"><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118727"><span class="hs-identifier hs-var">state</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679118726"><span class="annot"><span class="annottext">Seq a
</span><a href="#local-6989586621679118726"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall s a. STRef s a -&gt; ST s a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">readSTRef</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall s a b. HKState s a b -&gt; STRef s (Seq a)
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#queue"><span class="hs-identifier hs-var">queue</span></a></span><span> </span><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118727"><span class="hs-identifier hs-var">state</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-322"></span><span>                       </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">forall a. Seq a -&gt; ViewL a
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Seq.viewl</span></a></span><span> </span><span class="annot"><span class="annottext">Seq a
</span><a href="#local-6989586621679118726"><span class="hs-identifier hs-var">q</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-323"></span><span>                           </span><span id="local-6989586621679118724"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118724"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="annot"><a href="../../../../containers/html/src"><span class="hs-operator hs-type">:&lt;</span></a></span><span> </span><span id="local-6989586621679118722"><span class="annot"><span class="annottext">Seq a
</span><a href="#local-6989586621679118722"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall s a. STRef s a -&gt; a -&gt; ST s ()
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">writeSTRef</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall s a b. HKState s a b -&gt; STRef s (Seq a)
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#queue"><span class="hs-identifier hs-var">queue</span></a></span><span> </span><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118727"><span class="hs-identifier hs-var">state</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Seq a
</span><a href="#local-6989586621679118722"><span class="hs-identifier hs-var">q</span></a></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; f a -&gt; b -&gt; f b
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">Just</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118724"><span class="hs-identifier hs-var">a</span></a></span><span>
</span><span id="line-324"></span><span>                           </span><span class="annot"><span class="annottext">ViewL a
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">EmptyL</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">return</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">Nothing</span></a></span><span>
</span><span id="line-325"></span><span>
</span><span id="line-326"></span><span>    </span><span class="annot"><a href="#local-6989586621679118732"><span class="hs-identifier hs-type">bfsLoop</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#HKState"><span class="hs-identifier hs-type">HKState</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119238"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119240"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119239"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">ST</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119238"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Bool</span></a></span><span>
</span><span id="line-327"></span><span>    </span><span id="local-6989586621679118732"><span class="annot"><span class="annottext">bfsLoop :: HKState s a b -&gt; ST s Bool
</span><a href="#local-6989586621679118732"><span class="hs-identifier hs-var hs-var">bfsLoop</span></a></span></span><span> </span><span id="local-6989586621679118720"><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118720"><span class="hs-identifier hs-var">state</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">HKState s a b -&gt; ST s (Maybe a)
</span><a href="#local-6989586621679118728"><span class="hs-identifier hs-var">dequeue</span></a></span><span> </span><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118720"><span class="hs-identifier hs-var">state</span></a></span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">&gt;&gt;=</span></a></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-328"></span><span>                        </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">Just</span></a></span><span> </span><span id="local-6989586621679118719"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118719"><span class="hs-identifier hs-var">v</span></a></span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679118718"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679118718"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">HKState s a b -&gt; a -&gt; ST s Bool
</span><a href="#local-6989586621679118717"><span class="hs-identifier hs-var">bfsVertex</span></a></span><span> </span><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118720"><span class="hs-identifier hs-var">state</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118719"><span class="hs-identifier hs-var">v</span></a></span><span>
</span><span id="line-329"></span><span>                                      </span><span id="local-6989586621679118716"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679118716"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">HKState s a b -&gt; ST s Bool
</span><a href="#local-6989586621679118732"><span class="hs-identifier hs-var">bfsLoop</span></a></span><span> </span><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118720"><span class="hs-identifier hs-var">state</span></a></span><span>
</span><span id="line-330"></span><span>                                      </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">return</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679118718"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-operator hs-var">||</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679118716"><span class="hs-identifier hs-var">q</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-331"></span><span>                        </span><span class="annot"><span class="annottext">Maybe a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">Nothing</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">return</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-var">False</span></a></span><span>
</span><span id="line-332"></span><span>
</span><span id="line-333"></span><span>    </span><span class="annot"><a href="#local-6989586621679118717"><span class="hs-identifier hs-type">bfsVertex</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#HKState"><span class="hs-identifier hs-type">HKState</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119238"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119240"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119239"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679119240"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">ST</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119238"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Bool</span></a></span><span>
</span><span id="line-334"></span><span>    </span><span id="local-6989586621679118717"><span class="annot"><span class="annottext">bfsVertex :: HKState s a b -&gt; a -&gt; ST s Bool
</span><a href="#local-6989586621679118717"><span class="hs-identifier hs-var hs-var">bfsVertex</span></a></span></span><span> </span><span id="local-6989586621679118714"><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118714"><span class="hs-identifier hs-var">state</span></a></span></span><span> </span><span id="local-6989586621679118713"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118713"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679118712"><span class="annot"><span class="annottext">Map a Int
</span><a href="#local-6989586621679118712"><span class="hs-identifier hs-var">dist</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall s a. STRef s a -&gt; ST s a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">readSTRef</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall s a b. HKState s a b -&gt; STRef s (Map a Int)
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#distance"><span class="hs-identifier hs-var">distance</span></a></span><span> </span><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118714"><span class="hs-identifier hs-var">state</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-335"></span><span>                           </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679118711"><span class="annot"><span class="annottext">d :: Int
</span><a href="#local-6989586621679118711"><span class="hs-identifier hs-var hs-var">d</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. HasCallStack =&gt; Maybe a -&gt; a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">fromJust</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118713"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Maybe a
</span><a href="../../../../containers/html/src"><span class="hs-operator hs-var">`Map.lookup`</span></a></span><span> </span><span class="annot"><span class="annottext">Map a Int
</span><a href="#local-6989586621679118712"><span class="hs-identifier hs-var">dist</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall a. Num a =&gt; a -&gt; a -&gt; a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">+</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span>
</span><span id="line-336"></span><span>                           </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *). Foldable t =&gt; t Bool -&gt; Bool
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">or</span></a></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">&lt;$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">mapM</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">HKState s a b -&gt; Int -&gt; b -&gt; ST s Bool
</span><a href="#local-6989586621679118707"><span class="hs-identifier hs-var">bfsEdge</span></a></span><span> </span><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118714"><span class="hs-identifier hs-var">state</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679118711"><span class="hs-identifier hs-var">d</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; [b]
</span><a href="#local-6989586621679118706"><span class="hs-identifier hs-var">neighbours</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118713"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-337"></span><span>
</span><span id="line-338"></span><span>    </span><span class="annot"><a href="#local-6989586621679118705"><span class="hs-identifier hs-type">checkEnqueue</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#HKState"><span class="hs-identifier hs-type">HKState</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119238"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119240"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119239"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679119240"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">ST</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119238"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-339"></span><span>    </span><span id="local-6989586621679118705"><span class="annot"><span class="annottext">checkEnqueue :: HKState s a b -&gt; Int -&gt; a -&gt; ST s ()
</span><a href="#local-6989586621679118705"><span class="hs-identifier hs-var hs-var">checkEnqueue</span></a></span></span><span> </span><span id="local-6989586621679118704"><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118704"><span class="hs-identifier hs-var">state</span></a></span></span><span> </span><span id="local-6989586621679118703"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679118703"><span class="hs-identifier hs-var">d</span></a></span></span><span> </span><span id="local-6989586621679118702"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118702"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679118701"><span class="annot"><span class="annottext">Map a Int
</span><a href="#local-6989586621679118701"><span class="hs-identifier hs-var">dist</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall s a. STRef s a -&gt; ST s a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">readSTRef</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall s a b. HKState s a b -&gt; STRef s (Map a Int)
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#distance"><span class="hs-identifier hs-var">distance</span></a></span><span> </span><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118704"><span class="hs-identifier hs-var">state</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-340"></span><span>                                </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *). Applicative f =&gt; Bool -&gt; f () -&gt; f ()
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">when</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118702"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Bool
</span><a href="../../../../containers/html/src"><span class="hs-operator hs-var">`Map.notMember`</span></a></span><span> </span><span class="annot"><span class="annottext">Map a Int
</span><a href="#local-6989586621679118701"><span class="hs-identifier hs-var">dist</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">HKState s a b -&gt; Int -&gt; a -&gt; ST s ()
</span><a href="#local-6989586621679118733"><span class="hs-identifier hs-var">enqueue</span></a></span><span> </span><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118704"><span class="hs-identifier hs-var">state</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679118703"><span class="hs-identifier hs-var">d</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118702"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-341"></span><span>
</span><span id="line-342"></span><span>    </span><span class="annot"><a href="#local-6989586621679118707"><span class="hs-identifier hs-type">bfsEdge</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#HKState"><span class="hs-identifier hs-type">HKState</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119238"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119240"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119239"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679119239"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">ST</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119238"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Bool</span></a></span><span>
</span><span id="line-343"></span><span>    </span><span id="local-6989586621679118707"><span class="annot"><span class="annottext">bfsEdge :: HKState s a b -&gt; Int -&gt; b -&gt; ST s Bool
</span><a href="#local-6989586621679118707"><span class="hs-identifier hs-var hs-var">bfsEdge</span></a></span></span><span> </span><span id="local-6989586621679118700"><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118700"><span class="hs-identifier hs-var">state</span></a></span></span><span> </span><span id="local-6989586621679118699"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679118699"><span class="hs-identifier hs-var">d</span></a></span></span><span> </span><span id="local-6989586621679118698"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118698"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679118697"><span class="annot"><span class="annottext">Matching a b
</span><a href="#local-6989586621679118697"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall s a. STRef s a -&gt; ST s a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">readSTRef</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall s a b. HKState s a b -&gt; STRef s (Matching a b)
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#curMatching"><span class="hs-identifier hs-var">curMatching</span></a></span><span> </span><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118700"><span class="hs-identifier hs-var">state</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-344"></span><span>                           </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118698"><span class="hs-identifier hs-var">u</span></a></span><span> </span><span class="annot"><span class="annottext">forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Maybe a
</span><a href="../../../../containers/html/src"><span class="hs-operator hs-var">`Map.lookup`</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. Matching a b -&gt; Map b a
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#pairOfRight"><span class="hs-identifier hs-var">pairOfRight</span></a></span><span> </span><span class="annot"><span class="annottext">Matching a b
</span><a href="#local-6989586621679118697"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-345"></span><span>                               </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">Just</span></a></span><span> </span><span id="local-6989586621679118696"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118696"><span class="hs-identifier hs-var">v</span></a></span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">HKState s a b -&gt; Int -&gt; a -&gt; ST s ()
</span><a href="#local-6989586621679118705"><span class="hs-identifier hs-var">checkEnqueue</span></a></span><span> </span><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118700"><span class="hs-identifier hs-var">state</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679118699"><span class="hs-identifier hs-var">d</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118696"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; f a -&gt; b -&gt; f b
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-var">False</span></a></span><span>
</span><span id="line-346"></span><span>                               </span><span class="annot"><span class="annottext">Maybe a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">Nothing</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">return</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-var">True</span></a></span><span>
</span><span id="line-347"></span><span>
</span><span id="line-348"></span><span>    </span><span class="annot"><a href="#local-6989586621679118743"><span class="hs-identifier hs-type">dfs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#HKState"><span class="hs-identifier hs-type">HKState</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119238"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119240"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119239"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">ST</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119238"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-349"></span><span>    </span><span id="local-6989586621679118743"><span class="annot"><span class="annottext">dfs :: HKState s a b -&gt; ST s ()
</span><a href="#local-6989586621679118743"><span class="hs-identifier hs-var hs-var">dfs</span></a></span></span><span> </span><span id="local-6989586621679118695"><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118695"><span class="hs-identifier hs-var">state</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">HKState s a b -&gt; ST s [a]
</span><a href="#local-6989586621679118742"><span class="hs-identifier hs-var">currentlyUncovered</span></a></span><span> </span><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118695"><span class="hs-identifier hs-var">state</span></a></span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">&gt;&gt;=</span></a></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Foldable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m ()
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">mapM_</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">HKState s a b -&gt; Int -&gt; a -&gt; ST s Bool
</span><a href="#local-6989586621679118694"><span class="hs-identifier hs-var">dfsVertex</span></a></span><span> </span><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118695"><span class="hs-identifier hs-var">state</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span class="hs-special">)</span><span>
</span><span id="line-350"></span><span>
</span><span id="line-351"></span><span>    </span><span class="annot"><a href="#local-6989586621679118694"><span class="hs-identifier hs-type">dfsVertex</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#HKState"><span class="hs-identifier hs-type">HKState</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119238"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119240"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119239"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679119240"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">ST</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119238"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Bool</span></a></span><span>
</span><span id="line-352"></span><span>    </span><span id="local-6989586621679118694"><span class="annot"><span class="annottext">dfsVertex :: HKState s a b -&gt; Int -&gt; a -&gt; ST s Bool
</span><a href="#local-6989586621679118694"><span class="hs-identifier hs-var hs-var">dfsVertex</span></a></span></span><span> </span><span id="local-6989586621679118693"><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118693"><span class="hs-identifier hs-var">state</span></a></span></span><span> </span><span id="local-6989586621679118692"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679118692"><span class="hs-identifier hs-var">d</span></a></span></span><span> </span><span id="local-6989586621679118691"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118691"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679118690"><span class="annot"><span class="annottext">Map a Int
</span><a href="#local-6989586621679118690"><span class="hs-identifier hs-var">dist</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall s a. STRef s a -&gt; ST s a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">readSTRef</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall s a b. HKState s a b -&gt; STRef s (Map a Int)
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#distance"><span class="hs-identifier hs-var">distance</span></a></span><span> </span><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118693"><span class="hs-identifier hs-var">state</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-353"></span><span>                             </span><span id="local-6989586621679118689"><span class="annot"><span class="annottext">Set a
</span><a href="#local-6989586621679118689"><span class="hs-identifier hs-var">vis</span></a></span></span><span>  </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall s a. STRef s a -&gt; ST s a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">readSTRef</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall s a b. HKState s a b -&gt; STRef s (Set a)
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#visited"><span class="hs-identifier hs-var">visited</span></a></span><span> </span><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118693"><span class="hs-identifier hs-var">state</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-354"></span><span>                             </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679118688"><span class="annot"><span class="annottext">dv :: Int
</span><a href="#local-6989586621679118688"><span class="hs-identifier hs-var hs-var">dv</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. HasCallStack =&gt; Maybe a -&gt; a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">fromJust</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118691"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Maybe a
</span><a href="../../../../containers/html/src"><span class="hs-operator hs-var">`Map.lookup`</span></a></span><span> </span><span class="annot"><span class="annottext">Map a Int
</span><a href="#local-6989586621679118690"><span class="hs-identifier hs-var">dist</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-355"></span><span>                             </span><span class="hs-keyword">case</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679118692"><span class="hs-identifier hs-var">d</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Num a =&gt; a -&gt; a -&gt; a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">+</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-operator hs-var">==</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679118688"><span class="hs-identifier hs-var">dv</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-operator hs-var">&amp;&amp;</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118691"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; a -&gt; Set a -&gt; Bool
</span><a href="../../../../containers/html/src"><span class="hs-operator hs-var">`Set.notMember`</span></a></span><span> </span><span class="annot"><span class="annottext">Set a
</span><a href="#local-6989586621679118689"><span class="hs-identifier hs-var">vis</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-356"></span><span>                                 </span><span class="annot"><span class="annottext">Bool
</span><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-var">False</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">return</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-var">False</span></a></span><span>
</span><span id="line-357"></span><span>                                 </span><span class="annot"><span class="annottext">Bool
</span><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-var">True</span></a></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="annot"><span class="annottext">forall s a. STRef s a -&gt; (a -&gt; a) -&gt; ST s ()
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">modifySTRef</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall s a b. HKState s a b -&gt; STRef s (Set a)
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#visited"><span class="hs-identifier hs-var">visited</span></a></span><span> </span><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118693"><span class="hs-identifier hs-var">state</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Ord a =&gt; a -&gt; Set a -&gt; Set a
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Set.insert</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118691"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-358"></span><span>                                             </span><span class="annot"><span class="annottext">HKState s a b -&gt; Int -&gt; a -&gt; [b] -&gt; ST s Bool
</span><a href="#local-6989586621679118685"><span class="hs-identifier hs-var">dfsEdges</span></a></span><span> </span><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118693"><span class="hs-identifier hs-var">state</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679118688"><span class="hs-identifier hs-var">dv</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118691"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; [b]
</span><a href="#local-6989586621679118706"><span class="hs-identifier hs-var">neighbours</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118691"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-359"></span><span>
</span><span id="line-360"></span><span>    </span><span class="annot"><a href="#local-6989586621679118685"><span class="hs-identifier hs-type">dfsEdges</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#HKState"><span class="hs-identifier hs-type">HKState</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119238"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119240"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119239"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679119240"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679119239"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">ST</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119238"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Bool</span></a></span><span>
</span><span id="line-361"></span><span>    </span><span id="local-6989586621679118685"><span class="annot"><span class="annottext">dfsEdges :: HKState s a b -&gt; Int -&gt; a -&gt; [b] -&gt; ST s Bool
</span><a href="#local-6989586621679118685"><span class="hs-identifier hs-var hs-var">dfsEdges</span></a></span></span><span> </span><span class="annot"><span class="annottext">HKState s a b
</span><span class="hs-identifier">_</span></span><span>     </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">return</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-var">False</span></a></span><span>
</span><span id="line-362"></span><span>    </span><span class="annot"><a href="#local-6989586621679118685"><span class="hs-identifier hs-var">dfsEdges</span></a></span><span> </span><span id="local-6989586621679118684"><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118684"><span class="hs-identifier hs-var">state</span></a></span></span><span> </span><span id="local-6989586621679118683"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679118683"><span class="hs-identifier hs-var">d</span></a></span></span><span> </span><span id="local-6989586621679118682"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118682"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679118681"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118681"><span class="hs-identifier hs-var">b</span></a></span></span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-glyph hs-type">:</span></a></span><span id="local-6989586621679118680"><span class="annot"><span class="annottext">[b]
</span><a href="#local-6989586621679118680"><span class="hs-identifier hs-var">bs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679118679"><span class="annot"><span class="annottext">Matching a b
</span><a href="#local-6989586621679118679"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall s a. STRef s a -&gt; ST s a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">readSTRef</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall s a b. HKState s a b -&gt; STRef s (Matching a b)
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#curMatching"><span class="hs-identifier hs-var">curMatching</span></a></span><span> </span><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118684"><span class="hs-identifier hs-var">state</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-363"></span><span>                                   </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118681"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Maybe a
</span><a href="../../../../containers/html/src"><span class="hs-operator hs-var">`Map.lookup`</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. Matching a b -&gt; Map b a
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#pairOfRight"><span class="hs-identifier hs-var">pairOfRight</span></a></span><span> </span><span class="annot"><span class="annottext">Matching a b
</span><a href="#local-6989586621679118679"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-364"></span><span>                                       </span><span class="annot"><span class="annottext">Maybe a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">Nothing</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">HKState s a b -&gt; a -&gt; b -&gt; ST s ()
</span><a href="#local-6989586621679118678"><span class="hs-identifier hs-var">addEdge</span></a></span><span> </span><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118684"><span class="hs-identifier hs-var">state</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118682"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118681"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; f a -&gt; b -&gt; f b
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-var">True</span></a></span><span>
</span><span id="line-365"></span><span>                                       </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">Just</span></a></span><span> </span><span id="local-6989586621679118677"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118677"><span class="hs-identifier hs-var">w</span></a></span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">HKState s a b -&gt; Int -&gt; a -&gt; ST s Bool
</span><a href="#local-6989586621679118694"><span class="hs-identifier hs-var">dfsVertex</span></a></span><span> </span><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118684"><span class="hs-identifier hs-var">state</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679118683"><span class="hs-identifier hs-var">d</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118677"><span class="hs-identifier hs-var">w</span></a></span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">&gt;&gt;=</span></a></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-366"></span><span>                                            </span><span class="annot"><span class="annottext">Bool
</span><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-var">True</span></a></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">HKState s a b -&gt; a -&gt; b -&gt; ST s ()
</span><a href="#local-6989586621679118678"><span class="hs-identifier hs-var">addEdge</span></a></span><span> </span><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118684"><span class="hs-identifier hs-var">state</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118682"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118681"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; f a -&gt; b -&gt; f b
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-var">True</span></a></span><span>
</span><span id="line-367"></span><span>                                            </span><span class="annot"><span class="annottext">Bool
</span><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-var">False</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">HKState s a b -&gt; Int -&gt; a -&gt; [b] -&gt; ST s Bool
</span><a href="#local-6989586621679118685"><span class="hs-identifier hs-var">dfsEdges</span></a></span><span> </span><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118684"><span class="hs-identifier hs-var">state</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679118683"><span class="hs-identifier hs-var">d</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118682"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">[b]
</span><a href="#local-6989586621679118680"><span class="hs-identifier hs-var">bs</span></a></span><span>
</span><span id="line-368"></span><span>
</span><span id="line-369"></span><span>    </span><span class="annot"><a href="#local-6989586621679118678"><span class="hs-identifier hs-type">addEdge</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#HKState"><span class="hs-identifier hs-type">HKState</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119238"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119240"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119239"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679119240"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679119239"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">ST</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119238"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-370"></span><span>    </span><span id="local-6989586621679118678"><span class="annot"><span class="annottext">addEdge :: HKState s a b -&gt; a -&gt; b -&gt; ST s ()
</span><a href="#local-6989586621679118678"><span class="hs-identifier hs-var hs-var">addEdge</span></a></span></span><span> </span><span id="local-6989586621679118676"><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118676"><span class="hs-identifier hs-var">state</span></a></span></span><span> </span><span id="local-6989586621679118675"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118675"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="local-6989586621679118674"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118674"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall s a. STRef s a -&gt; (a -&gt; a) -&gt; ST s ()
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">modifySTRef</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall s a b. HKState s a b -&gt; STRef s (Matching a b)
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#curMatching"><span class="hs-identifier hs-var">curMatching</span></a></span><span> </span><span class="annot"><span class="annottext">HKState s a b
</span><a href="#local-6989586621679118676"><span class="hs-identifier hs-var">state</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b.
(Ord a, Ord b) =&gt;
a -&gt; b -&gt; Matching a b -&gt; Matching a b
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#addEdgeUnsafe"><span class="hs-identifier hs-var">addEdgeUnsafe</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118675"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118674"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-371"></span><span>
</span><span id="line-372"></span><span>    </span><span class="annot"><a href="#local-6989586621679118706"><span class="hs-identifier hs-type">neighbours</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679119240"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679119239"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-373"></span><span>    </span><span id="local-6989586621679118706"><span class="annot"><span class="annottext">neighbours :: a -&gt; [b]
</span><a href="#local-6989586621679118706"><span class="hs-identifier hs-var hs-var">neighbours</span></a></span></span><span> </span><span id="local-6989586621679118673"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118673"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Set a -&gt; [a]
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Set.toAscList</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. HasCallStack =&gt; Maybe a -&gt; a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">fromJust</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Maybe a
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Map.lookup</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118673"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. AdjacencyMap a b -&gt; Map a (Set b)
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.html#leftAdjacencyMap"><span class="hs-identifier hs-var">leftAdjacencyMap</span></a></span><span> </span><span class="annot"><span class="annottext">AdjacencyMap a b
</span><a href="#local-6989586621679118754"><span class="hs-identifier hs-var">g</span></a></span><span>
</span><span id="line-374"></span><span>
</span><span id="line-375"></span><span class="hs-comment">-- | A /vertex cover/ of a bipartite graph.</span><span>
</span><span id="line-376"></span><span class="hs-comment">--</span><span>
</span><span id="line-377"></span><span class="hs-comment">-- A /vertex cover/ is a subset of vertices such that every edge is incident to</span><span>
</span><span id="line-378"></span><span class="hs-comment">-- some vertex in the subset. We represent vertex covers by storing two sets of</span><span>
</span><span id="line-379"></span><span class="hs-comment">-- vertices, one for each part. An equivalent representation, which is slightly</span><span>
</span><span id="line-380"></span><span class="hs-comment">-- less memory efficient, is @Set@ @(Either@ @a@ @b)@.</span><span>
</span><span id="line-381"></span><span class="hs-keyword">type</span><span> </span><span id="VertexCover"><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#VertexCover"><span class="hs-identifier hs-var">VertexCover</span></a></span></span><span> </span><span id="local-6989586621679118671"><span class="annot"><a href="#local-6989586621679118671"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span id="local-6989586621679118670"><span class="annot"><a href="#local-6989586621679118670"><span class="hs-identifier hs-type">b</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../../../containers/html/src"><span class="hs-identifier hs-type">Set</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118671"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../../../containers/html/src"><span class="hs-identifier hs-type">Set</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118670"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-382"></span><span>
</span><span id="line-383"></span><span class="hs-comment">-- | Check if a given pair of sets is a /vertex cover/ of a bipartite graph.</span><span>
</span><span id="line-384"></span><span class="hs-comment">-- Complexity: /O(m * log(n))/.</span><span>
</span><span id="line-385"></span><span class="hs-comment">--</span><span>
</span><span id="line-386"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-387"></span><span class="hs-comment">-- isVertexCoverOf (xs             , ys             ) 'empty'          == Set.'Set.null' xs &amp;&amp; Set.'Set.null' ys</span><span>
</span><span id="line-388"></span><span class="hs-comment">-- isVertexCoverOf (xs             , ys             ) ('leftVertex' x) == Set.'Set.isSubsetOf' xs (Set.'Set.singleton' x) &amp;&amp; Set.'Set.null' ys</span><span>
</span><span id="line-389"></span><span class="hs-comment">-- isVertexCoverOf (Set.'Set.empty'      , Set.'Set.empty'      ) ('edge' x y)     == False</span><span>
</span><span id="line-390"></span><span class="hs-comment">-- isVertexCoverOf (Set.'Set.singleton' x, ys             ) ('edge' x y)     == Set.'Set.isSubsetOf' ys (Set.'Set.singleton' y)</span><span>
</span><span id="line-391"></span><span class="hs-comment">-- isVertexCoverOf (xs             , Set.'Set.singleton' y) ('edge' x y)     == Set.'Set.isSubsetOf' xs (Set.'Set.singleton' x)</span><span>
</span><span id="line-392"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-393"></span><span id="local-6989586621679119178"><span id="local-6989586621679119179"><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#isVertexCoverOf"><span class="hs-identifier hs-type">isVertexCoverOf</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Ord</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119179"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Ord</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119178"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../../../containers/html/src"><span class="hs-identifier hs-type">Set</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119179"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../../../containers/html/src"><span class="hs-identifier hs-type">Set</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119178"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.html#AdjacencyMap"><span class="hs-identifier hs-type">AdjacencyMap</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119179"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119178"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Bool</span></a></span></span></span><span>
</span><span id="line-394"></span><span id="isVertexCoverOf"><span class="annot"><span class="annottext">isVertexCoverOf :: forall a b.
(Ord a, Ord b) =&gt;
(Set a, Set b) -&gt; AdjacencyMap a b -&gt; Bool
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#isVertexCoverOf"><span class="hs-identifier hs-var hs-var">isVertexCoverOf</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679118662"><span class="annot"><span class="annottext">Set a
</span><a href="#local-6989586621679118662"><span class="hs-keyword hs-var">as</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679118661"><span class="annot"><span class="annottext">Set b
</span><a href="#local-6989586621679118661"><span class="hs-identifier hs-var">bs</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679118660"><span class="annot"><span class="annottext">AdjacencyMap a b
</span><a href="#local-6989586621679118660"><span class="hs-identifier hs-var">g</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Set a
</span><a href="#local-6989586621679118662"><span class="hs-keyword hs-var">as</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; Set a -&gt; Set a -&gt; Bool
</span><a href="../../../../containers/html/src"><span class="hs-operator hs-var">`Set.isSubsetOf`</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. AdjacencyMap a b -&gt; Set a
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.html#leftVertexSet"><span class="hs-identifier hs-var">leftVertexSet</span></a></span><span> </span><span class="annot"><span class="annottext">AdjacencyMap a b
</span><a href="#local-6989586621679118660"><span class="hs-identifier hs-var">g</span></a></span><span>
</span><span id="line-395"></span><span>    </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-operator hs-var">&amp;&amp;</span></a></span><span> </span><span class="annot"><span class="annottext">Set b
</span><a href="#local-6989586621679118661"><span class="hs-identifier hs-var">bs</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; Set a -&gt; Set a -&gt; Bool
</span><a href="../../../../containers/html/src"><span class="hs-operator hs-var">`Set.isSubsetOf`</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. AdjacencyMap a b -&gt; Set b
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.html#rightVertexSet"><span class="hs-identifier hs-var">rightVertexSet</span></a></span><span> </span><span class="annot"><span class="annottext">AdjacencyMap a b
</span><a href="#local-6989586621679118660"><span class="hs-identifier hs-var">g</span></a></span><span>
</span><span id="line-396"></span><span>    </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-operator hs-var">&amp;&amp;</span></a></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *). Foldable t =&gt; t Bool -&gt; Bool
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">and</span></a></span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118656"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; a -&gt; Set a -&gt; Bool
</span><a href="../../../../containers/html/src"><span class="hs-operator hs-var">`Set.member`</span></a></span><span> </span><span class="annot"><span class="annottext">Set a
</span><a href="#local-6989586621679118662"><span class="hs-keyword hs-var">as</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-operator hs-var">||</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118654"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; a -&gt; Set a -&gt; Bool
</span><a href="../../../../containers/html/src"><span class="hs-operator hs-var">`Set.member`</span></a></span><span> </span><span class="annot"><span class="annottext">Set b
</span><a href="#local-6989586621679118661"><span class="hs-identifier hs-var">bs</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679118656"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118656"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679118654"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118654"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall a b. AdjacencyMap a b -&gt; [(a, b)]
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.html#edgeList"><span class="hs-identifier hs-var">edgeList</span></a></span><span> </span><span class="annot"><span class="annottext">AdjacencyMap a b
</span><a href="#local-6989586621679118660"><span class="hs-identifier hs-var">g</span></a></span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-397"></span><span>
</span><span id="line-398"></span><span class="hs-comment">-- | The number of vertices in a vertex cover.</span><span>
</span><span id="line-399"></span><span class="hs-comment">-- Complexity: /O(1)/ time.</span><span>
</span><span id="line-400"></span><span id="local-6989586621679119167"><span id="local-6989586621679119168"><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#vertexCoverSize"><span class="hs-identifier hs-type">vertexCoverSize</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#VertexCover"><span class="hs-identifier hs-type">VertexCover</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119168"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119167"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span></span></span><span>
</span><span id="line-401"></span><span id="vertexCoverSize"><span class="annot"><span class="annottext">vertexCoverSize :: forall a b. VertexCover a b -&gt; Int
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#vertexCoverSize"><span class="hs-identifier hs-var hs-var">vertexCoverSize</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679118651"><span class="annot"><span class="annottext">Set a
</span><a href="#local-6989586621679118651"><span class="hs-keyword hs-var">as</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679118650"><span class="annot"><span class="annottext">Set b
</span><a href="#local-6989586621679118650"><span class="hs-identifier hs-var">bs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Set a -&gt; Int
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Set.size</span></a></span><span> </span><span class="annot"><span class="annottext">Set a
</span><a href="#local-6989586621679118651"><span class="hs-keyword hs-var">as</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Num a =&gt; a -&gt; a -&gt; a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">+</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Set a -&gt; Int
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Set.size</span></a></span><span> </span><span class="annot"><span class="annottext">Set b
</span><a href="#local-6989586621679118650"><span class="hs-identifier hs-var">bs</span></a></span><span>
</span><span id="line-402"></span><span>
</span><span id="line-403"></span><span class="hs-comment">-- | Find a /minimum vertex cover/ in a bipartite graph. A vertex cover is</span><span>
</span><span id="line-404"></span><span class="hs-comment">-- minimum if it has the smallest possible size.</span><span>
</span><span id="line-405"></span><span class="hs-comment">-- Complexity: /O(m * sqrt(n) * log(n))/.</span><span>
</span><span id="line-406"></span><span class="hs-comment">--</span><span>
</span><span id="line-407"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-408"></span><span class="hs-comment">-- minVertexCover 'empty'                              == (Set.'Set.empty', Set.'Set.empty')</span><span>
</span><span id="line-409"></span><span class="hs-comment">-- minVertexCover ('vertices' xs ys)                   == (Set.'Set.empty', Set.'Set.empty')</span><span>
</span><span id="line-410"></span><span class="hs-comment">-- minVertexCover ('path' [1,2,3])                     == (Set.'Set.empty', Set.'Set.singleton' 2)</span><span>
</span><span id="line-411"></span><span class="hs-comment">-- minVertexCover ('star' x (1:2:ys))                  == (Set.'Set.singleton' x, Set.'Set.empty')</span><span>
</span><span id="line-412"></span><span class="hs-comment">-- 'vertexCoverSize' (minVertexCover ('biclique' xs ys)) == 'min' ('length' ('Data.List.nub' xs)) ('length' ('Data.List.nub' ys))</span><span>
</span><span id="line-413"></span><span class="hs-comment">-- 'vertexCoverSize' . minVertexCover                  == 'matchingSize' . 'maxMatching'</span><span>
</span><span id="line-414"></span><span class="hs-comment">-- 'isVertexCoverOf' (minVertexCover x) x              == True</span><span>
</span><span id="line-415"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-416"></span><span id="local-6989586621679119161"><span id="local-6989586621679119162"><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#minVertexCover"><span class="hs-identifier hs-type">minVertexCover</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Ord</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119162"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Ord</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119161"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.html#AdjacencyMap"><span class="hs-identifier hs-type">AdjacencyMap</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119162"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119161"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#VertexCover"><span class="hs-identifier hs-type">VertexCover</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119162"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119161"><span class="hs-identifier hs-type">b</span></a></span></span></span><span>
</span><span id="line-417"></span><span id="minVertexCover"><span class="annot"><span class="annottext">minVertexCover :: forall a b. (Ord a, Ord b) =&gt; AdjacencyMap a b -&gt; VertexCover a b
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#minVertexCover"><span class="hs-identifier hs-var hs-var">minVertexCover</span></a></span></span><span> </span><span id="local-6989586621679118642"><span class="annot"><span class="annottext">AdjacencyMap a b
</span><a href="#local-6989586621679118642"><span class="hs-identifier hs-var">g</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. a -&gt; Either a b -&gt; a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">fromLeft</span></a></span><span> </span><span class="annot"><span class="annottext">forall {a}. a
</span><a href="#local-6989586621679118641"><span class="hs-identifier hs-var">panic</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b.
(Ord a, Ord b) =&gt;
Matching a b
-&gt; AdjacencyMap a b -&gt; Either (VertexCover a b) (List a b)
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#augmentingPath"><span class="hs-identifier hs-var">augmentingPath</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. (Ord a, Ord b) =&gt; AdjacencyMap a b -&gt; Matching a b
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#maxMatching"><span class="hs-identifier hs-var">maxMatching</span></a></span><span> </span><span class="annot"><span class="annottext">AdjacencyMap a b
</span><a href="#local-6989586621679118642"><span class="hs-identifier hs-var">g</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">AdjacencyMap a b
</span><a href="#local-6989586621679118642"><span class="hs-identifier hs-var">g</span></a></span><span>
</span><span id="line-418"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-419"></span><span>    </span><span id="local-6989586621679118641"><span class="annot"><span class="annottext">panic :: a
</span><a href="#local-6989586621679118641"><span class="hs-identifier hs-var hs-var">panic</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. HasCallStack =&gt; String -&gt; a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">error</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;minVertexCover: internal error (found augmenting path)&quot;</span></span><span>
</span><span id="line-420"></span><span>
</span><span id="line-421"></span><span class="hs-comment">-- | An /independent set/ of a bipartite graph.</span><span>
</span><span id="line-422"></span><span class="hs-comment">--</span><span>
</span><span id="line-423"></span><span class="hs-comment">-- An /independent set/ is a subset of vertices such that no two of them are</span><span>
</span><span id="line-424"></span><span class="hs-comment">-- adjacent. We represent independent sets by storing two sets of vertices, one</span><span>
</span><span id="line-425"></span><span class="hs-comment">-- for each part. An equivalent representation, which is slightly less memory</span><span>
</span><span id="line-426"></span><span class="hs-comment">-- efficient, is @Set@ @(Either@ @a@ @b)@.</span><span>
</span><span id="line-427"></span><span class="hs-keyword">type</span><span> </span><span id="IndependentSet"><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#IndependentSet"><span class="hs-identifier hs-var">IndependentSet</span></a></span></span><span> </span><span id="local-6989586621679118637"><span class="annot"><a href="#local-6989586621679118637"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span id="local-6989586621679118636"><span class="annot"><a href="#local-6989586621679118636"><span class="hs-identifier hs-type">b</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../../../containers/html/src"><span class="hs-identifier hs-type">Set</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118637"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../../../containers/html/src"><span class="hs-identifier hs-type">Set</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118636"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-428"></span><span>
</span><span id="line-429"></span><span class="hs-comment">-- | Check if a given pair of sets is an /independent set/ of a bipartite graph.</span><span>
</span><span id="line-430"></span><span class="hs-comment">-- Complexity: /O(m * log(n))/.</span><span>
</span><span id="line-431"></span><span class="hs-comment">--</span><span>
</span><span id="line-432"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-433"></span><span class="hs-comment">-- isIndependentSetOf (xs             , ys             ) 'empty'          == Set.'Set.null' xs &amp;&amp; Set.'Set.null' ys</span><span>
</span><span id="line-434"></span><span class="hs-comment">-- isIndependentSetOf (xs             , ys             ) ('leftVertex' x) == Set.'Set.isSubsetOf' xs (Set.'Set.singleton' x) &amp;&amp; Set.'Set.null' ys</span><span>
</span><span id="line-435"></span><span class="hs-comment">-- isIndependentSetOf (Set.'Set.empty'      , Set.'Set.empty'      ) ('edge' x y)     == True</span><span>
</span><span id="line-436"></span><span class="hs-comment">-- isIndependentSetOf (Set.'Set.singleton' x, ys             ) ('edge' x y)     == Set.'Set.null' ys</span><span>
</span><span id="line-437"></span><span class="hs-comment">-- isIndependentSetOf (xs             , Set.'Set.singleton' y) ('edge' x y)     == Set.'Set.null' xs</span><span>
</span><span id="line-438"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-439"></span><span id="local-6989586621679118634"><span id="local-6989586621679118635"><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#isIndependentSetOf"><span class="hs-identifier hs-type">isIndependentSetOf</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Ord</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118635"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Ord</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118634"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../../../containers/html/src"><span class="hs-identifier hs-type">Set</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118635"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../../../containers/html/src"><span class="hs-identifier hs-type">Set</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118634"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.html#AdjacencyMap"><span class="hs-identifier hs-type">AdjacencyMap</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118635"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118634"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Bool</span></a></span></span></span><span>
</span><span id="line-440"></span><span id="isIndependentSetOf"><span class="annot"><span class="annottext">isIndependentSetOf :: forall a b.
(Ord a, Ord b) =&gt;
(Set a, Set b) -&gt; AdjacencyMap a b -&gt; Bool
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#isIndependentSetOf"><span class="hs-identifier hs-var hs-var">isIndependentSetOf</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679118626"><span class="annot"><span class="annottext">Set a
</span><a href="#local-6989586621679118626"><span class="hs-keyword hs-var">as</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679118625"><span class="annot"><span class="annottext">Set b
</span><a href="#local-6989586621679118625"><span class="hs-identifier hs-var">bs</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679118624"><span class="annot"><span class="annottext">AdjacencyMap a b
</span><a href="#local-6989586621679118624"><span class="hs-identifier hs-var">g</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Set a
</span><a href="#local-6989586621679118626"><span class="hs-keyword hs-var">as</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; Set a -&gt; Set a -&gt; Bool
</span><a href="../../../../containers/html/src"><span class="hs-operator hs-var">`Set.isSubsetOf`</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. AdjacencyMap a b -&gt; Set a
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.html#leftVertexSet"><span class="hs-identifier hs-var">leftVertexSet</span></a></span><span> </span><span class="annot"><span class="annottext">AdjacencyMap a b
</span><a href="#local-6989586621679118624"><span class="hs-identifier hs-var">g</span></a></span><span>
</span><span id="line-441"></span><span>    </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-operator hs-var">&amp;&amp;</span></a></span><span> </span><span class="annot"><span class="annottext">Set b
</span><a href="#local-6989586621679118625"><span class="hs-identifier hs-var">bs</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; Set a -&gt; Set a -&gt; Bool
</span><a href="../../../../containers/html/src"><span class="hs-operator hs-var">`Set.isSubsetOf`</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. AdjacencyMap a b -&gt; Set b
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.html#rightVertexSet"><span class="hs-identifier hs-var">rightVertexSet</span></a></span><span> </span><span class="annot"><span class="annottext">AdjacencyMap a b
</span><a href="#local-6989586621679118624"><span class="hs-identifier hs-var">g</span></a></span><span>
</span><span id="line-442"></span><span>    </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-operator hs-var">&amp;&amp;</span></a></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *). Foldable t =&gt; t Bool -&gt; Bool
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">and</span></a></span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-var">not</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118623"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; a -&gt; Set a -&gt; Bool
</span><a href="../../../../containers/html/src"><span class="hs-operator hs-var">`Set.member`</span></a></span><span> </span><span class="annot"><span class="annottext">Set a
</span><a href="#local-6989586621679118626"><span class="hs-keyword hs-var">as</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-operator hs-var">&amp;&amp;</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118622"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; a -&gt; Set a -&gt; Bool
</span><a href="../../../../containers/html/src"><span class="hs-operator hs-var">`Set.member`</span></a></span><span> </span><span class="annot"><span class="annottext">Set b
</span><a href="#local-6989586621679118625"><span class="hs-identifier hs-var">bs</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679118623"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118623"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679118622"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118622"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall a b. AdjacencyMap a b -&gt; [(a, b)]
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.html#edgeList"><span class="hs-identifier hs-var">edgeList</span></a></span><span> </span><span class="annot"><span class="annottext">AdjacencyMap a b
</span><a href="#local-6989586621679118624"><span class="hs-identifier hs-var">g</span></a></span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-443"></span><span>
</span><span id="line-444"></span><span class="hs-comment">-- | The number of vertices in an independent set.</span><span>
</span><span id="line-445"></span><span class="hs-comment">-- Complexity: /O(1)/ time.</span><span>
</span><span id="line-446"></span><span id="local-6989586621679118620"><span id="local-6989586621679118621"><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#independentSetSize"><span class="hs-identifier hs-type">independentSetSize</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#IndependentSet"><span class="hs-identifier hs-type">IndependentSet</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118621"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118620"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span></span></span><span>
</span><span id="line-447"></span><span id="independentSetSize"><span class="annot"><span class="annottext">independentSetSize :: forall a b. VertexCover a b -&gt; Int
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#independentSetSize"><span class="hs-identifier hs-var hs-var">independentSetSize</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679118618"><span class="annot"><span class="annottext">Set a
</span><a href="#local-6989586621679118618"><span class="hs-keyword hs-var">as</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679118617"><span class="annot"><span class="annottext">Set b
</span><a href="#local-6989586621679118617"><span class="hs-identifier hs-var">bs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Set a -&gt; Int
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Set.size</span></a></span><span> </span><span class="annot"><span class="annottext">Set a
</span><a href="#local-6989586621679118618"><span class="hs-keyword hs-var">as</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Num a =&gt; a -&gt; a -&gt; a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">+</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Set a -&gt; Int
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Set.size</span></a></span><span> </span><span class="annot"><span class="annottext">Set b
</span><a href="#local-6989586621679118617"><span class="hs-identifier hs-var">bs</span></a></span><span>
</span><span id="line-448"></span><span>
</span><span id="line-449"></span><span class="hs-comment">-- | Find a /maximum independent set/ in a bipartite graph. An independent set</span><span>
</span><span id="line-450"></span><span class="hs-comment">-- is maximum if it has the largest possible size.</span><span>
</span><span id="line-451"></span><span class="hs-comment">-- Complexity: /O(m * sqrt(n) * log(n))/.</span><span>
</span><span id="line-452"></span><span class="hs-comment">--</span><span>
</span><span id="line-453"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-454"></span><span class="hs-comment">-- maxIndependentSet 'empty'                                 == (Set.'Set.empty', Set.'Set.empty')</span><span>
</span><span id="line-455"></span><span class="hs-comment">-- maxIndependentSet ('vertices' xs ys)                      == (Set.'Set.fromList' xs, Set.'Set.fromList' ys)</span><span>
</span><span id="line-456"></span><span class="hs-comment">-- maxIndependentSet ('path' [1,2,3])                        == (Set.'Set.fromList' [1,3], Set.'Set.empty')</span><span>
</span><span id="line-457"></span><span class="hs-comment">-- maxIndependentSet ('star' x (1:2:ys))                     == (Set.'Set.empty', Set.'Set.fromList' (1:2:ys))</span><span>
</span><span id="line-458"></span><span class="hs-comment">-- 'independentSetSize' (maxIndependentSet ('biclique' xs ys)) == 'max' ('length' ('Data.List.nub' xs)) ('length' ('Data.List.nub' ys))</span><span>
</span><span id="line-459"></span><span class="hs-comment">-- 'independentSetSize' (maxIndependentSet x)                == 'vertexCount' x - 'vertexCoverSize' ('minVertexCover' x)</span><span>
</span><span id="line-460"></span><span class="hs-comment">-- 'isIndependentSetOf' (maxIndependentSet x) x              == True</span><span>
</span><span id="line-461"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-462"></span><span id="local-6989586621679118615"><span id="local-6989586621679118616"><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#maxIndependentSet"><span class="hs-identifier hs-type">maxIndependentSet</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Ord</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118616"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Ord</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118615"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.html#AdjacencyMap"><span class="hs-identifier hs-type">AdjacencyMap</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118616"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118615"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#IndependentSet"><span class="hs-identifier hs-type">IndependentSet</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118616"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118615"><span class="hs-identifier hs-type">b</span></a></span></span></span><span>
</span><span id="line-463"></span><span id="maxIndependentSet"><span class="annot"><span class="annottext">maxIndependentSet :: forall a b. (Ord a, Ord b) =&gt; AdjacencyMap a b -&gt; VertexCover a b
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#maxIndependentSet"><span class="hs-identifier hs-var hs-var">maxIndependentSet</span></a></span></span><span> </span><span id="local-6989586621679118608"><span class="annot"><span class="annottext">AdjacencyMap a b
</span><a href="#local-6989586621679118608"><span class="hs-identifier hs-var">g</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-464"></span><span>    </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. AdjacencyMap a b -&gt; Set a
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.html#leftVertexSet"><span class="hs-identifier hs-var">leftVertexSet</span></a></span><span> </span><span class="annot"><span class="annottext">AdjacencyMap a b
</span><a href="#local-6989586621679118608"><span class="hs-identifier hs-var">g</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; Set a -&gt; Set a -&gt; Set a
</span><a href="../../../../containers/html/src"><span class="hs-operator hs-var">`Set.difference`</span></a></span><span> </span><span class="annot"><span class="annottext">Set a
</span><a href="#local-6989586621679118606"><span class="hs-keyword hs-var">as</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a b. AdjacencyMap a b -&gt; Set b
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.html#rightVertexSet"><span class="hs-identifier hs-var">rightVertexSet</span></a></span><span> </span><span class="annot"><span class="annottext">AdjacencyMap a b
</span><a href="#local-6989586621679118608"><span class="hs-identifier hs-var">g</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; Set a -&gt; Set a -&gt; Set a
</span><a href="../../../../containers/html/src"><span class="hs-operator hs-var">`Set.difference`</span></a></span><span> </span><span class="annot"><span class="annottext">Set b
</span><a href="#local-6989586621679118605"><span class="hs-identifier hs-var">bs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-465"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-466"></span><span>    </span><span class="hs-special">(</span><span id="local-6989586621679118606"><span class="annot"><span class="annottext">Set a
</span><a href="#local-6989586621679118606"><span class="hs-keyword hs-var">as</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679118605"><span class="annot"><span class="annottext">Set b
</span><a href="#local-6989586621679118605"><span class="hs-identifier hs-var">bs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. (Ord a, Ord b) =&gt; AdjacencyMap a b -&gt; VertexCover a b
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#minVertexCover"><span class="hs-identifier hs-var">minVertexCover</span></a></span><span> </span><span class="annot"><span class="annottext">AdjacencyMap a b
</span><a href="#local-6989586621679118608"><span class="hs-identifier hs-var">g</span></a></span><span>
</span><span id="line-467"></span><span>
</span><span id="line-468"></span><span class="hs-comment">-- | Given a matching in a bipartite graph, find either a /vertex cover/ of the</span><span>
</span><span id="line-469"></span><span class="hs-comment">-- same size or an /augmenting path/ with respect to the matching, thereby</span><span>
</span><span id="line-470"></span><span class="hs-comment">-- demonstrating that the matching is not maximum.</span><span>
</span><span id="line-471"></span><span class="hs-comment">-- Complexity: /O((m + n) * log(n))/.</span><span>
</span><span id="line-472"></span><span class="hs-comment">--</span><span>
</span><span id="line-473"></span><span class="hs-comment">-- An /alternating path/ is a path whose edges belong alternately to the</span><span>
</span><span id="line-474"></span><span class="hs-comment">-- matching and not to the matching. An /augmenting path/ is an alternating path</span><span>
</span><span id="line-475"></span><span class="hs-comment">-- that starts from and ends on the vertices that are not covered by the</span><span>
</span><span id="line-476"></span><span class="hs-comment">-- matching. A matching is maximum if and only if there is no augmenting path</span><span>
</span><span id="line-477"></span><span class="hs-comment">-- with respect to it.</span><span>
</span><span id="line-478"></span><span class="hs-comment">--</span><span>
</span><span id="line-479"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-480"></span><span class="hs-comment">-- augmentingPath ('matching' [])      'empty'            == Left (Set.'Set.empty', Set.'Set.empty')</span><span>
</span><span id="line-481"></span><span class="hs-comment">-- augmentingPath ('matching' [])      ('edge' 1 2)       == Right [1,2]</span><span>
</span><span id="line-482"></span><span class="hs-comment">-- augmentingPath ('matching' [(1,2)]) ('path' [1,2,3])   == Left (Set.'Set.empty', Set.'Set.singleton' 2)</span><span>
</span><span id="line-483"></span><span class="hs-comment">-- augmentingPath ('matching' [(3,2)]) ('path' [1,2,3,4]) == Right [1,2,3,4]</span><span>
</span><span id="line-484"></span><span class="hs-comment">-- isLeft (augmentingPath ('maxMatching' x) x)          == True</span><span>
</span><span id="line-485"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-486"></span><span id="local-6989586621679119154"><span id="local-6989586621679119155"><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#augmentingPath"><span class="hs-identifier hs-type">augmentingPath</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Ord</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119155"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Ord</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119154"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#Matching"><span class="hs-identifier hs-type">Matching</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119155"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119154"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.html#AdjacencyMap"><span class="hs-identifier hs-type">AdjacencyMap</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119155"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119154"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">Either</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#VertexCover"><span class="hs-identifier hs-type">VertexCover</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119155"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119154"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.html#List"><span class="hs-identifier hs-type">List</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119155"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119154"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span><span>
</span><span id="line-487"></span><span id="augmentingPath"><span class="annot"><span class="annottext">augmentingPath :: forall a b.
(Ord a, Ord b) =&gt;
Matching a b
-&gt; AdjacencyMap a b -&gt; Either (VertexCover a b) (List a b)
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#augmentingPath"><span class="hs-identifier hs-var hs-var">augmentingPath</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b.
(Ord a, Ord b) =&gt;
Matching a b
-&gt; AdjacencyMap a b -&gt; Either (VertexCover a b) (List a b)
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#augmentingPathImpl"><span class="hs-identifier hs-var">augmentingPathImpl</span></a></span><span>
</span><span id="line-488"></span><span>
</span><span id="line-489"></span><span class="hs-keyword">type</span><span> </span><span id="AugPathMonad"><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#AugPathMonad"><span class="hs-identifier hs-var">AugPathMonad</span></a></span></span><span> </span><span id="local-6989586621679118599"><span class="annot"><a href="#local-6989586621679118599"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span id="local-6989586621679118598"><span class="annot"><a href="#local-6989586621679118598"><span class="hs-identifier hs-type">b</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="../../../../transformers/html/src"><span class="hs-identifier hs-type">MaybeT</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../../../transformers/html/src"><span class="hs-identifier hs-type">State</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#VertexCover"><span class="hs-identifier hs-type">VertexCover</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118599"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118598"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.html#List"><span class="hs-identifier hs-type">List</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118599"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118598"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-490"></span><span>
</span><span id="line-491"></span><span class="hs-comment">-- The implementation is in a separate function to avoid the &quot;forall&quot; in docs.</span><span>
</span><span id="line-492"></span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#augmentingPathImpl"><span class="hs-identifier hs-type">augmentingPathImpl</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679118597"><span class="annot"><a href="#local-6989586621679118597"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span id="local-6989586621679118596"><span class="annot"><a href="#local-6989586621679118596"><span class="hs-identifier hs-type">b</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Ord</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118597"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Ord</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118596"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#Matching"><span class="hs-identifier hs-type">Matching</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118597"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118596"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.html#AdjacencyMap"><span class="hs-identifier hs-type">AdjacencyMap</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118597"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118596"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">Either</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#VertexCover"><span class="hs-identifier hs-type">VertexCover</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118597"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118596"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.html#List"><span class="hs-identifier hs-type">List</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118597"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118596"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-493"></span><span id="augmentingPathImpl"><span class="annot"><span class="annottext">augmentingPathImpl :: forall a b.
(Ord a, Ord b) =&gt;
Matching a b
-&gt; AdjacencyMap a b -&gt; Either (VertexCover a b) (List a b)
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#augmentingPathImpl"><span class="hs-identifier hs-var hs-var">augmentingPathImpl</span></a></span></span><span> </span><span id="local-6989586621679118557"><span class="annot"><span class="annottext">Matching a b
</span><a href="#local-6989586621679118557"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679118556"><span class="annot"><span class="annottext">AdjacencyMap a b
</span><a href="#local-6989586621679118556"><span class="hs-identifier hs-var">g</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">forall s a. State s a -&gt; s -&gt; (a, s)
</span><a href="../../../../transformers/html/src"><span class="hs-identifier hs-var">runState</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. MaybeT m a -&gt; m (Maybe a)
</span><a href="../../../../transformers/html/src"><span class="hs-identifier hs-var">runMaybeT</span></a></span><span> </span><span class="annot"><span class="annottext">AugPathMonad a b
</span><a href="#local-6989586621679118555"><span class="hs-identifier hs-var">dfs</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. AdjacencyMap a b -&gt; Set a
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.html#leftVertexSet"><span class="hs-identifier hs-var">leftVertexSet</span></a></span><span> </span><span class="annot"><span class="annottext">AdjacencyMap a b
</span><a href="#local-6989586621679118556"><span class="hs-identifier hs-var">g</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a. Set a
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Set.empty</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-494"></span><span>    </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe (List a b)
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">Nothing</span></a></span><span>  </span><span class="hs-special">,</span><span> </span><span id="local-6989586621679118554"><span class="annot"><span class="annottext">VertexCover a b
</span><a href="#local-6989586621679118554"><span class="hs-identifier hs-var">cover</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a b. a -&gt; Either a b
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">Left</span></a></span><span> </span><span class="annot"><span class="annottext">VertexCover a b
</span><a href="#local-6989586621679118554"><span class="hs-identifier hs-var">cover</span></a></span><span>
</span><span id="line-495"></span><span>    </span><span class="hs-special">(</span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">Just</span></a></span><span> </span><span id="local-6989586621679118553"><span class="annot"><span class="annottext">List a b
</span><a href="#local-6989586621679118553"><span class="hs-identifier hs-var">path</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">VertexCover a b
</span><span class="hs-identifier">_</span></span><span>    </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a b. b -&gt; Either a b
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">Right</span></a></span><span> </span><span class="annot"><span class="annottext">List a b
</span><a href="#local-6989586621679118553"><span class="hs-identifier hs-var">path</span></a></span><span>
</span><span id="line-496"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-497"></span><span>    </span><span class="annot"><a href="#local-6989586621679118555"><span class="hs-identifier hs-type">dfs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#AugPathMonad"><span class="hs-identifier hs-type">AugPathMonad</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118597"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118596"><span class="hs-identifier hs-type">b</span></a></span><span>
</span><span id="line-498"></span><span>    </span><span id="local-6989586621679118555"><span class="annot"><span class="annottext">dfs :: AugPathMonad a b
</span><a href="#local-6989586621679118555"><span class="hs-identifier hs-var hs-var">dfs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (f :: * -&gt; *) a.
(Foldable t, Alternative f) =&gt;
t (f a) -&gt; f a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">asum</span></a></span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">a -&gt; AugPathMonad a b
</span><a href="#local-6989586621679118552"><span class="hs-identifier hs-var">inVertex</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118551"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679118551"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118551"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall a b. AdjacencyMap a b -&gt; [a]
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.html#leftVertexList"><span class="hs-identifier hs-var">leftVertexList</span></a></span><span> </span><span class="annot"><span class="annottext">AdjacencyMap a b
</span><a href="#local-6989586621679118556"><span class="hs-identifier hs-var">g</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-var">not</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. Ord a =&gt; a -&gt; Matching a b -&gt; Bool
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#leftCovered"><span class="hs-identifier hs-var">leftCovered</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118551"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">Matching a b
</span><a href="#local-6989586621679118557"><span class="hs-identifier hs-var">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-499"></span><span>
</span><span id="line-500"></span><span>    </span><span class="annot"><a href="#local-6989586621679118552"><span class="hs-identifier hs-type">inVertex</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679118597"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#AugPathMonad"><span class="hs-identifier hs-type">AugPathMonad</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118597"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118596"><span class="hs-identifier hs-type">b</span></a></span><span>
</span><span id="line-501"></span><span>    </span><span id="local-6989586621679118552"><span class="annot"><span class="annottext">inVertex :: a -&gt; AugPathMonad a b
</span><a href="#local-6989586621679118552"><span class="hs-identifier hs-var hs-var">inVertex</span></a></span></span><span> </span><span id="local-6989586621679118550"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118550"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679118549"><span class="annot"><span class="annottext">Set a
</span><a href="#local-6989586621679118549"><span class="hs-keyword hs-var">as</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679118548"><span class="annot"><span class="annottext">Set b
</span><a href="#local-6989586621679118548"><span class="hs-identifier hs-var">bs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
(MonadTrans t, Monad m) =&gt;
m a -&gt; t m a
</span><a href="../../../../transformers/html/src"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) s. Monad m =&gt; StateT s m s
</span><a href="../../../../transformers/html/src"><span class="hs-identifier hs-var">get</span></a></span><span>
</span><span id="line-502"></span><span>                    </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *). Alternative f =&gt; Bool -&gt; f ()
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">guard</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118550"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; a -&gt; Set a -&gt; Bool
</span><a href="../../../../containers/html/src"><span class="hs-operator hs-var">`Set.member`</span></a></span><span> </span><span class="annot"><span class="annottext">Set a
</span><a href="#local-6989586621679118549"><span class="hs-keyword hs-var">as</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-503"></span><span>                    </span><span class="annot"><span class="annottext">forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
(MonadTrans t, Monad m) =&gt;
m a -&gt; t m a
</span><a href="../../../../transformers/html/src"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) s. Monad m =&gt; s -&gt; StateT s m ()
</span><a href="../../../../transformers/html/src"><span class="hs-identifier hs-var">put</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Ord a =&gt; a -&gt; Set a -&gt; Set a
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Set.delete</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118550"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">Set a
</span><a href="#local-6989586621679118549"><span class="hs-keyword hs-var">as</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Set b
</span><a href="#local-6989586621679118548"><span class="hs-identifier hs-var">bs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-504"></span><span>                    </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (f :: * -&gt; *) a.
(Foldable t, Alternative f) =&gt;
t (f a) -&gt; f a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">asum</span></a></span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">a -&gt; b -&gt; AugPathMonad a b
</span><a href="#local-6989586621679118546"><span class="hs-identifier hs-var">onEdge</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118550"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118545"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679118545"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118545"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">a -&gt; [b]
</span><a href="#local-6989586621679118544"><span class="hs-identifier hs-var">neighbours</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118550"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-505"></span><span>
</span><span id="line-506"></span><span>    </span><span class="annot"><a href="#local-6989586621679118546"><span class="hs-identifier hs-type">onEdge</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679118597"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679118596"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#AugPathMonad"><span class="hs-identifier hs-type">AugPathMonad</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118597"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118596"><span class="hs-identifier hs-type">b</span></a></span><span>
</span><span id="line-507"></span><span>    </span><span id="local-6989586621679118546"><span class="annot"><span class="annottext">onEdge :: a -&gt; b -&gt; AugPathMonad a b
</span><a href="#local-6989586621679118546"><span class="hs-identifier hs-var hs-var">onEdge</span></a></span></span><span> </span><span id="local-6989586621679118543"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118543"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="local-6989586621679118542"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118542"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; b -&gt; List a b -&gt; List a b
</span><a href="#local-6989586621679118541"><span class="hs-identifier hs-var">addEdge</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118543"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118542"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">&lt;$&gt;</span></a></span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679118540"><span class="annot"><span class="annottext">Set a
</span><a href="#local-6989586621679118540"><span class="hs-keyword hs-var">as</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679118539"><span class="annot"><span class="annottext">Set b
</span><a href="#local-6989586621679118539"><span class="hs-identifier hs-var">bs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
(MonadTrans t, Monad m) =&gt;
m a -&gt; t m a
</span><a href="../../../../transformers/html/src"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) s. Monad m =&gt; StateT s m s
</span><a href="../../../../transformers/html/src"><span class="hs-identifier hs-var">get</span></a></span><span>
</span><span id="line-508"></span><span>                                    </span><span class="annot"><span class="annottext">forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
(MonadTrans t, Monad m) =&gt;
m a -&gt; t m a
</span><a href="../../../../transformers/html/src"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) s. Monad m =&gt; s -&gt; StateT s m ()
</span><a href="../../../../transformers/html/src"><span class="hs-identifier hs-var">put</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Set a
</span><a href="#local-6989586621679118540"><span class="hs-keyword hs-var">as</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; a -&gt; Set a -&gt; Set a
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Set.insert</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118542"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">Set b
</span><a href="#local-6989586621679118539"><span class="hs-identifier hs-var">bs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-509"></span><span>                                    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118542"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Maybe a
</span><a href="../../../../containers/html/src"><span class="hs-operator hs-var">`Map.lookup`</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. Matching a b -&gt; Map b a
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#pairOfRight"><span class="hs-identifier hs-var">pairOfRight</span></a></span><span> </span><span class="annot"><span class="annottext">Matching a b
</span><a href="#local-6989586621679118557"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-510"></span><span>                                        </span><span class="annot"><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">Just</span></a></span><span> </span><span id="local-6989586621679118538"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118538"><span class="hs-identifier hs-var">a</span></a></span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">a -&gt; AugPathMonad a b
</span><a href="#local-6989586621679118552"><span class="hs-identifier hs-var">inVertex</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118538"><span class="hs-identifier hs-var">a</span></a></span><span>
</span><span id="line-511"></span><span>                                        </span><span class="annot"><span class="annottext">Maybe a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">Nothing</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">return</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. List a b
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.html#Nil"><span class="hs-identifier hs-var">Nil</span></a></span><span>
</span><span id="line-512"></span><span>
</span><span id="line-513"></span><span>    </span><span class="annot"><a href="#local-6989586621679118541"><span class="hs-identifier hs-type">addEdge</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679118597"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679118596"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.html#List"><span class="hs-identifier hs-type">List</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118597"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118596"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.html#List"><span class="hs-identifier hs-type">List</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118597"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679118596"><span class="hs-identifier hs-type">b</span></a></span><span>
</span><span id="line-514"></span><span>    </span><span id="local-6989586621679118541"><span class="annot"><span class="annottext">addEdge :: a -&gt; b -&gt; List a b -&gt; List a b
</span><a href="#local-6989586621679118541"><span class="hs-identifier hs-var hs-var">addEdge</span></a></span></span><span> </span><span id="local-6989586621679118536"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118536"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="local-6989586621679118535"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118535"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. a -&gt; List b a -&gt; List a b
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.html#Cons"><span class="hs-identifier hs-var">Cons</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118536"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. a -&gt; List b a -&gt; List a b
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.html#Cons"><span class="hs-identifier hs-var">Cons</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118535"><span class="hs-identifier hs-var">b</span></a></span><span>
</span><span id="line-515"></span><span>
</span><span id="line-516"></span><span>    </span><span class="annot"><a href="#local-6989586621679118544"><span class="hs-identifier hs-type">neighbours</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679118597"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679118596"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-517"></span><span>    </span><span id="local-6989586621679118544"><span class="annot"><span class="annottext">neighbours :: a -&gt; [b]
</span><a href="#local-6989586621679118544"><span class="hs-identifier hs-var hs-var">neighbours</span></a></span></span><span> </span><span id="local-6989586621679118533"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118533"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Set a -&gt; [a]
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Set.toAscList</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. HasCallStack =&gt; Maybe a -&gt; a
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">fromJust</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Maybe a
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Map.lookup</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118533"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. AdjacencyMap a b -&gt; Map a (Set b)
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.html#leftAdjacencyMap"><span class="hs-identifier hs-var">leftAdjacencyMap</span></a></span><span> </span><span class="annot"><span class="annottext">AdjacencyMap a b
</span><a href="#local-6989586621679118556"><span class="hs-identifier hs-var">g</span></a></span><span>
</span><span id="line-518"></span><span>
</span><span id="line-519"></span><span class="hs-comment">-- | Check if the internal representation of a matching is consistent, i.e. that</span><span>
</span><span id="line-520"></span><span class="hs-comment">-- every edge that is present in 'pairOfLeft' is also present in 'pairOfRight'.</span><span>
</span><span id="line-521"></span><span class="hs-comment">-- Complexity: /O(S * log(S))/, where /S/ is the size of the matching.</span><span>
</span><span id="line-522"></span><span class="hs-comment">--</span><span>
</span><span id="line-523"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-524"></span><span class="hs-comment">-- consistentMatching ('matching' xs)   == True</span><span>
</span><span id="line-525"></span><span class="hs-comment">-- consistentMatching ('maxMatching' x) == True</span><span>
</span><span id="line-526"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-527"></span><span id="local-6989586621679119257"><span id="local-6989586621679119258"><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#consistentMatching"><span class="hs-identifier hs-type">consistentMatching</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Ord</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119258"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Ord</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119257"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#Matching"><span class="hs-identifier hs-type">Matching</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119258"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679119257"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Bool</span></a></span></span></span><span>
</span><span id="line-528"></span><span id="consistentMatching"><span class="annot"><span class="annottext">consistentMatching :: forall a b. (Ord a, Ord b) =&gt; Matching a b -&gt; Bool
</span><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#consistentMatching"><span class="hs-identifier hs-var hs-var">consistentMatching</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Algebra.Graph.Bipartite.AdjacencyMap.Algorithm.html#Matching"><span class="hs-identifier hs-type">Matching</span></a></span><span> </span><span id="local-6989586621679118522"><span class="annot"><span class="annottext">Map a b
</span><a href="#local-6989586621679118522"><span class="hs-identifier hs-var">ab</span></a></span></span><span> </span><span id="local-6989586621679118521"><span class="annot"><span class="annottext">Map b a
</span><a href="#local-6989586621679118521"><span class="hs-identifier hs-var">ba</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-529"></span><span>    </span><span class="annot"><span class="annottext">forall k a. Map k a -&gt; [(k, a)]
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Map.toAscList</span></a></span><span> </span><span class="annot"><span class="annottext">Map a b
</span><a href="#local-6989586621679118522"><span class="hs-identifier hs-var">ab</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><a href="../../../../ghc/html/libraries/ghc-prim-0.8.0/src"><span class="hs-operator hs-var">==</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; [a] -&gt; [a]
</span><a href="../../../../ghc/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">sort</span></a></span><span> </span><span class="hs-special">[</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118520"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118519"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679118519"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679118519"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679118520"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679118520"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall k a. Map k a -&gt; [(k, a)]
</span><a href="../../../../containers/html/src"><span class="hs-identifier hs-var">Map.toAscList</span></a></span><span> </span><span class="annot"><span class="annottext">Map b a
</span><a href="#local-6989586621679118521"><span class="hs-identifier hs-var">ba</span></a></span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-530"></span></pre></body></html>