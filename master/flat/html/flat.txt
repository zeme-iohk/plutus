-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Principled and efficient bit-oriented binary serialization.
--   
--   Reference implementation of <a>flat</a>, a principled and efficient
--   binary serialization format.
@package flat
@version 0.4.4.0.0.0.0.2

module Data.ByteString.Convert

-- | Convert to/from strict ByteStrings
class AsByteString a
toByteString :: AsByteString a => a -> ByteString
fromByteString :: AsByteString a => ByteString -> a
instance Data.ByteString.Convert.AsByteString Data.ByteString.Internal.ByteString
instance Data.ByteString.Convert.AsByteString Data.ByteString.Lazy.Internal.ByteString
instance Data.ByteString.Convert.AsByteString [GHC.Word.Word8]


-- | Primitives to convert between Float/Double and Word32/Word64.
--   
--   Code copied from <a>binary</a>.
--   
--   Based on:
--   <a>http://hackage.haskell.org/package/reinterpret-cast-0.1.0/docs/src/Data-ReinterpretCast-Internal-ImplArray.html</a>..
--   
--   Implements casting via a 1-element STUArray, as described in
--   <a>http://stackoverflow.com/a/7002812/263061</a>.
module Data.FloatCast

-- | Reinterpret-casts a <a>Float</a> to a <a>Word32</a>.
floatToWord :: Float -> Word32

-- | Reinterpret-casts a <a>Word32</a> to a <a>Float</a>.
--   
--   <pre>
--   \f -&gt; wordToFloat (floatToWord f ) == f
--   </pre>
--   
--   +++ OK, passed 100 tests.
--   
--   <pre>
--   &gt;&gt;&gt; floatToWord (-0.15625)
--   3189768192
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; wordToFloat 3189768192
--   -0.15625
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; floatToWord (-5.828125) == 0xC0BA8000
--   True
--   </pre>
wordToFloat :: Word32 -> Float

-- | Reinterpret-casts a <a>Double</a> to a <a>Word64</a>.
--   
--   <pre>
--   \f -&gt; wordToDouble (doubleToWord f ) == f
--   </pre>
--   
--   +++ OK, passed 100 tests.
--   
--   <pre>
--   &gt;&gt;&gt; showHex (doubleToWord 1.0000000000000004) ""
--   "3ff0000000000002"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; doubleToWord 1.0000000000000004 == 0x3FF0000000000002
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; showHex (doubleToWord (-0.15625)) ""
--   "bfc4000000000000"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; wordToDouble 0xbfc4000000000000
--   -0.15625
--   </pre>
doubleToWord :: Double -> Word64

-- | Reinterpret-casts a <a>Word64</a> to a <a>Double</a>.
wordToDouble :: Word64 -> Double

-- | Return the value computed by a state thread. The <tt>forall</tt>
--   ensures that the internal state used by the <a>ST</a> computation is
--   inaccessible to the rest of the program.
runST :: (forall s. () => ST s a) -> a

-- | <pre>
--   &gt;&gt;&gt; runST (cast (0xF0F1F2F3F4F5F6F7::Word64)) == (0xF0F1F2F3F4F5F6F7::Word64)
--   True
--   </pre>
cast :: (MArray (STUArray s) a (ST s), MArray (STUArray s) b (ST s)) => a -> ST s b


-- | <a>ZigZag encoding</a> of signed integrals.
module Data.ZigZag

-- | Convert between a signed integral and the corresponding ZigZag encoded
--   unsigned integral (e.g. between Int8 and Word8 or Integral and
--   Natural).
--   
--   Allow conversion only between compatible types, invalid conversions
--   produce a type error:
--   
--   <pre>
--   zigZag (-1::Int64) :: Word32
--   ...
--   ... Couldn't match type ...
--   ...
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; zigZag (0::Int8)
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; zigZag (-1::Int16)
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; zigZag (1::Int32)
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; zigZag (-2::Int16)
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; zigZag (-50::Integer)
--   99
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; zigZag (50::Integer)
--   100
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; zigZag (64::Integer)
--   128
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; zigZag (-256::Integer)
--   511
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; zigZag (256::Integer)
--   512
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map zigZag [-3..3::Integer]
--   [5,3,1,0,2,4,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map zagZig [0..6::Word8]
--   [0,-1,1,-2,2,-3,3]
--   </pre>
--   
--   <pre>
--   \(f::Integer) -&gt; zagZig (zigZag f) == f
--   </pre>
--   
--   +++ OK, passed 100 tests.
--   
--   <pre>
--   \(f::Natural) -&gt; zigZag (zagZig f) == f
--   </pre>
--   
--   +++ OK, passed 100 tests.
--   
--   <pre>
--   \(f::Int8) -&gt; zagZig (zigZag f) == f
--   </pre>
--   
--   +++ OK, passed 100 tests. prop&gt; (f::Word8) -&gt; zigZag (zagZig f)
--   == f +++ OK, passed 100 tests. prop&gt; (s::Int8) -&gt; zigZag s ==
--   fromIntegral (zigZag (fromIntegral s :: Integer)) +++ OK, passed 100
--   tests. prop&gt; (u::Word8) -&gt; zagZig u == fromIntegral (zagZig
--   (fromIntegral u :: Natural)) +++ OK, passed 100 tests.
--   
--   <pre>
--   \(f::Int64) -&gt; zagZig (zigZag f) == f
--   </pre>
--   
--   +++ OK, passed 100 tests. prop&gt; (f::Word64) -&gt; zigZag (zagZig f)
--   == f +++ OK, passed 100 tests. prop&gt; (s::Int64) -&gt; zigZag s ==
--   fromIntegral (zigZag (fromIntegral s :: Integer)) +++ OK, passed 100
--   tests. prop&gt; (u::Word64) -&gt; zagZig u == fromIntegral (zagZig
--   (fromIntegral u :: Natural)) +++ OK, passed 100 tests.
class (Integral signed, Integral unsigned) => ZigZag signed unsigned | unsigned -> signed, signed -> unsigned
zigZag :: ZigZag signed unsigned => signed -> unsigned
zigZag :: (ZigZag signed unsigned, FiniteBits signed) => signed -> unsigned
zagZig :: ZigZag signed unsigned => unsigned -> signed
zagZig :: (ZigZag signed unsigned, Bits unsigned) => unsigned -> signed
instance Data.ZigZag.ZigZag GHC.Int.Int8 GHC.Word.Word8
instance Data.ZigZag.ZigZag GHC.Int.Int16 GHC.Word.Word16
instance Data.ZigZag.ZigZag GHC.Int.Int32 GHC.Word.Word32
instance Data.ZigZag.ZigZag GHC.Int.Int64 GHC.Word.Word64
instance Data.ZigZag.ZigZag GHC.Num.Integer.Integer GHC.Num.Natural.Natural


-- | Strict Decoder Types
module Flat.Decoder.Types

-- | A decoder.
--   
--   Given: * end of input buffer * current position in input buffer
--   
--   returns: * decoded value * new position in input buffer
newtype Get a
Get :: (Ptr Word8 -> S -> IO (GetResult a)) -> Get a
[runGet] :: Get a -> Ptr Word8 -> S -> IO (GetResult a)

-- | Decoder state
data S
S :: {-# UNPACK #-} !Ptr Word8 -> {-# UNPACK #-} !Int -> S
[currPtr] :: S -> {-# UNPACK #-} !Ptr Word8
[usedBits] :: S -> {-# UNPACK #-} !Int
data GetResult a
GetResult :: {-# UNPACK #-} !S -> !a -> GetResult a

-- | A decoded value
type Decoded a = Either DecodeException a

-- | An exception during decoding
data DecodeException
NotEnoughSpace :: Env -> DecodeException
TooMuchSpace :: Env -> DecodeException
BadEncoding :: Env -> String -> DecodeException
notEnoughSpace :: Ptr Word8 -> S -> IO a
tooMuchSpace :: Ptr Word8 -> S -> IO a
badEncoding :: Ptr Word8 -> S -> String -> IO a
instance GHC.Classes.Ord Flat.Decoder.Types.S
instance GHC.Classes.Eq Flat.Decoder.Types.S
instance GHC.Show.Show Flat.Decoder.Types.S
instance GHC.Base.Functor Flat.Decoder.Types.GetResult
instance GHC.Classes.Ord Flat.Decoder.Types.DecodeException
instance GHC.Classes.Eq Flat.Decoder.Types.DecodeException
instance GHC.Show.Show Flat.Decoder.Types.DecodeException
instance GHC.Exception.Type.Exception Flat.Decoder.Types.DecodeException
instance GHC.Base.Functor Flat.Decoder.Types.Get
instance Control.DeepSeq.NFData (Flat.Decoder.Types.Get a)
instance GHC.Show.Show (Flat.Decoder.Types.Get a)
instance GHC.Base.Applicative Flat.Decoder.Types.Get
instance GHC.Base.Monad Flat.Decoder.Types.Get
instance Control.Monad.Fail.MonadFail Flat.Decoder.Types.Get


-- | Endian utilities Exported for testing purposes, but not meant to be
--   used outside this package.
module Flat.Endian

-- | Convert a 32 bit value in cpu endianess to big endian
--   
--   <pre>
--   &gt;&gt;&gt; toBE32 0xF0F1F2F3 == if isBigEndian then 0xF0F1F2F3 else 0xF3F2F1F0
--   True
--   </pre>
toBE32 :: Word32 -> Word32

-- | Convert a 64 bit value in cpu endianess to big endian
--   
--   <pre>
--   &gt;&gt;&gt; toBE64 0xF0F1F2F3F4F5F6F7 == if isBigEndian then 0xF0F1F2F3F4F5F6F7 else 0xF7F6F5F4F3F2F1F0
--   True
--   </pre>
toBE64 :: Word64 -> Word64

-- | Convert a 16 bit value in cpu endianess to big endian
--   
--   <pre>
--   &gt;&gt;&gt; toBE16 0xF0F1 == if isBigEndian then 0xF0F1 else 0xF1F0
--   True
--   </pre>
toBE16 :: Word16 -> Word16
isBigEndian :: Bool


-- | Memory access primitives.
--   
--   Includes code from the store-core package.
module Flat.Memory
chunksToByteString :: (Ptr Word8, [Int]) -> ByteString
chunksToByteArray :: (Ptr Word8, [Int]) -> (ByteArray, Int)

-- | Byte arrays.
data ByteArray

-- | Create a new bytestring, copying from sourcePtr sourceLength number of
--   bytes peekByteString :: Ptr Word8 -&gt; Int -&gt; BS.ByteString
--   peekByteString sourcePtr sourceLength = BS.unsafeCreate sourceLength $
--   destPointer -&gt; BS.memcpy destPointer sourcePtr sourceLength
pokeByteArray :: ByteArray# -> Int -> Int -> Ptr Word8 -> IO (Ptr Word8)

-- | Copy bytestring to given pointer, returns new pointer
pokeByteString :: ByteString -> Ptr Word8 -> IO (Ptr Word8)
unsafeCreateUptoN' :: Int -> (Ptr Word8 -> IO (Int, a)) -> (ByteString, a)

-- | Computes the offset required to get from the second to the first
--   argument. We have
--   
--   <pre>
--   p2 == p1 `plusPtr` (p2 `minusPtr` p1)
--   </pre>
minusPtr :: Ptr a -> Ptr b -> Int


-- | Strict Decoder Primitives
module Flat.Decoder.Prim

-- | Decode a boolean
dBool :: Get Bool

-- | Return the 8 most significant bits (same as dBE8)
dWord8 :: Get Word8

-- | Return the 8 most significant bits
dBE8 :: Get Word8

-- | Return the 16 most significant bits
dBE16 :: Get Word16

-- | Return the 32 most significant bits
dBE32 :: Get Word32

-- | Return the 64 most significant bits
dBE64 :: Get Word64

-- | Return the n most significant bits (up to maximum of 8)
--   
--   The bits are returned right shifted: &gt;&gt;&gt; unflatWith (dBEBits8
--   3) [0b11100001::Word8] == Right 0b00000111 True
dBEBits8 :: Int -> Get Word8

-- | Return the n most significant bits (up to maximum of 16) The bits are
--   returned right shifted.
dBEBits16 :: Int -> Get Word16

-- | Return the n most significant bits (up to maximum of 32) The bits are
--   returned right shifted.
dBEBits32 :: Int -> Get Word32

-- | Return the n most significant bits (up to maximum of 64) The bits are
--   returned right shifted.
dBEBits64 :: Int -> Get Word64

-- | Drop the specified number of bits
dropBits :: Int -> Get ()

-- | Decode a Float
dFloat :: Get Float

-- | Decode a Double
dDouble :: Get Double

-- | Decode an Array (a list of chunks up to 255 bytes long) returning the
--   pointer to the first data byte and a list of chunk sizes
getChunksInfo :: Get (Ptr Word8, [Int])

-- | Decode a ByteString
dByteString_ :: Get ByteString

-- | Decode a Lazy ByteString
dLazyByteString_ :: Get ByteString

-- | Decode a ByteArray and its length
dByteArray_ :: Get (ByteArray, Int)

-- | A special state, optimised for constructor decoding.
--   
--   It consists of:
--   
--   <ul>
--   <li>The bits to parse, the top bit being the first to parse (could use
--   a Word16 instead, no difference in performance)</li>
--   <li>The number of decoded bits</li>
--   </ul>
--   
--   Supports up to 512 constructors (9 bits).
data ConsState
ConsState :: {-# UNPACK #-} !Word -> !Int -> ConsState

-- | Switch to constructor decoding {-# INLINE consOpen #-}
consOpen :: Get ConsState

-- | Switch back to normal decoding {-# NOINLINE consClose #-}
consClose :: Int -> Get ()

-- | Decode a single bit
consBool :: ConsState -> (ConsState, Bool)

-- | Decode from 1 to 3 bits
--   
--   It could read more bits that are available, but it doesn't matter,
--   errors will be checked in consClose.
consBits :: ConsState -> Int -> (ConsState, Word)


-- | Strict Decoder
module Flat.Decoder.Strict
decodeArrayWith :: Get a -> Get [a]
decodeListWith :: Get a -> Get [a]
dByteString :: Get ByteString
dLazyByteString :: Get ByteString
dShortByteString :: Get ShortByteString
dShortByteString_ :: Get ShortByteString
dUTF16 :: Get Text
dUTF8 :: Get Text
dInteger :: Get Integer
dNatural :: Get Natural
dChar :: Get Char

-- | Return the 8 most significant bits (same as dBE8)
dWord8 :: Get Word8
dWord16 :: Get Word16
dWord32 :: Get Word32
dWord64 :: Get Word64
dWord :: Get Word
dInt8 :: Get Int8
dInt16 :: Get Int16
dInt32 :: Get Int32
dInt64 :: Get Int64
dInt :: Get Int

module Flat.Decoder.Run

-- | Given a decoder and an input buffer returns either the decoded value
--   or an error (if the input buffer is not fully consumed)
strictDecoder :: Get a -> ByteString -> Either DecodeException a
listTDecoder :: Get a -> ByteString -> IO (ListT IO a)


-- | Strict Decoder
module Flat.Decoder

-- | Given a decoder and an input buffer returns either the decoded value
--   or an error (if the input buffer is not fully consumed)
strictDecoder :: Get a -> ByteString -> Either DecodeException a
listTDecoder :: Get a -> ByteString -> IO (ListT IO a)

-- | A decoded value
type Decoded a = Either DecodeException a

-- | An exception during decoding
data DecodeException
NotEnoughSpace :: Env -> DecodeException
TooMuchSpace :: Env -> DecodeException
BadEncoding :: Env -> String -> DecodeException

-- | A decoder.
--   
--   Given: * end of input buffer * current position in input buffer
--   
--   returns: * decoded value * new position in input buffer
data Get a
dByteString :: Get ByteString
dLazyByteString :: Get ByteString
dShortByteString :: Get ShortByteString
dShortByteString_ :: Get ShortByteString
dUTF16 :: Get Text
dUTF8 :: Get Text
decodeArrayWith :: Get a -> Get [a]
decodeListWith :: Get a -> Get [a]

-- | Decode a Float
dFloat :: Get Float

-- | Decode a Double
dDouble :: Get Double
dInteger :: Get Integer
dNatural :: Get Natural
dChar :: Get Char

-- | Decode a boolean
dBool :: Get Bool

-- | Return the 8 most significant bits (same as dBE8)
dWord8 :: Get Word8
dWord16 :: Get Word16
dWord32 :: Get Word32
dWord64 :: Get Word64
dWord :: Get Word
dInt8 :: Get Int8
dInt16 :: Get Int16
dInt32 :: Get Int32
dInt64 :: Get Int64
dInt :: Get Int

-- | Return the 8 most significant bits
dBE8 :: Get Word8

-- | Return the 16 most significant bits
dBE16 :: Get Word16

-- | Return the 32 most significant bits
dBE32 :: Get Word32

-- | Return the 64 most significant bits
dBE64 :: Get Word64

-- | Return the n most significant bits (up to maximum of 8)
--   
--   The bits are returned right shifted: &gt;&gt;&gt; unflatWith (dBEBits8
--   3) [0b11100001::Word8] == Right 0b00000111 True
dBEBits8 :: Int -> Get Word8

-- | Return the n most significant bits (up to maximum of 16) The bits are
--   returned right shifted.
dBEBits16 :: Int -> Get Word16

-- | Return the n most significant bits (up to maximum of 32) The bits are
--   returned right shifted.
dBEBits32 :: Int -> Get Word32

-- | Return the n most significant bits (up to maximum of 64) The bits are
--   returned right shifted.
dBEBits64 :: Int -> Get Word64

-- | Drop the specified number of bits
dropBits :: Int -> Get ()

-- | A special state, optimised for constructor decoding.
--   
--   It consists of:
--   
--   <ul>
--   <li>The bits to parse, the top bit being the first to parse (could use
--   a Word16 instead, no difference in performance)</li>
--   <li>The number of decoded bits</li>
--   </ul>
--   
--   Supports up to 512 constructors (9 bits).
data ConsState
ConsState :: {-# UNPACK #-} !Word -> !Int -> ConsState

-- | Switch to constructor decoding {-# INLINE consOpen #-}
consOpen :: Get ConsState

-- | Switch back to normal decoding {-# NOINLINE consClose #-}
consClose :: Int -> Get ()

-- | Decode a single bit
consBool :: ConsState -> (ConsState, Bool)

-- | Decode from 1 to 3 bits
--   
--   It could read more bits that are available, but it doesn't matter,
--   errors will be checked in consClose.
consBits :: ConsState -> Int -> (ConsState, Word)

module Flat.Tutorial


-- | Common Types
module Flat.Types

-- | Number of bits
type NumBits = Int

-- | Natural number
--   
--   Invariant: numbers &lt;= 0xffffffffffffffff use the <a>NS</a>
--   constructor
data Natural

-- | A compact representation of a <a>Word8</a> vector.
--   
--   It has a lower memory overhead than a <a>ByteString</a> and does not
--   contribute to heap fragmentation. It can be converted to or from a
--   <a>ByteString</a> (at the cost of copying the string data). It
--   supports very few other operations.
--   
--   It is suitable for use as an internal representation for code that
--   needs to keep many short strings in memory, but it <i>should not</i>
--   be used as an interchange type. That is, it should not generally be
--   used in public APIs. The <a>ByteString</a> type is usually more
--   suitable for use in interfaces; it is more flexible and it supports a
--   wide range of operations.
data ShortByteString

-- | A space efficient, packed, unboxed Unicode text type.
data Text


-- | Encoder Types
module Flat.Encoder.Types

-- | Calculate the size (in bits) of the encoding of a value
type Size a = a -> NumBits -> NumBits

-- | Number of bits
type NumBits = Int

-- | A basic encoder
type Prim = S -> IO S

-- | Strict encoder state
data S
S :: {-# UNPACK #-} !Ptr Word8 -> {-# UNPACK #-} !Word8 -> {-# UNPACK #-} !NumBits -> S
[nextPtr] :: S -> {-# UNPACK #-} !Ptr Word8
[currByte] :: S -> {-# UNPACK #-} !Word8
[usedBits] :: S -> {-# UNPACK #-} !NumBits
instance GHC.Show.Show Flat.Encoder.Types.S


-- | Encoding Primitives
module Flat.Encoder.Prim

-- | Encode up to 9 bits
eBits16F :: NumBits -> Word16 -> Prim

-- | Encode up to 8 bits.
eBitsF :: NumBits -> Word8 -> Prim
eFloatF :: Float -> Prim
eDoubleF :: Double -> Prim

-- | Encode text as UTF16 and encode the result as an array of bytes
--   Efficient, as Text is already internally encoded as UTF16.
eUTF16F :: Text -> Prim

-- | Encode text as UTF8 and encode the result as an array of bytes PROB:
--   encodeUtf8 calls a C primitive, not compatible with GHCJS (fixed in
--   latest versions of GHCJS?)
eUTF8F :: Text -> Prim
eCharF :: Char -> Prim
eNaturalF :: Natural -> Prim
eIntegerF :: Integer -> Prim
eInt64F :: Int64 -> Prim
eInt32F :: Int32 -> Prim
eIntF :: Int -> Prim
eInt16F :: Int16 -> Prim
eInt8F :: Int8 -> Prim
eWordF :: Word -> Prim
eWord64F :: Word64 -> Prim
eWord32F :: Word32 -> Prim
eWord16F :: Word16 -> Prim
eBytesF :: ByteString -> Prim

-- | Encode a Lazy ByteString
eLazyBytesF :: ByteString -> Prim
eShortBytesF :: ShortByteString -> Prim
eWord8F :: Word8 -> Prim
eFillerF :: Prim
eBoolF :: Bool -> Prim
eTrueF :: Prim
eFalseF :: Prim
varWordF :: (Bits t, Integral t) => t -> Prim
w7l :: (Bits t, Integral t) => t -> [Word8]
eWord32BEF :: Word32 -> Prim
eWord64BEF :: Word64 -> Prim
eWord32E :: (Word32 -> Word32) -> Word32 -> Prim
eWord64E :: (Word64 -> Word64) -> Word64 -> Prim


-- | Primitives to calculate the encoding size of a value
module Flat.Encoder.Size
sFillerMax :: NumBits
sBool :: NumBits
sWord8 :: NumBits
sInt8 :: NumBits
sFloat :: NumBits
sDouble :: NumBits
sChar :: Char -> NumBits
sCharMax :: NumBits
sWord :: Word -> NumBits
sInt :: Int -> NumBits
sInt16 :: Int16 -> NumBits
sInt32 :: Int32 -> NumBits
sInt64 :: Int64 -> NumBits
sWord16 :: Word16 -> NumBits
sWord32 :: Word32 -> NumBits
sWord64 :: Word64 -> NumBits
sInteger :: Integer -> NumBits
sNatural :: Natural -> NumBits
sIntegral :: (Bits t, Integral t) => t -> Int
sUTF8Max :: Text -> NumBits
sUTF16 :: Text -> NumBits
sBytes :: ByteString -> NumBits
sLazyBytes :: ByteString -> NumBits
sShortBytes :: ShortByteString -> NumBits
textBytes :: Text -> Int
bitsToBytes :: Int -> Int
numBlks :: Integral t => t -> t -> t
arrayBits :: Int -> NumBits
arrayChunks :: Int -> NumBits
blobBits :: Int -> NumBits
blkBitsBS :: ByteString -> NumBits
blksBits :: Int -> NumBits


-- | Strict encoder
module Flat.Encoder.Strict

-- | Strict encoder
strictEncoder :: NumBits -> Encoding -> ByteString
newtype Encoding
Encoding :: Prim -> Encoding
[run] :: Encoding -> Prim
encodersS :: [Encoding] -> Encoding

-- | Encode as a List
encodeListWith :: (t -> Encoding) -> [t] -> Encoding

-- | Encode as Array
encodeArrayWith :: (t -> Encoding) -> [t] -> Encoding
eChar :: Char -> Encoding
eUTF16 :: Text -> Encoding
eUTF8 :: Text -> Encoding
eBytes :: ByteString -> Encoding
eLazyBytes :: ByteString -> Encoding
eShortBytes :: ShortByteString -> Encoding
eNatural :: Natural -> Encoding
eFloat :: Float -> Encoding
eDouble :: Double -> Encoding
eInteger :: Integer -> Encoding
eInt64 :: Int64 -> Encoding
eInt32 :: Int32 -> Encoding
eInt16 :: Int16 -> Encoding
eInt8 :: Int8 -> Encoding
eInt :: Int -> Encoding
eWord64 :: Word64 -> Encoding
eWord32 :: Word32 -> Encoding
eWord16 :: Word16 -> Encoding
eWord8 :: Word8 -> Encoding
eWord :: Word -> Encoding
eBits16 :: NumBits -> Word16 -> Encoding
eBits :: NumBits -> Word8 -> Encoding
eFiller :: Encoding
eBool :: Bool -> Encoding
eTrue :: Encoding
eFalse :: Encoding
vsize :: (t -> NumBits) -> t -> NumBits -> NumBits
csize :: NumBits -> t -> NumBits -> NumBits
sChar :: Size Char
sInt64 :: Size Int64
sInt32 :: Size Int32
sInt16 :: Size Int16
sInt8 :: Size Int8
sInt :: Size Int
sWord64 :: Size Word64
sWord32 :: Size Word32
sWord16 :: Size Word16
sWord8 :: Size Word8
sWord :: Size Word
sFloat :: Size Float
sDouble :: Size Double
sBytes :: Size ByteString
sLazyBytes :: Size ByteString
sShortBytes :: Size ShortByteString
sNatural :: Size Natural
sInteger :: Size Integer
sUTF8Max :: Size Text
sUTF16 :: Size Text
sFillerMax :: Size a
sBool :: Size Bool
instance GHC.Show.Show Flat.Encoder.Strict.Encoding
instance GHC.Base.Semigroup Flat.Encoder.Strict.Encoding
instance GHC.Base.Monoid Flat.Encoder.Strict.Encoding


-- | Encoder and encoding primitives
module Flat.Encoder
data Encoding

-- | An associative operation.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&gt; [4,5,6]
--   [1,2,3,4,5,6]
--   </pre>
(<>) :: Semigroup a => a -> a -> a
infixr 6 <>

-- | Number of bits
type NumBits = Int
encodersS :: [Encoding] -> Encoding

-- | Identity of <a>mappend</a>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello world" &lt;&gt; mempty
--   "Hello world"
--   </pre>
mempty :: Monoid a => a

-- | Strict encoder
strictEncoder :: NumBits -> Encoding -> ByteString
eTrueF :: Prim
eFalseF :: Prim
eFloat :: Float -> Encoding
eDouble :: Double -> Encoding
eInteger :: Integer -> Encoding
eNatural :: Natural -> Encoding
eWord16 :: Word16 -> Encoding
eWord32 :: Word32 -> Encoding
eWord64 :: Word64 -> Encoding
eWord8 :: Word8 -> Encoding
eBits :: NumBits -> Word8 -> Encoding
eBits16 :: NumBits -> Word16 -> Encoding
eFiller :: Encoding
eBool :: Bool -> Encoding
eTrue :: Encoding
eFalse :: Encoding
eBytes :: ByteString -> Encoding
eUTF16 :: Text -> Encoding
eLazyBytes :: ByteString -> Encoding
eShortBytes :: ShortByteString -> Encoding
eInt :: Int -> Encoding
eInt8 :: Int8 -> Encoding
eInt16 :: Int16 -> Encoding
eInt32 :: Int32 -> Encoding
eInt64 :: Int64 -> Encoding
eWord :: Word -> Encoding
eChar :: Char -> Encoding

-- | Encode as Array
encodeArrayWith :: (t -> Encoding) -> [t] -> Encoding

-- | Encode as a List
encodeListWith :: (t -> Encoding) -> [t] -> Encoding

-- | Calculate the size (in bits) of the encoding of a value
type Size a = a -> NumBits -> NumBits
arrayBits :: Int -> NumBits
sWord :: Size Word
sWord8 :: Size Word8
sWord16 :: Size Word16
sWord32 :: Size Word32
sWord64 :: Size Word64
sInt :: Size Int
sInt8 :: Size Int8
sInt16 :: Size Int16
sInt32 :: Size Int32
sInt64 :: Size Int64
sNatural :: Size Natural
sInteger :: Size Integer
sFloat :: Size Float
sDouble :: Size Double
sChar :: Size Char
sBytes :: Size ByteString
sLazyBytes :: Size ByteString
sShortBytes :: Size ShortByteString
sUTF16 :: Size Text
sFillerMax :: Size a
sBool :: Size Bool
sUTF8Max :: Size Text
eUTF8 :: Text -> Encoding


-- | Generics-based generation of Flat instances
module Flat.Class

-- | Class of types that can be encoded/decoded
class Flat a

-- | Return the encoding corrresponding to the value
encode :: Flat a => a -> Encoding

-- | Return the encoding corrresponding to the value
encode :: (Flat a, Generic a, GFlatEncode (Rep a)) => a -> Encoding

-- | Decode a value
decode :: Flat a => Get a

-- | Decode a value
decode :: (Flat a, Generic a, GFlatDecode (Rep a)) => Get a

-- | Add maximum size in bits of the value to the total count
--   
--   Used to calculated maximum buffer size before encoding
size :: Flat a => a -> NumBits -> NumBits

-- | Add maximum size in bits of the value to the total count
--   
--   Used to calculated maximum buffer size before encoding
size :: (Flat a, Generic a, GFlatSize (Rep a)) => a -> NumBits -> NumBits

-- | Calculate the maximum size in bits of the serialisation of the value
getSize :: Flat a => a -> NumBits

-- | Generic Encoder
class GFlatEncode f

-- | Generic Decoding
class GFlatDecode f

-- | Calculate the number of bits required for the serialisation of a value
--   Implemented as a function that adds the maximum size to a running
--   total
class GFlatSize f
instance (Flat.Class.NumConstructors (a GHC.Generics.:+: b) Data.Type.Ord.<= 512, Flat.Class.GFlatEncodeSum (a GHC.Generics.:+: b)) => Flat.Class.GFlatEncode (a GHC.Generics.:+: b)
instance (Flat.Class.NumConstructors (a GHC.Generics.:+: b) Data.Type.Ord.<= 512, Flat.Class.GFlatDecodeSum (a GHC.Generics.:+: b)) => Flat.Class.GFlatDecode (a GHC.Generics.:+: b)
instance Flat.Class.GFlatSizeSum (a GHC.Generics.:+: b) => Flat.Class.GFlatSize (a GHC.Generics.:+: b)
instance (Flat.Class.GFlatSizeSum a, Flat.Class.GFlatSizeSum b) => Flat.Class.GFlatSizeSum (a GHC.Generics.:+: b)
instance Flat.Class.GFlatSize a => Flat.Class.GFlatSizeSum (GHC.Generics.C1 c a)
instance Flat.Class.Flat a => Flat.Class.GFlatEncode (GHC.Generics.K1 i a)
instance Flat.Class.Flat a => Flat.Class.GFlatDecode (GHC.Generics.K1 i a)
instance Flat.Class.Flat a => Flat.Class.GFlatSize (GHC.Generics.K1 i a)
instance Flat.Class.GFlatSize f => Flat.Class.GFlatSize (GHC.Generics.M1 i c f)
instance Flat.Class.GFlatSize GHC.Generics.V1
instance Flat.Class.GFlatSize GHC.Generics.U1
instance (Flat.Class.GFlatSize a, Flat.Class.GFlatSize b) => Flat.Class.GFlatSize (a GHC.Generics.:*: b)
instance (Flat.Class.GFlatDecodeSum n1, Flat.Class.GFlatDecodeSum n2, Flat.Class.GFlatDecodeSum n3, Flat.Class.GFlatDecodeSum n4) => Flat.Class.GFlatDecodeSum ((n1 GHC.Generics.:+: n2) GHC.Generics.:+: (n3 GHC.Generics.:+: n4))
instance (Flat.Class.GFlatDecodeSum n1, Flat.Class.GFlatDecodeSum n2, Flat.Class.GFlatDecodeSum n3, Flat.Class.GFlatDecodeSum n4, Flat.Class.GFlatDecodeSum n5, Flat.Class.GFlatDecodeSum n6, Flat.Class.GFlatDecodeSum n7, Flat.Class.GFlatDecodeSum n8) => Flat.Class.GFlatDecodeSum (((n1 GHC.Generics.:+: n2) GHC.Generics.:+: (n3 GHC.Generics.:+: n4)) GHC.Generics.:+: ((n5 GHC.Generics.:+: n6) GHC.Generics.:+: (n7 GHC.Generics.:+: n8)))
instance (Flat.Class.GFlatDecodeSum a, Flat.Class.GFlatDecodeSum b) => Flat.Class.GFlatDecodeSum (a GHC.Generics.:+: b)
instance Flat.Class.GFlatDecode a => Flat.Class.GFlatDecodeSum (GHC.Generics.C1 c a)
instance Flat.Class.GFlatDecode a => Flat.Class.GFlatDecode (GHC.Generics.M1 i c a)
instance Flat.Class.GFlatDecode GHC.Generics.V1
instance Flat.Class.GFlatDecode GHC.Generics.U1
instance (Flat.Class.GFlatDecode a, Flat.Class.GFlatDecode b) => Flat.Class.GFlatDecode (a GHC.Generics.:*: b)
instance (Flat.Class.GFlatDecode a, Flat.Class.GFlatDecode b) => Flat.Class.GFlatDecode (GHC.Generics.C1 m1 a GHC.Generics.:+: GHC.Generics.C1 m2 b)
instance (Flat.Class.GFlatEncodeSum a, Flat.Class.GFlatEncodeSum b) => Flat.Class.GFlatEncodeSum (a GHC.Generics.:+: b)
instance Flat.Class.GFlatEncode a => Flat.Class.GFlatEncodeSum (GHC.Generics.C1 c a)
instance Flat.Class.GFlatEncode f => Flat.Class.GFlatEncode (GHC.Generics.M1 i c f)
instance Flat.Class.GFlatEncode a => Flat.Class.GFlatEncode (GHC.Generics.D1 i (GHC.Generics.C1 c a))
instance Flat.Class.GFlatEncode GHC.Generics.V1
instance Flat.Class.GFlatEncode GHC.Generics.U1
instance (Flat.Class.GFlatEncode a, Flat.Class.GFlatEncode b) => Flat.Class.GFlatEncode (a GHC.Generics.:*: b)

module Flat.Instances.Util
encodeArray :: Flat a => [a] -> Encoding


-- | Flat instances for the text library
module Flat.Instances.Text

-- | The desired text encoding can be explicitly specified using the
--   wrappers UTF8Text and UTF16Text.
--   
--   The default encoding is UTF8:
--   
--   <pre>
--   &gt;&gt;&gt; tst (UTF8Text $ T.pack "日日日") == tst (T.pack "日日日")
--   True
--   </pre>
--   
--   A wrapper to encode/decode Text as UTF8 (slower but more compact)
newtype UTF8Text
UTF8Text :: Text -> UTF8Text
[unUTF8] :: UTF8Text -> Text

-- | <pre>
--   &gt;&gt;&gt; tst (UTF16Text $ T.pack "aaa")
--   (True,72,[1,6,97,0,97,0,97,0,0])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tst (UTF16Text $ T.pack "𐍈𐍈𐍈")
--   (True,120,[1,12,0,216,72,223,0,216,72,223,0,216,72,223,0])
--   </pre>
--   
--   A wrapper to encode/decode Text as UTF16 (faster but bigger)
newtype UTF16Text
UTF16Text :: Text -> UTF16Text
[unUTF16] :: UTF16Text -> Text
instance GHC.Show.Show Flat.Instances.Text.UTF8Text
instance GHC.Classes.Ord Flat.Instances.Text.UTF8Text
instance GHC.Classes.Eq Flat.Instances.Text.UTF8Text
instance GHC.Show.Show Flat.Instances.Text.UTF16Text
instance GHC.Classes.Ord Flat.Instances.Text.UTF16Text
instance GHC.Classes.Eq Flat.Instances.Text.UTF16Text
instance Flat.Class.Flat Flat.Instances.Text.UTF16Text
instance Flat.Class.Flat Flat.Instances.Text.UTF8Text
instance Flat.Class.Flat Data.Text.Internal.Text
instance Flat.Class.Flat Data.Text.Internal.Lazy.Text

module Flat.Instances.Mono

-- | Calculate size of an instance of IsSequence as the sum: * of the size
--   of all the elements * plus the size of the array constructors (1 byte
--   every 255 elements plus one final byte)
sizeSequence :: (IsSequence mono, Flat (Element mono)) => mono -> NumBits -> NumBits

-- | Encode an instance of IsSequence, as an array
encodeSequence :: (Flat (Element mono), MonoFoldable mono) => mono -> Encoding

-- | Decode an instance of IsSequence, as an array
decodeSequence :: (Flat (Element b), IsSequence b) => Get b
sizeList :: (MonoFoldable mono, Flat (Element mono)) => mono -> NumBits -> NumBits
encodeList :: (Flat (Element mono), MonoFoldable mono) => mono -> Encoding
decodeList :: (IsSequence b, Flat (Element b)) => Get b
sizeSet :: (IsSet set, Flat (Element set)) => Size set
encodeSet :: (IsSet set, Flat (Element set)) => set -> Encoding
decodeSet :: (IsSet set, Flat (Element set)) => Get set
sizeMap :: (Flat (ContainerKey r), Flat (MapValue r), IsMap r) => Size r

-- | Encode an instance of IsMap, as a list of (Key,Value) tuples
encodeMap :: (Flat (ContainerKey map), Flat (MapValue map), IsMap map) => map -> Encoding

-- | Decode an instance of IsMap, as a list of (Key,Value) tuples
decodeMap :: (Flat (ContainerKey map), Flat (MapValue map), IsMap map) => Get map

-- | Sequences are defined as Arrays:
--   
--   Array v = A0 | A1 v (Array v) | A2 v v (Array v) ... | A255 ... (Array
--   v)
--   
--   In practice, this means that the sequence is encoded as a sequence of
--   blocks of up to 255 elements, with every block preceded by the count
--   of the elements in the block and a final 0-length block.
--   
--   Lists are defined as:
--   
--   List a ≡ Nil | Cons a (List a)
--   
--   The AsList/AsArray wrappers can be used to serialise sequences as
--   Lists or Arrays
--   
--   <pre>
--   &gt;&gt;&gt; tst $ AsArray ([]::[()])
--   (True,8,[0])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tst $ AsArray [11::Word8,22,33]
--   (True,40,[3,11,22,33,0])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tst $ AsList ([]::[()])
--   (True,1,[0])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tst (AsList [11::Word8,22,33])
--   (True,28,[133,197,164,32])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tst (AsSet (Data.Set.fromList [11::Word8,22,33]))
--   (True,28,[133,197,164,32])
--   </pre>
newtype AsArray a
AsArray :: a -> AsArray a
[unArray] :: AsArray a -> a
newtype AsList a
AsList :: a -> AsList a
[unList] :: AsList a -> a
newtype AsSet a
AsSet :: a -> AsSet a
[unSet] :: AsSet a -> a

-- | Maps are saved as lists of (key,value) tuples.
--   
--   <pre>
--   &gt;&gt;&gt; tst (AsMap (Data.Map.fromList ([]::[(Word8,())])))
--   (True,1,[0])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tst (AsMap (Data.Map.fromList [(3::Word,9::Word)]))
--   (True,18,[129,132,128])
--   </pre>
newtype AsMap a
AsMap :: a -> AsMap a
[unMap] :: AsMap a -> a
instance GHC.Classes.Ord a => GHC.Classes.Ord (Flat.Instances.Mono.AsArray a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Flat.Instances.Mono.AsArray a)
instance GHC.Show.Show a => GHC.Show.Show (Flat.Instances.Mono.AsArray a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Flat.Instances.Mono.AsList a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Flat.Instances.Mono.AsList a)
instance GHC.Show.Show a => GHC.Show.Show (Flat.Instances.Mono.AsList a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Flat.Instances.Mono.AsSet a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Flat.Instances.Mono.AsSet a)
instance GHC.Show.Show a => GHC.Show.Show (Flat.Instances.Mono.AsSet a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Flat.Instances.Mono.AsMap a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Flat.Instances.Mono.AsMap a)
instance GHC.Show.Show a => GHC.Show.Show (Flat.Instances.Mono.AsMap a)
instance (Data.Containers.IsMap map, Flat.Class.Flat (Data.Containers.ContainerKey map), Flat.Class.Flat (Data.Containers.MapValue map)) => Flat.Class.Flat (Flat.Instances.Mono.AsMap map)
instance (Data.Containers.IsSet set, Flat.Class.Flat (Data.MonoTraversable.Element set)) => Flat.Class.Flat (Flat.Instances.Mono.AsSet set)
instance (Data.Sequences.IsSequence l, Flat.Class.Flat (Data.MonoTraversable.Element l)) => Flat.Class.Flat (Flat.Instances.Mono.AsList l)
instance (Data.Sequences.IsSequence r, Flat.Class.Flat (Data.MonoTraversable.Element r)) => Flat.Class.Flat (Flat.Instances.Mono.AsArray r)


-- | Flat instances for the vector package.
module Flat.Instances.Vector
instance Flat.Class.Flat a => Flat.Class.Flat (Data.Vector.Vector a)
instance (Data.Vector.Unboxed.Base.Unbox a, Flat.Class.Flat a) => Flat.Class.Flat (Data.Vector.Unboxed.Base.Vector a)
instance (Foreign.Storable.Storable a, Flat.Class.Flat a) => Flat.Class.Flat (Data.Vector.Storable.Vector a)

module Flat.Instances.Unordered
instance (Data.Hashable.Class.Hashable a, GHC.Classes.Eq a, Flat.Class.Flat a) => Flat.Class.Flat (Data.HashSet.Internal.HashSet a)
instance (Data.Hashable.Class.Hashable k, GHC.Classes.Eq k, Flat.Class.Flat k, Flat.Class.Flat v) => Flat.Class.Flat (Data.HashMap.Internal.HashMap k v)


-- | Flat instances for the base library
module Flat.Instances.Base
instance Flat.Class.Flat a => Flat.Class.Flat (Data.Functor.Identity.Identity a)
instance Flat.Class.Flat a => Flat.Class.Flat (Data.Semigroup.Internal.Dual a)
instance Flat.Class.Flat Data.Semigroup.Internal.All
instance Flat.Class.Flat Data.Semigroup.Internal.Any
instance Flat.Class.Flat a => Flat.Class.Flat (Data.Semigroup.Internal.Sum a)
instance Flat.Class.Flat a => Flat.Class.Flat (Data.Semigroup.Internal.Product a)
instance Flat.Class.Flat (f a) => Flat.Class.Flat (Data.Semigroup.Internal.Alt f a)
instance Flat.Class.Flat a => Flat.Class.Flat (Data.Semigroup.Min a)
instance Flat.Class.Flat a => Flat.Class.Flat (Data.Semigroup.Max a)
instance Flat.Class.Flat a => Flat.Class.Flat (Data.Semigroup.First a)
instance Flat.Class.Flat a => Flat.Class.Flat (Data.Semigroup.Last a)
instance Flat.Class.Flat ()
instance Flat.Class.Flat GHC.Types.Bool
instance Flat.Class.Flat GHC.Types.Char
instance Flat.Class.Flat a => Flat.Class.Flat (GHC.Maybe.Maybe a)
instance (Flat.Class.Flat a, Flat.Class.Flat b) => Flat.Class.Flat (Data.Either.Either a b)
instance Flat.Class.Flat (Data.Fixed.Fixed a)
instance Flat.Class.Flat GHC.Word.Word8
instance Flat.Class.Flat GHC.Types.Word
instance Flat.Class.Flat GHC.Num.Natural.Natural
instance Flat.Class.Flat GHC.Word.Word16
instance Flat.Class.Flat GHC.Word.Word32
instance Flat.Class.Flat GHC.Word.Word64
instance Flat.Class.Flat GHC.Types.Int
instance Flat.Class.Flat GHC.Num.Integer.Integer
instance Flat.Class.Flat GHC.Int.Int8
instance Flat.Class.Flat GHC.Int.Int16
instance Flat.Class.Flat GHC.Int.Int32
instance Flat.Class.Flat GHC.Int.Int64
instance Flat.Class.Flat GHC.Types.Float
instance Flat.Class.Flat GHC.Types.Double
instance Flat.Class.Flat a => Flat.Class.Flat (Data.Complex.Complex a)
instance (GHC.Real.Integral a, Flat.Class.Flat a) => Flat.Class.Flat (GHC.Real.Ratio a)
instance Flat.Class.Flat a => Flat.Class.Flat [a]
instance Flat.Class.Flat a => Flat.Class.Flat (GHC.Base.NonEmpty a)
instance (Flat.Class.Flat a, Flat.Class.Flat b) => Flat.Class.Flat (a, b)
instance (Flat.Class.Flat a, Flat.Class.Flat b, Flat.Class.Flat c) => Flat.Class.Flat (a, b, c)
instance (Flat.Class.Flat a, Flat.Class.Flat b, Flat.Class.Flat c, Flat.Class.Flat d) => Flat.Class.Flat (a, b, c, d)
instance (Flat.Class.Flat a, Flat.Class.Flat b, Flat.Class.Flat c, Flat.Class.Flat d, Flat.Class.Flat e) => Flat.Class.Flat (a, b, c, d, e)
instance (Flat.Class.Flat a, Flat.Class.Flat b, Flat.Class.Flat c, Flat.Class.Flat d, Flat.Class.Flat e, Flat.Class.Flat f) => Flat.Class.Flat (a, b, c, d, e, f)
instance (Flat.Class.Flat a, Flat.Class.Flat b, Flat.Class.Flat c, Flat.Class.Flat d, Flat.Class.Flat e, Flat.Class.Flat f, Flat.Class.Flat g) => Flat.Class.Flat (a, b, c, d, e, f, g)


-- | Instances for the containers library
module Flat.Instances.Containers
sizeMap :: (Flat (ContainerKey r), Flat (MapValue r), IsMap r) => Size r

-- | Encode an instance of IsMap, as a list of (Key,Value) tuples
encodeMap :: (Flat (ContainerKey map), Flat (MapValue map), IsMap map) => map -> Encoding

-- | Decode an instance of IsMap, as a list of (Key,Value) tuples
decodeMap :: (Flat (ContainerKey map), Flat (MapValue map), IsMap map) => Get map
instance Flat.Class.Flat a => Flat.Class.Flat (Data.IntMap.Internal.IntMap a)
instance (Flat.Class.Flat a, Flat.Class.Flat b, GHC.Classes.Ord a) => Flat.Class.Flat (Data.Map.Internal.Map a b)
instance Flat.Class.Flat a => Flat.Class.Flat (Data.Sequence.Internal.Seq a)
instance (Flat.Class.Flat a, GHC.Classes.Ord a) => Flat.Class.Flat (Data.Set.Internal.Set a)
instance Flat.Class.Flat a => Flat.Class.Flat (Data.Tree.Tree a)

module Flat.Instances.DList
instance Flat.Class.Flat a => Flat.Class.Flat (Data.DList.Internal.DList a)


-- | Flat instances for the bytestring library
module Flat.Instances.ByteString
instance Flat.Class.Flat Data.ByteString.Internal.ByteString
instance Flat.Class.Flat Data.ByteString.Lazy.Internal.ByteString
instance Flat.Class.Flat Data.ByteString.Short.Internal.ShortByteString


-- | Flat instances for the <a>array</a> package
module Flat.Instances.Array
instance (Flat.Class.Flat i, Flat.Class.Flat e, GHC.Ix.Ix i) => Flat.Class.Flat (GHC.Arr.Array i e)
instance (Flat.Class.Flat i, Flat.Class.Flat e, GHC.Ix.Ix i, Data.Array.Base.IArray Data.Array.Base.UArray e) => Flat.Class.Flat (Data.Array.Base.UArray i e)


-- | Flat Instances for common data types from the packages on which
--   <tt>flat</tt> has a dependency.
module Flat.Instances


-- | Pre-value and post-value byte alignments
module Flat.Filler

-- | A meaningless sequence of 0 bits terminated with a 1 bit (easier to
--   implement than the reverse) Useful to align an encoded value at
--   byte/word boundaries.
data Filler
FillerBit :: Filler -> Filler
FillerEnd :: Filler

-- | Length of a filler in bits
fillerLength :: Num a => Filler -> a

-- | A Pre aligned value, a value preceded by a filler Useful to prealign
--   ByteArrays, Texts and any structure that can be encoded more
--   efficiently when byte aligned.
data PreAligned a
PreAligned :: Filler -> a -> PreAligned a
[preFiller] :: PreAligned a -> Filler
[preValue] :: PreAligned a -> a

-- | Pre align a value
preAligned :: a -> PreAligned a

-- | A Post aligned value, a value followed by a filler Useful to complete
--   the encoding of a top-level value
data PostAligned a
PostAligned :: a -> Filler -> PostAligned a
[postValue] :: PostAligned a -> a
[postFiller] :: PostAligned a -> Filler

-- | Post align a value
postAligned :: a -> PostAligned a
preAlignedDecoder :: Get b -> Get b

-- | Decode a value assuming that is PostAligned
postAlignedDecoder :: Get b -> Get b
instance Control.DeepSeq.NFData Flat.Filler.Filler
instance GHC.Generics.Generic Flat.Filler.Filler
instance GHC.Classes.Ord Flat.Filler.Filler
instance GHC.Classes.Eq Flat.Filler.Filler
instance GHC.Show.Show Flat.Filler.Filler
instance Flat.Class.Flat a => Flat.Class.Flat (Flat.Filler.PostAligned a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Flat.Filler.PostAligned a)
instance GHC.Generics.Generic (Flat.Filler.PostAligned a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Flat.Filler.PostAligned a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Flat.Filler.PostAligned a)
instance GHC.Show.Show a => GHC.Show.Show (Flat.Filler.PostAligned a)
instance Flat.Class.Flat a => Flat.Class.Flat (Flat.Filler.PreAligned a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Flat.Filler.PreAligned a)
instance GHC.Generics.Generic (Flat.Filler.PreAligned a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Flat.Filler.PreAligned a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Flat.Filler.PreAligned a)
instance GHC.Show.Show a => GHC.Show.Show (Flat.Filler.PreAligned a)
instance Flat.Class.Flat Flat.Filler.Filler


-- | Encoding and decoding functions
module Flat.Run

-- | Encode padded value.
flat :: Flat a => a -> ByteString

-- | Encode unpadded value
flatRaw :: (Flat a, AsByteString b) => a -> b

-- | Decode padded value.
unflat :: (Flat a, AsByteString b) => b -> Decoded a

-- | Decode padded value, using the provided unpadded decoder.
unflatWith :: AsByteString b => Get a -> b -> Decoded a

-- | Decode unpadded value.
unflatRaw :: (Flat a, AsByteString b) => b -> Decoded a

-- | Unflat unpadded value, using provided decoder
unflatRawWith :: AsByteString b => Get a -> b -> Decoded a

module Flat.Repr
newtype Repr a
Repr :: ByteString -> Repr a
[repr] :: Repr a -> ByteString
unrepr :: Flat a => Repr a -> a
instance Flat.Class.Flat a => Flat.Class.Flat (Flat.Repr.Repr a)


-- | Utilities to represent and display bit sequences
module Flat.Bits

-- | A sequence of bits
type Bits = Vector Bool
toBools :: Bits -> [Bool]
fromBools :: [Bool] -> Bits

-- | The sequence of bits corresponding to the serialization of the passed
--   value (without any final byte padding)
--   
--   <pre>
--   &gt;&gt;&gt; bits True
--   [True]
--   </pre>
bits :: forall a. Flat a => a -> Bits

-- | The sequence of bits corresponding to the byte-padded serialization of
--   the passed value
--   
--   <pre>
--   &gt;&gt;&gt; paddedBits True
--   [True,False,False,False,False,False,False,True]
--   </pre>
paddedBits :: forall a. Flat a => a -> Bits

-- | Convert a sequence of bits to the corresponding list of bytes
--   
--   <pre>
--   &gt;&gt;&gt; asBytes $ asBits (256+3::Word16)
--   [1,3]
--   </pre>
asBytes :: Bits -> [Word8]

-- | Convert an integral value to its equivalent bit representation
--   
--   <pre>
--   &gt;&gt;&gt; asBits (5::Word8)
--   [False,False,False,False,False,True,False,True]
--   </pre>
asBits :: FiniteBits a => a -> Bits
instance Text.PrettyPrint.HughesPJClass.Pretty Flat.Bits.Bits


-- | doctest utilities
module Flat.Instances.Test

-- | Returns: result of flat/unflat test, encoding size in bits, byte
--   encoding
tst :: (Eq a, Flat a) => a -> (Bool, NumBits, [Word8])

-- | Returns: result of flat/unflat test, encoding size in bits, bits
--   encoding
tstBits :: (Eq a, Flat a) => a -> (Bool, NumBits, String)

-- | Test that container is serialised as a List
asList :: (Eq a1, Eq a2, Flat a1, Flat a2) => (a2 -> a1) -> a2 -> Bool
flatBits :: Flat a => a -> String
allBits :: Flat a => a -> String

-- | Pretty print a value with the <a>prettyNormal</a> level.
prettyShow :: Pretty a => a -> String


-- | Haskell implementation of <a>Flat</a>, a principled, portable and
--   efficient binary data format.
module Flat

-- | A decoded value
type Decoded a = Either DecodeException a

-- | An exception during decoding
data DecodeException
NotEnoughSpace :: Env -> DecodeException
TooMuchSpace :: Env -> DecodeException
BadEncoding :: Env -> String -> DecodeException
