

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>8. Profiling &mdash; Glasgow Haskell Compiler 9.2.5 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML "></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.5 User&#39;s Guide"
          href="_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="9. Debugging compiled programs" href="debug-info.html" />
    <link rel="prev" title="7. Extending and using GHC as a Library" href="extending_ghc.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="runghc.html">4. Using runghc</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">5. Using GHC</a></li>
<li class="toctree-l1"><a class="reference internal" href="exts.html">6. Language extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">8. Profiling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#cost-centres-and-cost-centre-stacks">8.1. Cost centres and cost-centre stacks</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#inserting-cost-centres-by-hand">8.1.1. Inserting cost centres by hand</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rules-for-attributing-costs">8.1.2. Rules for attributing costs</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#compiler-options-for-profiling">8.2. Compiler options for profiling</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#automatically-placing-cost-centres">8.2.1. Automatically placing cost-centres</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#time-and-allocation-profiling">8.3. Time and allocation profiling</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#json-profile-format">8.3.1. JSON profile format</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#profiling-memory-usage">8.4. Profiling memory usage</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#rts-options-for-heap-profiling">8.4.1. RTS options for heap profiling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#retainer-profiling">8.4.2. Retainer Profiling</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#hints-for-using-retainer-profiling">8.4.2.1. Hints for using retainer profiling</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#biographical-profiling">8.4.3. Biographical Profiling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#actual-memory-residency">8.4.4. Actual memory residency</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#hp2ps-rendering-heap-profiles-to-postscript">8.5. <code class="docutils literal notranslate"><span class="pre">hp2ps</span></code> – Rendering heap profiles to PostScript</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#manipulating-the-hp-file">8.5.1. Manipulating the <code class="docutils literal notranslate"><span class="pre">hp</span></code> file</a></li>
<li class="toctree-l3"><a class="reference internal" href="#zooming-in-on-regions-of-your-profile">8.5.2. Zooming in on regions of your profile</a></li>
<li class="toctree-l3"><a class="reference internal" href="#viewing-the-heap-profile-of-a-running-program">8.5.3. Viewing the heap profile of a running program</a></li>
<li class="toctree-l3"><a class="reference internal" href="#viewing-a-heap-profile-in-real-time">8.5.4. Viewing a heap profile in real time</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#profiling-parallel-and-concurrent-programs">8.6. Profiling Parallel and Concurrent Programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="#observing-code-coverage">8.7. Observing Code Coverage</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#a-small-example-reciprocation">8.7.1. A small example: Reciprocation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#options-for-instrumenting-code-for-coverage">8.7.2. Options for instrumenting code for coverage</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-hpc-toolkit">8.7.3. The hpc toolkit</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#hpc-report">8.7.3.1. hpc report</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hpc-markup">8.7.3.2. hpc markup</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hpc-sum">8.7.3.3. hpc sum</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hpc-combine">8.7.3.4. hpc combine</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hpc-map">8.7.3.5. hpc map</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hpc-overlay-and-hpc-draft">8.7.3.6. hpc overlay and hpc draft</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#caveats-and-shortcomings-of-haskell-program-coverage">8.7.4. Caveats and Shortcomings of Haskell Program Coverage</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#using-ticky-ticky-profiling-for-implementors">8.8. Using “ticky-ticky” profiling (for implementors)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li><span class="section-number">8. </span>Profiling</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/profiling.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="profiling">
<span id="id1"></span><h1><span class="section-number">8. </span>Profiling<a class="headerlink" href="#profiling" title="Permalink to this heading">¶</a></h1>
<p id="index-0">GHC comes with a time and space profiling system, so that you can answer
questions like “why is my program so slow?”, or “why is my program using
so much memory?”.</p>
<p>Profiling a program is a three-step process:</p>
<ol class="arabic">
<li><p>Re-compile your program for profiling with the <a class="reference internal" href="#ghc-flag-prof"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-prof</span></code></a> option, and
probably one of the options for adding automatic annotations:
<a class="reference internal" href="#ghc-flag-fprof-auto"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fprof-auto</span></code></a> is the most common <a class="footnote-reference brackets" href="#id5" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>.</p>
<p>If you are using external packages with <strong class="command">cabal</strong>, you may need to
reinstall these packages with profiling support; typically this is
done with <code class="docutils literal notranslate"><span class="pre">cabal</span> <span class="pre">install</span> <span class="pre">-p</span> <span class="pre">package</span> <span class="pre">--reinstall</span></code>.</p>
</li>
<li><p>Having compiled the program for profiling, you now need to run it to
generate the profile. For example, a simple time profile can be
generated by running the program with <code class="docutils literal notranslate"><span class="pre">+RTS</span> <span class="pre">-p</span></code> (see <a class="reference internal" href="#rts-flag-p"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-p</span></code></a>), which
generates a file named <code class="file docutils literal notranslate"><em><span class="pre">prog</span></em><span class="pre">.prof</span></code> where ⟨prog⟩ is the name of your
program (without the <code class="docutils literal notranslate"><span class="pre">.exe</span></code> extension, if you are on Windows).</p>
<p>There are many different kinds of profile that can be generated,
selected by different RTS options. We will be describing the various
kinds of profile throughout the rest of this chapter. Some profiles
require further processing using additional tools after running the
program.</p>
</li>
<li><p>Examine the generated profiling information, use the information to
optimise your program, and repeat as necessary.</p></li>
</ol>
<section id="cost-centres-and-cost-centre-stacks">
<span id="cost-centres"></span><h2><span class="section-number">8.1. </span>Cost centres and cost-centre stacks<a class="headerlink" href="#cost-centres-and-cost-centre-stacks" title="Permalink to this heading">¶</a></h2>
<p>GHC’s profiling system assigns costs to cost centres. A cost is simply
the time or space (memory) required to evaluate an expression. Cost
centres are program annotations around expressions; all costs incurred
by the annotated expression are assigned to the enclosing cost centre.
Furthermore, GHC will remember the stack of enclosing cost centres for
any given expression at run-time and generate a call-tree of cost
attributions.</p>
<p>Let’s take a look at an example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">main</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">print</span><span class="w"> </span><span class="p">(</span><span class="n">fib</span><span class="w"> </span><span class="mi">30</span><span class="p">)</span><span class="w"></span>
<span class="nf">fib</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Compile and run this program as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ghc -prof -fprof-auto -rtsopts Main.hs
$ ./Main +RTS -p
121393
$
</pre></div>
</div>
<p>When a GHC-compiled program is run with the <a class="reference internal" href="#rts-flag-p"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-p</span></code></a> RTS option, it
generates a file called <code class="file docutils literal notranslate"><span class="pre">prog.prof</span></code>. In this case, the file will contain
something like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>        Wed Oct 12 16:14 2011 Time and Allocation Profiling Report  (Final)

           Main +RTS -p -RTS

        total time  =        0.68 secs   (34 ticks @ 20 ms)
        total alloc = 204,677,844 bytes  (excludes profiling overheads)

COST CENTRE MODULE  %time %alloc

fib         Main    100.0  100.0


                                                      individual     inherited
COST CENTRE MODULE                  no.     entries  %time %alloc   %time %alloc

MAIN        MAIN                    102           0    0.0    0.0   100.0  100.0
 CAF        GHC.IO.Handle.FD        128           0    0.0    0.0     0.0    0.0
 CAF        GHC.IO.Encoding.Iconv   120           0    0.0    0.0     0.0    0.0
 CAF        GHC.Conc.Signal         110           0    0.0    0.0     0.0    0.0
 CAF        Main                    108           0    0.0    0.0   100.0  100.0
  main      Main                    204           1    0.0    0.0   100.0  100.0
   fib      Main                    205     2692537  100.0  100.0   100.0  100.0
</pre></div>
</div>
<p>The first part of the file gives the program name and options, and the
total time and total memory allocation measured during the run of the
program (note that the total memory allocation figure isn’t the same as
the amount of <em>live</em> memory needed by the program at any one time; the
latter can be determined using heap profiling, which we will describe
later in <a class="reference internal" href="#prof-heap"><span class="std std-ref">Profiling memory usage</span></a>).</p>
<p>The second part of the file is a break-down by cost centre of the most
costly functions in the program. In this case, there was only one
significant function in the program, namely <code class="docutils literal notranslate"><span class="pre">fib</span></code>, and it was
responsible for 100% of both the time and allocation costs of the
program.</p>
<p>The third and final section of the file gives a profile break-down by
cost-centre stack. This is roughly a call-tree profile of the program.
In the example above, it is clear that the costly call to <code class="docutils literal notranslate"><span class="pre">fib</span></code> came
from <code class="docutils literal notranslate"><span class="pre">main</span></code>.</p>
<p>The time and allocation incurred by a given part of the program is
displayed in two ways: “individual”, which are the costs incurred by the
code covered by this cost centre stack alone, and “inherited”, which
includes the costs incurred by all the children of this node.</p>
<p>The usefulness of cost-centre stacks is better demonstrated by modifying
the example slightly:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">main</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">print</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="mi">30</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="mi">30</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="n">f</span><span class="w"> </span><span class="n">n</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="n">n</span><span class="w"></span>
<span class="w">    </span><span class="n">g</span><span class="w"> </span><span class="n">n</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="p">`</span><span class="n">div</span><span class="p">`</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"></span>

<span class="nf">fib</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Compile and run this program as before, and take a look at the new
profiling results:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>COST CENTRE MODULE                  no.     entries  %time %alloc   %time %alloc

MAIN        MAIN                    102           0    0.0    0.0   100.0  100.0
 CAF        GHC.IO.Handle.FD        128           0    0.0    0.0     0.0    0.0
 CAF        GHC.IO.Encoding.Iconv   120           0    0.0    0.0     0.0    0.0
 CAF        GHC.Conc.Signal         110           0    0.0    0.0     0.0    0.0
 CAF        Main                    108           0    0.0    0.0   100.0  100.0
  main      Main                    204           1    0.0    0.0   100.0  100.0
   main.g   Main                    207           1    0.0    0.0     0.0    0.1
    fib     Main                    208        1973    0.0    0.1     0.0    0.1
   main.f   Main                    205           1    0.0    0.0   100.0   99.9
    fib     Main                    206     2692537  100.0   99.9   100.0   99.9
</pre></div>
</div>
<p>Now although we had two calls to <code class="docutils literal notranslate"><span class="pre">fib</span></code> in the program, it is
immediately clear that it was the call from <code class="docutils literal notranslate"><span class="pre">f</span></code> which took all the
time. The functions <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code> which are defined in the <code class="docutils literal notranslate"><span class="pre">where</span></code>
clause in <code class="docutils literal notranslate"><span class="pre">main</span></code> are given their own cost centres, <code class="docutils literal notranslate"><span class="pre">main.f</span></code> and
<code class="docutils literal notranslate"><span class="pre">main.g</span></code> respectively.</p>
<p>The actual meaning of the various columns in the output is:</p>
<blockquote>
<div><p>The number of times this particular point in the call tree was
entered.</p>
<p>The percentage of the total run time of the program spent at this
point in the call tree.</p>
<p>The percentage of the total memory allocations (excluding profiling
overheads) of the program made by this call.</p>
<p>The percentage of the total run time of the program spent below this
point in the call tree.</p>
<p>The percentage of the total memory allocations (excluding profiling
overheads) of the program made by this call and all of its
sub-calls.</p>
</div></blockquote>
<p>In addition you can use the <a class="reference internal" href="#rts-flag-P"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-P</span></code></a> RTS option to get the
following additional information:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ticks</span></code></dt><dd><p>The raw number of time “ticks” which were attributed to this
cost-centre; from this, we get the <code class="docutils literal notranslate"><span class="pre">%time</span></code> figure mentioned above.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bytes</span></code></dt><dd><p>Number of bytes allocated in the heap while in this cost-centre;
again, this is the raw number from which we get the <code class="docutils literal notranslate"><span class="pre">%alloc</span></code>
figure mentioned above.</p>
</dd>
</dl>
<p>What about recursive functions, and mutually recursive groups of
functions? Where are the costs attributed? Well, although GHC does keep
information about which groups of functions called each other
recursively, this information isn’t displayed in the basic time and
allocation profile, instead the call-graph is flattened into a tree as
follows: a call to a function that occurs elsewhere on the current stack
does not push another entry on the stack, instead the costs for this
call are aggregated into the caller <a class="footnote-reference brackets" href="#id6" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>.</p>
<section id="inserting-cost-centres-by-hand">
<span id="scc-pragma"></span><h3><span class="section-number">8.1.1. </span>Inserting cost centres by hand<a class="headerlink" href="#inserting-cost-centres-by-hand" title="Permalink to this heading">¶</a></h3>
<p>Cost centres are just program annotations. When you say <code class="docutils literal notranslate"><span class="pre">-fprof-auto</span></code>
to the compiler, it automatically inserts a cost centre annotation
around every binding not marked INLINE in your program, but you are
entirely free to add cost centre annotations yourself.</p>
<p>The syntax of a cost centre annotation for expressions is</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# SCC &quot;name&quot; #-}</span><span class="w"> </span><span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span><span class="w"></span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">&quot;name&quot;</span></code> is an arbitrary string, that will become the name of
your cost centre as it appears in the profiling output, and
<code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span></code> is any Haskell expression. An <code class="docutils literal notranslate"><span class="pre">SCC</span></code> annotation extends as
far to the right as possible when parsing, having the same precedence as lambda
abstractions, let expressions, and conditionals. Additionally, an annotation
may not appear in a position where it would change the grouping of
subexpressions:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="w">                          </span><span class="c1">-- accepted (a=0.25)</span><span class="w"></span>
<span class="nf">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="cm">{-# SCC &quot;name&quot; #-}</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="w">     </span><span class="c1">-- rejected (instead of b=1.0)</span><span class="w"></span>
</pre></div>
</div>
<p>This restriction is required to maintain the property that inserting a pragma,
just like inserting a comment, does not have unintended effects on the
semantics of the program, in accordance with <a class="reference external" href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0176-scc-parsing.rst">GHC Proposal #176</a>.</p>
<p>SCC stands for “Set Cost Centre”. The double quotes can be omitted if <code class="docutils literal notranslate"><span class="pre">name</span></code>
is a Haskell identifier starting with a lowercase letter, for example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# SCC id #-}</span><span class="w"> </span><span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span><span class="w"></span>
</pre></div>
</div>
<p>Cost centre annotations can also appear in the top-level or in a
declaration context. In that case you need to pass a function name
defined in the same module or scope with the annotation. Example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="w">  </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="n">g</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="w">    </span><span class="cm">{-# SCC g #-}</span><span class="w"></span>

<span class="cm">{-# SCC f #-}</span><span class="w"></span>
</pre></div>
</div>
<p>If you want to give a cost centre different name than the function name,
you can pass a string to the annotation</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="cm">{-# SCC f &quot;cost_centre_name&quot; #-}</span><span class="w"></span>
</pre></div>
</div>
<p>Here is an example of a program with a couple of SCCs:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">main</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">main</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">1000000</span><span class="p">]</span><span class="w"></span>
<span class="w">          </span><span class="kr">let</span><span class="w"> </span><span class="n">ys</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">2000000</span><span class="p">]</span><span class="w"></span>
<span class="w">          </span><span class="n">print</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="cm">{-# SCC last_xs #-}</span><span class="w"> </span><span class="n">last</span><span class="w"> </span><span class="n">xs</span><span class="w"></span>
<span class="w">          </span><span class="n">print</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="cm">{-# SCC last_init_xs #-}</span><span class="w"> </span><span class="n">last</span><span class="w"> </span><span class="p">(</span><span class="n">init</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">print</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="cm">{-# SCC last_ys #-}</span><span class="w"> </span><span class="n">last</span><span class="w"> </span><span class="n">ys</span><span class="w"></span>
<span class="w">          </span><span class="n">print</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="cm">{-# SCC last_init_ys #-}</span><span class="w"> </span><span class="n">last</span><span class="w"> </span><span class="p">(</span><span class="n">init</span><span class="w"> </span><span class="n">ys</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>which gives this profile when run:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>COST CENTRE     MODULE                  no.     entries  %time %alloc   %time %alloc

MAIN            MAIN                    102           0    0.0    0.0   100.0  100.0
 CAF            GHC.IO.Handle.FD        130           0    0.0    0.0     0.0    0.0
 CAF            GHC.IO.Encoding.Iconv   122           0    0.0    0.0     0.0    0.0
 CAF            GHC.Conc.Signal         111           0    0.0    0.0     0.0    0.0
 CAF            Main                    108           0    0.0    0.0   100.0  100.0
  main          Main                    204           1    0.0    0.0   100.0  100.0
   last_init_ys Main                    210           1   25.0   27.4    25.0   27.4
   main.ys      Main                    209           1   25.0   39.2    25.0   39.2
   last_ys      Main                    208           1   12.5    0.0    12.5    0.0
   last_init_xs Main                    207           1   12.5   13.7    12.5   13.7
   main.xs      Main                    206           1   18.8   19.6    18.8   19.6
   last_xs      Main                    205           1    6.2    0.0     6.2    0.0
</pre></div>
</div>
</section>
<section id="rules-for-attributing-costs">
<span id="prof-rules"></span><h3><span class="section-number">8.1.2. </span>Rules for attributing costs<a class="headerlink" href="#rules-for-attributing-costs" title="Permalink to this heading">¶</a></h3>
<p>While running a program with profiling turned on, GHC maintains a
cost-centre stack behind the scenes, and attributes any costs (memory
allocation and time) to whatever the current cost-centre stack is at the
time the cost is incurred.</p>
<p>The mechanism is simple: whenever the program evaluates an expression
with an SCC annotation, <code class="docutils literal notranslate"><span class="pre">{-#</span> <span class="pre">SCC</span> <span class="pre">c</span> <span class="pre">-#}</span> <span class="pre">E</span></code>, the cost centre <code class="docutils literal notranslate"><span class="pre">c</span></code> is
pushed on the current stack, and the entry count for this stack is
incremented by one. The stack also sometimes has to be saved and
restored; in particular when the program creates a thunk (a lazy
suspension), the current cost-centre stack is stored in the thunk, and
restored when the thunk is evaluated. In this way, the cost-centre stack
is independent of the actual evaluation order used by GHC at runtime.</p>
<p>At a function call, GHC takes the stack stored in the function being
called (which for a top-level function will be empty), and <em>appends</em> it
to the current stack, ignoring any prefix that is identical to a prefix
of the current stack.</p>
<p>We mentioned earlier that lazy computations, i.e. thunks, capture the
current stack when they are created, and restore this stack when they
are evaluated. What about top-level thunks? They are “created” when the
program is compiled, so what stack should we give them? The technical
name for a top-level thunk is a CAF (“Constant Applicative Form”). GHC
assigns every CAF in a module a stack consisting of the single cost
centre <code class="docutils literal notranslate"><span class="pre">M.CAF</span></code>, where <code class="docutils literal notranslate"><span class="pre">M</span></code> is the name of the module. It is also
possible to give each CAF a different stack, using the option
<a class="reference internal" href="#ghc-flag-fprof-cafs"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fprof-cafs</span></code></a>. This is especially useful when
compiling with <a class="reference internal" href="using-optimisation.html#ghc-flag-ffull-laziness"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-ffull-laziness</span></code></a> (as is default with <a class="reference internal" href="using-optimisation.html#ghc-flag-O"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-O</span></code></a>
and higher), as constants in function bodies will be lifted to the top-level
and become CAFs. You will probably need to consult the Core
(<a class="reference internal" href="debugging.html#ghc-flag-ddump-simpl"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-ddump-simpl</span></code></a>) in order to determine what these CAFs correspond to.</p>
</section>
</section>
<section id="compiler-options-for-profiling">
<span id="prof-compiler-options"></span><span id="index-1"></span><h2><span class="section-number">8.2. </span>Compiler options for profiling<a class="headerlink" href="#compiler-options-for-profiling" title="Permalink to this heading">¶</a></h2>
<span class="target" id="index-2"></span><dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-prof">
<span class="sig-name descname"><span class="pre">-prof</span></span><a class="headerlink" href="#ghc-flag-prof" title="Permalink to this definition">¶</a></dt>
<dd><p>To make use of the profiling system <em>all</em> modules must be compiled
and linked with the <a class="reference internal" href="#ghc-flag-prof"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-prof</span></code></a> option. Any <code class="docutils literal notranslate"><span class="pre">SCC</span></code> annotations you’ve
put in your source will spring to life.</p>
<p>Without a <a class="reference internal" href="#ghc-flag-prof"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-prof</span></code></a> option, your <code class="docutils literal notranslate"><span class="pre">SCC</span></code>s are ignored; so you can
compile <code class="docutils literal notranslate"><span class="pre">SCC</span></code>-laden code without changing it.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fno-prof-count-entries">
<span class="sig-name descname"><span class="pre">-fno-prof-count-entries</span></span><a class="headerlink" href="#ghc-flag-fno-prof-count-entries" title="Permalink to this definition">¶</a></dt>
<dd><p>Tells GHC not to collect information about how often functions are
entered at runtime (the “entries” column of the time profile), for
this module. This tends to make the profiled code run faster, and
hence closer to the speed of the unprofiled code, because GHC is
able to optimise more aggressively if it doesn’t have to maintain
correct entry counts. This option can be useful if you aren’t
interested in the entry counts (for example, if you only intend to
do heap profiling).</p>
</dd></dl>

<p>There are a few other profiling-related compilation options. Use them
<em>in addition to</em> <a class="reference internal" href="#ghc-flag-prof"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-prof</span></code></a>. These do not have to be used consistently
for all modules in a program.</p>
<section id="automatically-placing-cost-centres">
<h3><span class="section-number">8.2.1. </span>Automatically placing cost-centres<a class="headerlink" href="#automatically-placing-cost-centres" title="Permalink to this heading">¶</a></h3>
<p>GHC has a number of flags for automatically inserting cost-centres into the
compiled program.</p>
<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fprof-callers-name">
<span class="sig-name descname"><span class="pre">-fprof-callers</span></span><span class="sig-prename descclassname"><span class="pre">=⟨name⟩</span></span><a class="headerlink" href="#ghc-flag-fprof-callers-name" title="Permalink to this definition">¶</a></dt>
<dd><p>Automatically enclose all occurrences of the named function in an <code class="docutils literal notranslate"><span class="pre">SCC</span></code>.
Note that these cost-centres are added late in compilation (after
simplification) and consequently the names may be slightly different than
they appear in the source program (e.g. a call to <code class="docutils literal notranslate"><span class="pre">f</span></code> may inlined with
its wrapper, resulting in an occurrence of its worker, <code class="docutils literal notranslate"><span class="pre">$wf</span></code>).</p>
<p>In addition to plain module-qualified names (e.g. <code class="docutils literal notranslate"><span class="pre">GHC.Base.map</span></code>),
⟨name⟩ also accepts a small globbing language using <code class="docutils literal notranslate"><span class="pre">*</span></code> as a wildcard
symbol:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pattern    := &lt;module&gt; &#39;.&#39; &lt;identifier&gt;
module     := &#39;*&#39;
            | &lt;Haskell module name&gt;
identifier := &lt;ident_char&gt;
ident
</pre></div>
</div>
<p>For instance, the following are all valid patterns:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Data.List.map</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">*.map</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">*.parse*</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">*.&lt;\*&gt;</span></code></p></li>
</ul>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">*</span></code> character can be used literally by escaping (e.g. <code class="docutils literal notranslate"><span class="pre">\*</span></code>).</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fprof-auto">
<span class="sig-name descname"><span class="pre">-fprof-auto</span></span><a class="headerlink" href="#ghc-flag-fprof-auto" title="Permalink to this definition">¶</a></dt>
<dd><p><em>All</em> bindings not marked <a class="reference internal" href="exts/pragmas.html#pragma-INLINE"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">INLINE</span></code></a>, whether exported or not, top
level or nested, will be given automatic <code class="docutils literal notranslate"><span class="pre">SCC</span></code> annotations. Functions
marked <a class="reference internal" href="exts/pragmas.html#pragma-INLINE"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">INLINE</span></code></a> must be given a cost centre manually.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fprof-auto-top">
<span class="sig-name descname"><span class="pre">-fprof-auto-top</span></span><a class="headerlink" href="#ghc-flag-fprof-auto-top" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-3">GHC will automatically add <code class="docutils literal notranslate"><span class="pre">SCC</span></code> annotations for all top-level
bindings not marked <a class="reference internal" href="exts/pragmas.html#pragma-INLINE"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">INLINE</span></code></a>. If you want a cost centre on an
<a class="reference internal" href="exts/pragmas.html#pragma-INLINE"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">INLINE</span></code></a> function, you have to add it manually.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fprof-auto-exported">
<span class="sig-name descname"><span class="pre">-fprof-auto-exported</span></span><a class="headerlink" href="#ghc-flag-fprof-auto-exported" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-4">GHC will automatically add <code class="docutils literal notranslate"><span class="pre">SCC</span></code> annotations for all exported
functions not marked <a class="reference internal" href="exts/pragmas.html#pragma-INLINE"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">INLINE</span></code></a>. If you want a cost centre on an
<a class="reference internal" href="exts/pragmas.html#pragma-INLINE"><code class="xref std std-pragma docutils literal notranslate"><span class="pre">INLINE</span></code></a> function, you have to add it manually.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fprof-auto-calls">
<span class="sig-name descname"><span class="pre">-fprof-auto-calls</span></span><a class="headerlink" href="#ghc-flag-fprof-auto-calls" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds an automatic <code class="docutils literal notranslate"><span class="pre">SCC</span></code> annotation to all <em>call sites</em>. This is
particularly useful when using profiling for the purposes of
generating stack traces; see the function <a class="reference external" href="./../libraries/base-4.16.4.0/Debug-Trace.html#v:traceShow">Debug.Trace.traceShow</a>,
or the <a class="reference internal" href="runtime_control.html#rts-flag-xc"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-xc</span></code></a> RTS flag (<a class="reference internal" href="runtime_control.html#rts-options-debugging"><span class="std std-ref">RTS options for hackers, debuggers, and over-interested souls</span></a>) for more
details.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fprof-cafs">
<span class="sig-name descname"><span class="pre">-fprof-cafs</span></span><a class="headerlink" href="#ghc-flag-fprof-cafs" title="Permalink to this definition">¶</a></dt>
<dd><p>The costs of all CAFs in a module are usually attributed to one
“big” CAF cost-centre. With this option, all CAFs get their own
cost-centre. An “if all else fails” option…</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-auto-all">
<span class="sig-name descname"><span class="pre">-auto-all</span></span><a class="headerlink" href="#ghc-flag-auto-all" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated alias for <a class="reference internal" href="#ghc-flag-fprof-auto"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fprof-auto</span></code></a></p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-auto">
<span class="sig-name descname"><span class="pre">-auto</span></span><a class="headerlink" href="#ghc-flag-auto" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated alias for <a class="reference internal" href="#ghc-flag-fprof-auto-exported"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fprof-auto-exported</span></code></a></p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-caf-all">
<span class="sig-name descname"><span class="pre">-caf-all</span></span><a class="headerlink" href="#ghc-flag-caf-all" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated alias for <a class="reference internal" href="#ghc-flag-fprof-cafs"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fprof-cafs</span></code></a></p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-no-auto-all">
<span class="sig-name descname"><span class="pre">-no-auto-all</span></span><a class="headerlink" href="#ghc-flag-no-auto-all" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated alias for <a class="reference internal" href="#ghc-flag--fprof-auto-calls"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fno-prof-auto</span></code></a></p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-no-auto">
<span class="sig-name descname"><span class="pre">-no-auto</span></span><a class="headerlink" href="#ghc-flag-no-auto" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated alias for <a class="reference internal" href="#ghc-flag--fprof-auto-calls"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fno-prof-auto</span></code></a></p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-no-caf-all">
<span class="sig-name descname"><span class="pre">-no-caf-all</span></span><a class="headerlink" href="#ghc-flag-no-caf-all" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated alias for <a class="reference internal" href="#ghc-flag--fprof-cafs"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fno-prof-cafs</span></code></a></p>
</dd></dl>

</section>
</section>
<section id="time-and-allocation-profiling">
<span id="prof-time-options"></span><h2><span class="section-number">8.3. </span>Time and allocation profiling<a class="headerlink" href="#time-and-allocation-profiling" title="Permalink to this heading">¶</a></h2>
<p>To generate a time and allocation profile, give one of the following RTS
options to the compiled program when you run it (RTS options should be
enclosed between <code class="docutils literal notranslate"><span class="pre">+RTS</span> <span class="pre">...</span> <span class="pre">-RTS</span></code> as usual):</p>
<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-p">
<span class="sig-name descname"><span class="pre">-p</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#rts-flag-p" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object std" id="rts-flag-P">
<span class="sig-name descname"><span class="pre">-P</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#rts-flag-P" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object std" id="rts-flag-pa">
<span class="sig-name descname"><span class="pre">-pa</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#rts-flag-pa" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-5">The <a class="reference internal" href="#rts-flag-p"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-p</span></code></a> option produces a standard <em>time profile</em> report. It is
written into the file <code class="file docutils literal notranslate"><span class="pre">&lt;stem&gt;.prof</span></code>; the stem is taken to be the
program name by default, but can be overridden by the <a class="reference internal" href="#rts-flag-po-stem"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-po</span>
<span class="pre">⟨stem⟩</span></code></a> flag.</p>
<p>The <a class="reference internal" href="#rts-flag-P"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-P</span></code></a> option produces a more detailed report containing the
actual time and allocation data as well. (Not used much.)</p>
<p>The <a class="reference internal" href="#rts-flag-pa"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-pa</span></code></a> option produces the most detailed report containing all
cost centres in addition to the actual time and allocation data.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-pj">
<span class="sig-name descname"><span class="pre">-pj</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#rts-flag-pj" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#rts-flag-pj"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-pj</span></code></a> option produces a time/allocation profile report in JSON
format written into the file <code class="file docutils literal notranslate"><span class="pre">&lt;program&gt;.prof</span></code>.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-po-stem">
<span class="sig-name descname"><span class="pre">-po</span></span><span class="sig-prename descclassname"> <span class="pre">⟨stem⟩</span></span><a class="headerlink" href="#rts-flag-po-stem" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#rts-flag-po-stem"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-po</span> <span class="pre">⟨stem⟩</span></code></a> option overrides the stem used to form the
output file paths for the cost-centre profiler (see <a class="reference internal" href="#rts-flag-p"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-p</span></code></a> and
<a class="reference internal" href="#rts-flag-pj"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-pj</span></code></a> flags above) and heap profiler (see <a class="reference internal" href="runtime_control.html#rts-flag-h"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-h</span></code></a>).</p>
<p>For instance, running a program with <code class="docutils literal notranslate"><span class="pre">+RTS</span> <span class="pre">-h</span> <span class="pre">-p</span> <span class="pre">-pohello-world</span></code> would
produce a heap profile named <code class="file docutils literal notranslate"><span class="pre">hello-world.hp</span></code> and a cost-centre
profile named <code class="file docutils literal notranslate"><span class="pre">hello-world.prof</span></code>.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-V-secs">
<span class="sig-name descname"><span class="pre">-V</span></span><span class="sig-prename descclassname"> <span class="pre">⟨secs⟩</span></span><a class="headerlink" href="#rts-flag-V-secs" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>0.02</p>
</dd>
</dl>
<p>Sets the interval that the RTS clock ticks at, which is also the sampling
interval of the time and allocation profile. The default is 0.02 seconds.
The runtime uses a single timer signal to count ticks; this timer signal is
used to control the context switch timer (<a class="reference internal" href="using-concurrent.html#using-concurrent"><span class="std std-ref">Using Concurrent Haskell</span></a>) and the
heap profiling timer <a class="reference internal" href="#rts-options-heap-prof"><span class="std std-ref">RTS options for heap profiling</span></a>. Also, the time profiler
uses the RTS timer signal directly to record time profiling samples.</p>
<p>Normally, setting the <a class="reference internal" href="#rts-flag-V-secs"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-V</span> <span class="pre">⟨secs⟩</span></code></a> option directly is not
necessary: the resolution of the RTS timer is adjusted automatically if a
short interval is requested with the <a class="reference internal" href="using-concurrent.html#rts-flag-C-s"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-C</span> <span class="pre">⟨s⟩</span></code></a> or <a class="reference internal" href="#rts-flag-i-secs"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-i</span>
<span class="pre">⟨secs⟩</span></code></a> options. However, setting <a class="reference internal" href="#rts-flag-V-secs"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-V</span> <span class="pre">⟨secs⟩</span></code></a> is required in
order to increase the resolution of the time profiler.</p>
<p>Using a value of zero disables the RTS clock completely, and has the
effect of disabling timers that depend on it: the context switch
timer and the heap profiling timer. Context switches will still
happen, but deterministically and at a rate much faster than normal.
Disabling the interval timer is useful for debugging, because it
eliminates a source of non-determinism at runtime.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-xc">
<span class="sig-name descname"><span class="pre">-xc</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#rts-flag-xc" title="Permalink to this definition">¶</a></dt>
<dd><p>This option causes the runtime to print out the current cost-centre
stack whenever an exception is raised. This can be particularly
useful for debugging the location of exceptions, such as the
notorious <code class="docutils literal notranslate"><span class="pre">Prelude.head:</span> <span class="pre">empty</span> <span class="pre">list</span></code> error. See
<a class="reference internal" href="runtime_control.html#rts-options-debugging"><span class="std std-ref">RTS options for hackers, debuggers, and over-interested souls</span></a>.</p>
</dd></dl>

<section id="json-profile-format">
<h3><span class="section-number">8.3.1. </span>JSON profile format<a class="headerlink" href="#json-profile-format" title="Permalink to this heading">¶</a></h3>
<p>When invoked with the <a class="reference internal" href="#rts-flag-pj"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-pj</span></code></a> flag the runtime will emit the cost-centre
profile in a machine-readable JSON format. The top-level object of this format
has the following properties,</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">program</span></code> (string)</dt><dd><p>The name of the program</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">arguments</span></code> (list of strings)</dt><dd><p>The command line arguments passed to the program</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rts_arguments</span></code> (list of strings)</dt><dd><p>The command line arguments passed to the runtime system</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">initial_capabilities</span></code> (integral number)</dt><dd><p>How many capabilities the program was started with (e.g. using the
<a class="reference internal" href="using-concurrent.html#rts-flag-N-x"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-N</span> <span class="pre">⟨x⟩</span></code></a> option). Note that the number of capabilities may change
during execution due to the <code class="docutils literal notranslate"><span class="pre">setNumCapabilities</span></code> function.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">total_time</span></code> (number)</dt><dd><p>The total wall time of the program’s execution in seconds.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">total_ticks</span></code> (integral number)</dt><dd><p>How many profiler “ticks” elapsed over the course of the program’s execution.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">end_time</span></code> (number)</dt><dd><p>The approximate time when the program finished execution as a UNIX epoch timestamp.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tick_interval</span></code> (float)</dt><dd><p>How much time between profiler ticks.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">total_alloc</span></code> (integer)</dt><dd><p>The cumulative allocations of the program in bytes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cost_centres</span></code> (list of objects)</dt><dd><p>A list of the program’s cost centres</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">profile</span></code> (object)</dt><dd><p>The profile tree itself</p>
</dd>
</dl>
<p>Each entry in <code class="docutils literal notranslate"><span class="pre">cost_centres</span></code> is an object describing a cost-centre of the
program having the following properties,</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code> (integral number)</dt><dd><p>A unique identifier used to refer to the cost-centre</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_caf</span></code> (boolean)</dt><dd><p>Whether the cost-centre is a Constant Applicative Form (CAF)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">label</span></code> (string)</dt><dd><p>A descriptive string roughly identifying the cost-centre.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">src_loc</span></code> (string)</dt><dd><p>A string describing the source span enclosing the cost-centre.</p>
</dd>
</dl>
<p>The profile data itself is described by the <code class="docutils literal notranslate"><span class="pre">profile</span></code> field, which contains a
tree-like object (which we’ll call a “cost-centre stack” here) with the
following properties,</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code> (integral number)</dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">id</span></code> of a cost-centre listed in the <code class="docutils literal notranslate"><span class="pre">cost_centres</span></code> list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">entries</span></code> (integral number)</dt><dd><p>How many times was this cost-centre entered?</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ticks</span></code> (integral number)</dt><dd><p>How many ticks was the program’s execution inside of this cost-centre? This
does not include child cost-centres.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">alloc</span></code> (integral number)</dt><dd><p>How many bytes did the program allocate while inside of this cost-centre?
This does not include allocations while in child cost-centres.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">children</span></code> (list)</dt><dd><p>A list containing child cost-centre stacks.</p>
</dd>
</dl>
<p>For instance, a simple profile might look like this,</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nt">&quot;program&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Main&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="nt">&quot;arguments&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w"></span>
<span class="w">    </span><span class="s2">&quot;nofib/shootout/n-body/Main&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="s2">&quot;50000&quot;</span><span class="w"></span>
<span class="w">  </span><span class="p">],</span><span class="w"></span>
<span class="w">  </span><span class="nt">&quot;rts_arguments&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w"></span>
<span class="w">    </span><span class="s2">&quot;-pj&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="s2">&quot;-hy&quot;</span><span class="w"></span>
<span class="w">  </span><span class="p">],</span><span class="w"></span>
<span class="w">  </span><span class="nt">&quot;end_time&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Thu Feb 23 17:15 2017&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="nt">&quot;initial_capabilities&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="nt">&quot;total_time&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">1.7</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="nt">&quot;total_ticks&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1700</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="nt">&quot;tick_interval&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1000</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="nt">&quot;total_alloc&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">3770785728</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="nt">&quot;cost_centres&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nt">&quot;id&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">168</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="nt">&quot;label&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;IDLE&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="nt">&quot;module&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;IDLE&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="nt">&quot;src_loc&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;&lt;built-in&gt;&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="nt">&quot;is_caf&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w"></span>
<span class="w">    </span><span class="p">},</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nt">&quot;id&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">156</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="nt">&quot;label&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;CAF&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="nt">&quot;module&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;GHC.Integer.Logarithms.Internals&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="nt">&quot;src_loc&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;&lt;entire-module&gt;&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="nt">&quot;is_caf&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w"></span>
<span class="w">    </span><span class="p">},</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nt">&quot;id&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">155</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="nt">&quot;label&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;CAF&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="nt">&quot;module&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;GHC.Integer.Logarithms&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="nt">&quot;src_loc&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;&lt;entire-module&gt;&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="nt">&quot;is_caf&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w"></span>
<span class="w">    </span><span class="p">},</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nt">&quot;id&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">154</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="nt">&quot;label&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;CAF&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="nt">&quot;module&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;GHC.Event.Array&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="nt">&quot;src_loc&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;&lt;entire-module&gt;&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="nt">&quot;is_caf&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">],</span><span class="w"></span>
<span class="w">  </span><span class="nt">&quot;profile&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nt">&quot;id&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">162</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="nt">&quot;entries&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="nt">&quot;alloc&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">688</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="nt">&quot;ticks&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="nt">&quot;children&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nt">&quot;id&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="nt">&quot;entries&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="nt">&quot;alloc&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">208</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="nt">&quot;ticks&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="nt">&quot;children&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w"></span>
<span class="w">          </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nt">&quot;id&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">22</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="nt">&quot;entries&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="nt">&quot;alloc&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">80</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="nt">&quot;ticks&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="nt">&quot;children&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[]</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">]</span><span class="w"></span>
<span class="w">      </span><span class="p">},</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nt">&quot;id&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">42</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="nt">&quot;entries&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="nt">&quot;alloc&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1632</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="nt">&quot;ticks&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="nt">&quot;children&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[]</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="profiling-memory-usage">
<span id="prof-heap"></span><h2><span class="section-number">8.4. </span>Profiling memory usage<a class="headerlink" href="#profiling-memory-usage" title="Permalink to this heading">¶</a></h2>
<p>In addition to profiling the time and allocation behaviour of your
program, you can also generate a graph of its memory usage over time.
This is useful for detecting the causes of space leaks, when your
program holds on to more memory at run-time that it needs to. Space
leaks lead to slower execution due to heavy garbage collector activity,
and may even cause the program to run out of memory altogether.</p>
<p>To generate a heap profile from your program:</p>
<ol class="arabic">
<li><p>Compile the program for profiling (<a class="reference internal" href="#prof-compiler-options"><span class="std std-ref">Compiler options for profiling</span></a>).</p></li>
<li><p>Run it with one of the heap profiling options described below (eg.
<a class="reference internal" href="#rts-flag-hc"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-hc</span></code></a> for a basic producer profile). This generates the file
<code class="file docutils literal notranslate"><em><span class="pre">prog</span></em><span class="pre">.hp</span></code>.</p>
<p>If the <a class="reference internal" href="runtime_control.html#rts-eventlog"><span class="std std-ref">event log</span></a> is enabled (with the <a class="reference internal" href="runtime_control.html#rts-flag-l-flags"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-l</span> <span class="pre">⟨flags⟩</span></code></a>
runtime system flag) heap samples will additionally be emitted to the GHC
event log (see <a class="reference internal" href="eventlog-formats.html#heap-profiler-events"><span class="std std-ref">Heap profiler event log output</span></a> for details about event format).</p>
</li>
<li><p>Run <strong class="command">hp2ps</strong> to produce a Postscript file, <code class="file docutils literal notranslate"><em><span class="pre">prog</span></em><span class="pre">.ps</span></code>. The
<strong class="command">hp2ps</strong> utility is described in detail in <a class="reference internal" href="#hp2ps"><span class="std std-ref">hp2ps – Rendering heap profiles to PostScript</span></a>.</p></li>
<li><p>Display the heap profile using a postscript viewer such as Ghostview,
or print it out on a Postscript-capable printer.</p></li>
</ol>
<p>For example, here is a heap profile produced for the <code class="docutils literal notranslate"><span class="pre">sphere</span></code> program
from GHC’s <code class="docutils literal notranslate"><span class="pre">nofib</span></code> benchmark suite,</p>
<img alt="_images/prof_scc.svg" src="_images/prof_scc.svg" /><p>You might also want to take a look at
<a class="reference external" href="http://www.haskell.org/haskellwiki/Hp2any">hp2any</a>, a more advanced
suite of tools (not distributed with GHC) for displaying heap profiles.</p>
<p>Note that there might be a big difference between the OS reported memory usage
of your program and the amount of live data as reported by heap profiling.
The reasons for the difference are explained in <a class="reference internal" href="hints.html#hints-os-memory"><span class="std std-ref">Understanding how OS memory usage corresponds to live data</span></a>.</p>
<section id="rts-options-for-heap-profiling">
<span id="rts-options-heap-prof"></span><h3><span class="section-number">8.4.1. </span>RTS options for heap profiling<a class="headerlink" href="#rts-options-for-heap-profiling" title="Permalink to this heading">¶</a></h3>
<p>There are several different kinds of heap profile that can be generated.
All the different profile types yield a graph of live heap against time,
but they differ in how the live heap is broken down into bands. The
following RTS options select which break-down to use:</p>
<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-hT">
<span class="sig-name descname"><span class="pre">-hT</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#rts-flag-hT" title="Permalink to this definition">¶</a></dt>
<dd><p>Breaks down the graph by heap closure type.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-hc">
<span class="sig-name descname"><span class="pre">-hc</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#rts-flag-hc" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object std" id="rts-flag-h">
<span class="sig-name descname"><span class="pre">-h</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#rts-flag-h" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Requires</em> <a class="reference internal" href="#ghc-flag-prof"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-prof</span></code></a>. Breaks down the graph by the cost-centre stack
which produced the data.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The meaning of the shortened <a class="reference internal" href="runtime_control.html#rts-flag-h"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-h</span></code></a> is dependent on whether
your program was compiled for profiling. When compiled for profiling,
<a class="reference internal" href="runtime_control.html#rts-flag-h"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-h</span></code></a> is equivalent to <a class="reference internal" href="#rts-flag-hc"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-hc</span></code></a>, but otherwise is
equivalent to <a class="reference internal" href="runtime_control.html#rts-flag-hT"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-hT</span></code></a> (see <a class="reference internal" href="runtime_control.html#rts-profiling"><span class="std std-ref">RTS options for profiling</span></a>). The <a class="reference internal" href="runtime_control.html#rts-flag-h"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-h</span></code></a>
is deprecated and will be removed in a future release.</p>
</div>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-hm">
<span class="sig-name descname"><span class="pre">-hm</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#rts-flag-hm" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Requires</em> <a class="reference internal" href="#ghc-flag-prof"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-prof</span></code></a>. Break down the live heap by the module
containing the code which produced the data.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-hd">
<span class="sig-name descname"><span class="pre">-hd</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#rts-flag-hd" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Requires</em> <a class="reference internal" href="#ghc-flag-prof"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-prof</span></code></a>. Breaks down the graph by closure description.
For actual data, the description is just the constructor name, for other
closures it is a compiler-generated string identifying the closure.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-hy">
<span class="sig-name descname"><span class="pre">-hy</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#rts-flag-hy" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Requires</em> <a class="reference internal" href="#ghc-flag-prof"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-prof</span></code></a>. Breaks down the graph by type. For closures
which have function type or unknown/polymorphic type, the string will
represent an approximation to the actual type.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-hr">
<span class="sig-name descname"><span class="pre">-hr</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#rts-flag-hr" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Requires</em> <a class="reference internal" href="#ghc-flag-prof"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-prof</span></code></a>. Break down the graph by retainer set. Retainer
profiling is described in more detail below (<a class="reference internal" href="#retainer-prof"><span class="std std-ref">Retainer Profiling</span></a>).</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-hb">
<span class="sig-name descname"><span class="pre">-hb</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#rts-flag-hb" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Requires</em> <a class="reference internal" href="#ghc-flag-prof"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-prof</span></code></a>. Break down the graph by biography.
Biographical profiling is described in more detail below
(<a class="reference internal" href="#biography-prof"><span class="std std-ref">Biographical Profiling</span></a>).</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-hi">
<span class="sig-name descname"><span class="pre">-hi</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#rts-flag-hi" title="Permalink to this definition">¶</a></dt>
<dd><p>Break down the graph by the address of the info table of a closure. For this
to produce useful output the program must have been compiled with
<a class="reference internal" href="debug-info.html#ghc-flag-finfo-table-map"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-finfo-table-map</span></code></a>.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std">
<span class="sig-name descname"><span class="pre">-l</span></span><span class="sig-prename descclassname"></span></dt>
<dd><p id="index-6">Emit profile samples to the <a class="reference internal" href="runtime_control.html#rts-eventlog"><span class="std std-ref">GHC event log</span></a>.
This format is both more expressive than the old <code class="docutils literal notranslate"><span class="pre">.hp</span></code> format
and can be correlated with other events over the program’s runtime.
See <a class="reference internal" href="eventlog-formats.html#heap-profiler-events"><span class="std std-ref">Heap profiler event log output</span></a> for details on the produced event structure.</p>
</dd></dl>

<p>In addition, the profile can be restricted to heap data which satisfies
certain criteria - for example, you might want to display a profile by
type but only for data produced by a certain module, or a profile by
retainer for a certain type of data. Restrictions are specified as
follows:</p>
<dl class="std rts-flag">
<dt class="sig sig-object std">
<span class="sig-name descname"><span class="pre">-hc</span></span><span class="sig-prename descclassname"> <span class="pre">⟨name⟩</span></span></dt>
<dd><p>Restrict the profile to closures produced by cost-centre stacks with
one of the specified cost centres at the top.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std">
<span class="sig-name descname"><span class="pre">-hC</span></span><span class="sig-prename descclassname"> <span class="pre">⟨name⟩</span></span></dt>
<dd><p>Restrict the profile to closures produced by cost-centre stacks with
one of the specified cost centres anywhere in the stack.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std">
<span class="sig-name descname"><span class="pre">-hm</span></span><span class="sig-prename descclassname"> <span class="pre">⟨module⟩</span></span></dt>
<dd><p>Restrict the profile to closures produced by the specified modules.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std">
<span class="sig-name descname"><span class="pre">-hd</span></span><span class="sig-prename descclassname"> <span class="pre">⟨desc⟩</span></span></dt>
<dd><p>Restrict the profile to closures with the specified description
strings.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std">
<span class="sig-name descname"><span class="pre">-hy</span></span><span class="sig-prename descclassname"> <span class="pre">⟨type⟩</span></span></dt>
<dd><p>Restrict the profile to closures with the specified types.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std">
<span class="sig-name descname"><span class="pre">-hr</span></span><span class="sig-prename descclassname"> <span class="pre">⟨cc⟩</span></span></dt>
<dd><p>Restrict the profile to closures with retainer sets containing
cost-centre stacks with one of the specified cost centres at the
top.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std">
<span class="sig-name descname"><span class="pre">-hb</span></span><span class="sig-prename descclassname"> <span class="pre">⟨bio⟩</span></span></dt>
<dd><p>Restrict the profile to closures with one of the specified
biographies, where ⟨bio⟩ is one of <code class="docutils literal notranslate"><span class="pre">lag</span></code>, <code class="docutils literal notranslate"><span class="pre">drag</span></code>, <code class="docutils literal notranslate"><span class="pre">void</span></code>, or
<code class="docutils literal notranslate"><span class="pre">use</span></code>.</p>
</dd></dl>

<p>For example, the following options will generate a retainer profile
restricted to <code class="docutils literal notranslate"><span class="pre">Branch</span></code> and <code class="docutils literal notranslate"><span class="pre">Leaf</span></code> constructors:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>prog +RTS -hr -hdBranch,Leaf
</pre></div>
</div>
<p>There can only be one “break-down” option (eg. <a class="reference internal" href="#rts-flag-hr"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-hr</span></code></a> in the example
above), but there is no limit on the number of further restrictions that
may be applied. All the options may be combined, with one exception: GHC
doesn’t currently support mixing the <a class="reference internal" href="#rts-flag-hr"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-hr</span></code></a> and <a class="reference internal" href="#rts-flag-hb"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-hb</span></code></a> options.</p>
<p>There are three more options which relate to heap profiling:</p>
<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-i-secs">
<span class="sig-name descname"><span class="pre">-i</span></span><span class="sig-prename descclassname"> <span class="pre">⟨secs⟩</span></span><a class="headerlink" href="#rts-flag-i-secs" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the profiling (sampling) interval to ⟨secs⟩ seconds (the default
is 0.1 second). Fractions are allowed: for example <code class="docutils literal notranslate"><span class="pre">-i0.2</span></code> will
get 5 samples per second. This only affects heap profiling; time
profiles are always sampled with the frequency of the RTS clock. See
<a class="reference internal" href="#prof-time-options"><span class="std std-ref">Time and allocation profiling</span></a> for changing that.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-no-automatic-heap-samples">
<span class="sig-name descname"><span class="pre">--no-automatic-heap-samples</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#rts-flag-no-automatic-heap-samples" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>9.2.1</p>
</dd>
</dl>
<p>Don’t start heap profiling from the start of program execution. If this
option is enabled, it’s expected that the user will manually start heap
profiling or request specific samples using functions from <code class="docutils literal notranslate"><span class="pre">GHC.Profiling</span></code>.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-null-eventlog-writer">
<span class="sig-name descname"><span class="pre">--null-eventlog-writer</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#rts-flag-null-eventlog-writer" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>9.2.2</p>
</dd>
</dl>
<p>Don’t output eventlog to file, only configure tracing events.
Meant to be used with customized event log writer.</p>
</dd></dl>

<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-L-num">
<span class="sig-name descname"><span class="pre">-L</span></span><span class="sig-prename descclassname"> <span class="pre">⟨num⟩</span></span><a class="headerlink" href="#rts-flag-L-num" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the maximum length of a cost-centre stack name in a heap
profile. Defaults to 25.</p>
</dd></dl>

</section>
<section id="retainer-profiling">
<span id="retainer-prof"></span><h3><span class="section-number">8.4.2. </span>Retainer Profiling<a class="headerlink" href="#retainer-profiling" title="Permalink to this heading">¶</a></h3>
<p>Retainer profiling is designed to help answer questions like “why is
this data being retained?”. We start by defining what we mean by a
retainer:</p>
<blockquote>
<div><p>A retainer is either the system stack, an unevaluated closure
(thunk), or an explicitly mutable object.</p>
</div></blockquote>
<p>In particular, constructors are <em>not</em> retainers.</p>
<p>An object <code class="docutils literal notranslate"><span class="pre">B</span></code> retains object <code class="docutils literal notranslate"><span class="pre">A</span></code> if (i) <code class="docutils literal notranslate"><span class="pre">B</span></code> is a retainer object and (ii)
object <code class="docutils literal notranslate"><span class="pre">A</span></code> can be reached by recursively following pointers starting from
object <code class="docutils literal notranslate"><span class="pre">B</span></code>, but not meeting any other retainer objects on the way. Each
live object is retained by one or more retainer objects, collectively
called its retainer set, or its retainer set, or its retainers.</p>
<p>When retainer profiling is requested by giving the program the <code class="docutils literal notranslate"><span class="pre">-hr</span></code>
option, a graph is generated which is broken down by retainer set. A
retainer set is displayed as a set of cost-centre stacks; because this
is usually too large to fit on the profile graph, each retainer set is
numbered and shown abbreviated on the graph along with its number, and
the full list of retainer sets is dumped into the file <code class="docutils literal notranslate"><span class="pre">prog.prof</span></code>.</p>
<p>Retainer profiling requires multiple passes over the live heap in order
to discover the full retainer set for each object, which can be quite
slow. So we set a limit on the maximum size of a retainer set, where all
retainer sets larger than the maximum retainer set size are replaced by
the special set <code class="docutils literal notranslate"><span class="pre">MANY</span></code>. The maximum set size defaults to 8 and can be
altered with the <a class="reference internal" href="#rts-flag-R-size"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-R</span> <span class="pre">⟨size⟩</span></code></a> RTS option:</p>
<dl class="std rts-flag">
<dt class="sig sig-object std" id="rts-flag-R-size">
<span class="sig-name descname"><span class="pre">-R</span></span><span class="sig-prename descclassname"> <span class="pre">⟨size⟩</span></span><a class="headerlink" href="#rts-flag-R-size" title="Permalink to this definition">¶</a></dt>
<dd><p>Restrict the number of elements in a retainer set to ⟨size⟩ (default
8).</p>
</dd></dl>

<section id="hints-for-using-retainer-profiling">
<h4><span class="section-number">8.4.2.1. </span>Hints for using retainer profiling<a class="headerlink" href="#hints-for-using-retainer-profiling" title="Permalink to this heading">¶</a></h4>
<p>The definition of retainers is designed to reflect a common cause of
space leaks: a large structure is retained by an unevaluated
computation, and will be released once the computation is forced. A good
example is looking up a value in a finite map, where unless the lookup
is forced in a timely manner the unevaluated lookup will cause the whole
mapping to be retained. These kind of space leaks can often be
eliminated by forcing the relevant computations to be performed eagerly,
using <code class="docutils literal notranslate"><span class="pre">seq</span></code> or strictness annotations on data constructor fields.</p>
<p>Often a particular data structure is being retained by a chain of
unevaluated closures, only the nearest of which will be reported by
retainer profiling - for example <code class="docutils literal notranslate"><span class="pre">A</span></code> retains <code class="docutils literal notranslate"><span class="pre">B</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code> retains <code class="docutils literal notranslate"><span class="pre">C</span></code>, and
<code class="docutils literal notranslate"><span class="pre">C</span></code> retains a large structure. There might be a large number of <code class="docutils literal notranslate"><span class="pre">B</span></code>s but
only a single <code class="docutils literal notranslate"><span class="pre">A</span></code>, so <code class="docutils literal notranslate"><span class="pre">A</span></code> is really the one we’re interested in eliminating.
However, retainer profiling will in this case report <code class="docutils literal notranslate"><span class="pre">B</span></code> as the retainer of
the large structure. To move further up the chain of retainers, we can ask for
another retainer profile but this time restrict the profile to <code class="docutils literal notranslate"><span class="pre">B</span></code> objects, so
we get a profile of the retainers of <code class="docutils literal notranslate"><span class="pre">B</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>prog +RTS -hr -hcB
</pre></div>
</div>
<p>This trick isn’t foolproof, because there might be other <code class="docutils literal notranslate"><span class="pre">B</span></code> closures in
the heap which aren’t the retainers we are interested in, but we’ve
found this to be a useful technique in most cases.</p>
</section>
</section>
<section id="biographical-profiling">
<span id="biography-prof"></span><h3><span class="section-number">8.4.3. </span>Biographical Profiling<a class="headerlink" href="#biographical-profiling" title="Permalink to this heading">¶</a></h3>
<p>A typical heap object may be in one of the following four states at each
point in its lifetime:</p>
<ul class="simple">
<li><p>The lag stage, which is the time between creation and the first use
of the object,</p></li>
<li><p>the use stage, which lasts from the first use until the last use of
the object, and</p></li>
<li><p>The drag stage, which lasts from the final use until the last
reference to the object is dropped.</p></li>
<li><p>An object which is never used is said to be in the void state for its
whole lifetime.</p></li>
</ul>
<p>A biographical heap profile displays the portion of the live heap in
each of the four states listed above. Usually the most interesting
states are the void and drag states: live heap in these states is more
likely to be wasted space than heap in the lag or use states.</p>
<p>It is also possible to break down the heap in one or more of these
states by a different criteria, by restricting a profile by biography.
For example, to show the portion of the heap in the drag or void state
by producer:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>prog +RTS -hc -hbdrag,void
</pre></div>
</div>
<p>Once you know the producer or the type of the heap in the drag or void
states, the next step is usually to find the retainer(s):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>prog +RTS -hr -hccc...
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This two stage process is required because GHC cannot currently
profile using both biographical and retainer information simultaneously.</p>
</div>
</section>
<section id="actual-memory-residency">
<span id="mem-residency"></span><h3><span class="section-number">8.4.4. </span>Actual memory residency<a class="headerlink" href="#actual-memory-residency" title="Permalink to this heading">¶</a></h3>
<p>How does the heap residency reported by the heap profiler relate to the
actual memory residency of your program when you run it? You might see a
large discrepancy between the residency reported by the heap profiler,
and the residency reported by tools on your system (eg. <code class="docutils literal notranslate"><span class="pre">ps</span></code> or
<code class="docutils literal notranslate"><span class="pre">top</span></code> on Unix, or the Task Manager on Windows). There are several
reasons for this:</p>
<ul class="simple">
<li><p>There is an overhead of profiling itself, which is subtracted from
the residency figures by the profiler. This overhead goes away when
compiling without profiling support, of course. The space overhead is
currently 2 extra words per heap object, which probably results in
about a 30% overhead.</p></li>
<li><p>Garbage collection requires more memory than the actual residency.  The
factor depends on the kind of garbage collection algorithm in use: a major GC
in the standard generation copying collector will usually require <span class="math notranslate nohighlight">\(3L\)</span>
bytes of memory, where <span class="math notranslate nohighlight">\(L\)</span> is the amount of live data. This is because
by default (see the RTS <a class="reference internal" href="runtime_control.html#rts-flag-F-factor"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-F</span> <span class="pre">⟨factor⟩</span></code></a> option) we allow the old
generation to grow to twice its size (<span class="math notranslate nohighlight">\(2L\)</span>) before collecting it, and
we require additionally <span class="math notranslate nohighlight">\(L\)</span> bytes to copy the live data into. When
using compacting collection (see the <a class="reference internal" href="runtime_control.html#rts-flag-c"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-c</span></code></a> option), this is reduced
to <span class="math notranslate nohighlight">\(2L\)</span>, and can further be reduced by tweaking the <a class="reference internal" href="runtime_control.html#rts-flag-F-factor"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-F</span>
<span class="pre">⟨factor⟩</span></code></a> option. Also add the size of the allocation area (see <a class="reference internal" href="runtime_control.html#rts-flag-A-size"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-A</span>
<span class="pre">⟨size⟩</span></code></a>).</p></li>
<li><p>The program text itself, the C stack, any non-heap data (e.g. data
allocated by foreign libraries, and data allocated by the RTS), and
<code class="docutils literal notranslate"><span class="pre">mmap()</span></code>'d memory are not counted in the heap profile.</p></li>
</ul>
</section>
</section>
<section id="hp2ps-rendering-heap-profiles-to-postscript">
<span id="hp2ps"></span><h2><span class="section-number">8.5. </span><code class="docutils literal notranslate"><span class="pre">hp2ps</span></code> – Rendering heap profiles to PostScript<a class="headerlink" href="#hp2ps-rendering-heap-profiles-to-postscript" title="Permalink to this heading">¶</a></h2>
<p id="index-7">Usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>hp2ps [flags] [&lt;file&gt;[.hp]]
</pre></div>
</div>
<p>The program <strong class="command">hp2ps</strong> program converts a <code class="docutils literal notranslate"><span class="pre">.hp</span></code> file produced
by the <code class="docutils literal notranslate"><span class="pre">-h&lt;break-down&gt;</span></code> runtime option into a PostScript graph of the
heap profile. By convention, the file to be processed by <strong class="command">hp2ps</strong> has a
<code class="docutils literal notranslate"><span class="pre">.hp</span></code> extension. The PostScript output is written to <code class="file docutils literal notranslate"><em><span class="pre">file</span></em><span class="pre">&#64;.ps</span></code>.
If <code class="docutils literal notranslate"><span class="pre">&lt;file&gt;</span></code> is omitted entirely, then the program behaves as a filter.</p>
<p><strong class="command">hp2ps</strong> is distributed in <code class="file docutils literal notranslate"><span class="pre">ghc/utils/hp2ps</span></code> in a GHC source
distribution. It was originally developed by Dave Wakeling as part of
the HBC/LML heap profiler.</p>
<p>The flags are:</p>
<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-hp2ps-d">
<span class="sig-name descname"><span class="pre">-d</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-hp2ps-d" title="Permalink to this definition">¶</a></dt>
<dd><p>In order to make graphs more readable, <code class="docutils literal notranslate"><span class="pre">hp2ps</span></code> sorts the shaded
bands for each identifier. The default sort ordering is for the
bands with the largest area to be stacked on top of the smaller
ones. The <code class="docutils literal notranslate"><span class="pre">-d</span></code> option causes rougher bands (those representing
series of values with the largest standard deviations) to be stacked
on top of smoother ones.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-hp2ps-b">
<span class="sig-name descname"><span class="pre">-b</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-hp2ps-b" title="Permalink to this definition">¶</a></dt>
<dd><p>Normally, <code class="docutils literal notranslate"><span class="pre">hp2ps</span></code> puts the title of the graph in a small box at
the top of the page. However, if the JOB string is too long to fit
in a small box (more than 35 characters), then <code class="docutils literal notranslate"><span class="pre">hp2ps</span></code> will choose
to use a big box instead. The <code class="docutils literal notranslate"><span class="pre">-b</span></code> option forces <code class="docutils literal notranslate"><span class="pre">hp2ps</span></code> to use
a big box.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-hp2ps-efloat-in-mm-pt">
<span class="sig-name descname"><span class="pre">-e⟨float⟩[in|mm|pt]</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-hp2ps-efloat-in-mm-pt" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate encapsulated PostScript suitable for inclusion in LaTeX
documents. Usually, the PostScript graph is drawn in landscape mode
in an area 9 inches wide by 6 inches high, and <code class="docutils literal notranslate"><span class="pre">hp2ps</span></code> arranges
for this area to be approximately centred on a sheet of a4 paper.
This format is convenient of studying the graph in detail, but it is
unsuitable for inclusion in LaTeX documents. The <code class="docutils literal notranslate"><span class="pre">-e</span></code> option
causes the graph to be drawn in portrait mode, with float specifying
the width in inches, millimetres or points (the default). The
resulting PostScript file conforms to the Encapsulated PostScript
(EPS) convention, and it can be included in a LaTeX document using
Rokicki’s dvi-to-PostScript converter <code class="docutils literal notranslate"><span class="pre">dvips</span></code>.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-hp2ps-g">
<span class="sig-name descname"><span class="pre">-g</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-hp2ps-g" title="Permalink to this definition">¶</a></dt>
<dd><p>Create output suitable for the <code class="docutils literal notranslate"><span class="pre">gs</span></code> PostScript previewer (or
similar). In this case the graph is printed in portrait mode without
scaling. The output is unsuitable for a laser printer.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-hp2ps-l">
<span class="sig-name descname"><span class="pre">-l</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-hp2ps-l" title="Permalink to this definition">¶</a></dt>
<dd><p>Normally a profile is limited to 20 bands with additional
identifiers being grouped into an <code class="docutils literal notranslate"><span class="pre">OTHER</span></code> band. The <code class="docutils literal notranslate"><span class="pre">-l</span></code> flag
removes this 20 band and limit, producing as many bands as
necessary. No key is produced as it won’t fit!. It is useful for
creation time profiles with many bands.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-hp2ps-mint">
<span class="sig-name descname"><span class="pre">-m⟨int⟩</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-hp2ps-mint" title="Permalink to this definition">¶</a></dt>
<dd><p>Normally a profile is limited to 20 bands with additional
identifiers being grouped into an <code class="docutils literal notranslate"><span class="pre">OTHER</span></code> band. The <code class="docutils literal notranslate"><span class="pre">-m</span></code> flag
specifies an alternative band limit (the maximum is 20).</p>
<p><code class="docutils literal notranslate"><span class="pre">-m0</span></code> requests the band limit to be removed. As many bands as
necessary are produced. However no key is produced as it won’t fit!
It is useful for displaying creation time profiles with many bands.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-hp2ps-p">
<span class="sig-name descname"><span class="pre">-p</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-hp2ps-p" title="Permalink to this definition">¶</a></dt>
<dd><p>Use previous parameters. By default, the PostScript graph is
automatically scaled both horizontally and vertically so that it
fills the page. However, when preparing a series of graphs for use
in a presentation, it is often useful to draw a new graph using the
same scale, shading and ordering as a previous one. The <code class="docutils literal notranslate"><span class="pre">-p</span></code> flag
causes the graph to be drawn using the parameters determined by a
previous run of <code class="docutils literal notranslate"><span class="pre">hp2ps</span></code> on <code class="docutils literal notranslate"><span class="pre">file</span></code>. These are extracted from
<code class="docutils literal notranslate"><span class="pre">file&#64;.aux</span></code>.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-hp2ps-s">
<span class="sig-name descname"><span class="pre">-s</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-hp2ps-s" title="Permalink to this definition">¶</a></dt>
<dd><p>Use a small box for the title.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-hp2ps-tfloat">
<span class="sig-name descname"><span class="pre">-t⟨float⟩</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-hp2ps-tfloat" title="Permalink to this definition">¶</a></dt>
<dd><p>Normally trace elements which sum to a total of less than 1% of the
profile are removed from the profile. The <code class="docutils literal notranslate"><span class="pre">-t</span></code> option allows this
percentage to be modified (maximum 5%).</p>
<p><code class="docutils literal notranslate"><span class="pre">-t0</span></code> requests no trace elements to be removed from the profile,
ensuring that all the data will be displayed.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-hp2ps-c">
<span class="sig-name descname"><span class="pre">-c</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-hp2ps-c" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate colour output.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-hp2ps-y">
<span class="sig-name descname"><span class="pre">-y</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-hp2ps-y" title="Permalink to this definition">¶</a></dt>
<dd><p>Ignore marks.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-hp2ps-0">
<span id="cmdoption-hp2ps"></span><span class="sig-name descname"><span class="pre">-?</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-hp2ps-0" title="Permalink to this definition">¶</a></dt>
<dd><p>Print out usage information.</p>
</dd></dl>

<section id="manipulating-the-hp-file">
<span id="manipulating-hp"></span><h3><span class="section-number">8.5.1. </span>Manipulating the <code class="docutils literal notranslate"><span class="pre">hp</span></code> file<a class="headerlink" href="#manipulating-the-hp-file" title="Permalink to this heading">¶</a></h3>
<p>(Notes kindly offered by Jan-Willem Maessen.)</p>
<p>The <code class="docutils literal notranslate"><span class="pre">FOO.hp</span></code> file produced when you ask for the heap profile of a
program <code class="docutils literal notranslate"><span class="pre">FOO</span></code> is a text file with a particularly simple structure.
Here’s a representative example, with much of the actual data omitted:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>JOB &quot;FOO -hC&quot;
DATE &quot;Thu Dec 26 18:17 2002&quot;
SAMPLE_UNIT &quot;seconds&quot;
VALUE_UNIT &quot;bytes&quot;
BEGIN_SAMPLE 0.00
END_SAMPLE 0.00
BEGIN_SAMPLE 15.07
  ... sample data ...
END_SAMPLE 15.07
BEGIN_SAMPLE 30.23
  ... sample data ...
END_SAMPLE 30.23
... etc.
BEGIN_SAMPLE 11695.47
END_SAMPLE 11695.47
</pre></div>
</div>
<p>The first four lines (<code class="docutils literal notranslate"><span class="pre">JOB</span></code>, <code class="docutils literal notranslate"><span class="pre">DATE</span></code>, <code class="docutils literal notranslate"><span class="pre">SAMPLE_UNIT</span></code>,
<code class="docutils literal notranslate"><span class="pre">VALUE_UNIT</span></code>) form a header. Each block of lines starting with
<code class="docutils literal notranslate"><span class="pre">BEGIN_SAMPLE</span></code> and ending with <code class="docutils literal notranslate"><span class="pre">END_SAMPLE</span></code> forms a single sample
(you can think of this as a vertical slice of your heap profile). The
hp2ps utility should accept any input with a properly-formatted header
followed by a series of <em>complete</em> samples.</p>
</section>
<section id="zooming-in-on-regions-of-your-profile">
<h3><span class="section-number">8.5.2. </span>Zooming in on regions of your profile<a class="headerlink" href="#zooming-in-on-regions-of-your-profile" title="Permalink to this heading">¶</a></h3>
<p>You can look at particular regions of your profile simply by loading a
copy of the <code class="docutils literal notranslate"><span class="pre">.hp</span></code> file into a text editor and deleting the unwanted
samples. The resulting <code class="docutils literal notranslate"><span class="pre">.hp</span></code> file can be run through <code class="docutils literal notranslate"><span class="pre">hp2ps</span></code> and
viewed or printed.</p>
</section>
<section id="viewing-the-heap-profile-of-a-running-program">
<h3><span class="section-number">8.5.3. </span>Viewing the heap profile of a running program<a class="headerlink" href="#viewing-the-heap-profile-of-a-running-program" title="Permalink to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">.hp</span></code> file is generated incrementally as your program runs. In
principle, running <strong class="command">hp2ps</strong> on the incomplete file should produce a
snapshot of your program’s heap usage. However, the last sample in the
file may be incomplete, causing <strong class="command">hp2ps</strong> to fail. If you are using a
machine with UNIX utilities installed, it’s not too hard to work around
this problem (though the resulting command line looks rather Byzantine):</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>head -<span class="sb">`</span>fgrep -n END_SAMPLE FOO.hp <span class="p">|</span> tail -1 <span class="p">|</span> cut -d : -f <span class="m">1</span><span class="sb">`</span> FOO.hp <span class="se">\</span>
    <span class="p">|</span> hp2ps &gt; FOO.ps
</pre></div>
</div>
<p>The command <code class="docutils literal notranslate"><span class="pre">fgrep</span> <span class="pre">-n</span> <span class="pre">END_SAMPLE</span> <span class="pre">FOO.hp</span></code> finds the end of every
complete sample in <code class="docutils literal notranslate"><span class="pre">FOO.hp</span></code>, and labels each sample with its ending
line number. We then select the line number of the last complete sample
using <strong class="command">tail</strong> and <strong class="command">cut</strong>. This is used as a parameter to <strong class="command">head</strong>; the
result is as if we deleted the final incomplete sample from <code class="file docutils literal notranslate"><span class="pre">FOO.hp</span></code>.
This results in a properly-formatted .hp file which we feed directly to
<strong class="command">hp2ps</strong>.</p>
</section>
<section id="viewing-a-heap-profile-in-real-time">
<h3><span class="section-number">8.5.4. </span>Viewing a heap profile in real time<a class="headerlink" href="#viewing-a-heap-profile-in-real-time" title="Permalink to this heading">¶</a></h3>
<p>The <strong class="command">gv</strong> and <strong class="command">ghostview</strong> programs have a “watch file” option
can be used to view an up-to-date heap profile of your program as it runs.
Simply generate an incremental heap profile as described in the previous
section. Run <strong class="command">gv</strong> on your profile:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>gv -watch -orientation<span class="o">=</span>seascape FOO.ps
</pre></div>
</div>
<p>If you forget the <code class="docutils literal notranslate"><span class="pre">-watch</span></code> flag you can still select “Watch file” from
the “State” menu. Now each time you generate a new profile <code class="docutils literal notranslate"><span class="pre">FOO.ps</span></code>
the view will update automatically.</p>
<p>This can all be encapsulated in a little script:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/sh</span>
head -<span class="sb">`</span>fgrep -n END_SAMPLE FOO.hp <span class="p">|</span> tail -1 <span class="p">|</span> cut -d : -f <span class="m">1</span><span class="sb">`</span> FOO.hp <span class="se">\</span>
  <span class="p">|</span> hp2ps &gt; FOO.ps
gv -watch -orientation<span class="o">=</span>seascape FOO.ps <span class="p">&amp;</span>
<span class="k">while</span> <span class="o">[</span> <span class="m">1</span> <span class="o">]</span> <span class="p">;</span> <span class="k">do</span>
  sleep <span class="m">10</span> <span class="c1"># We generate a new profile every 10 seconds.</span>
  head -<span class="sb">`</span>fgrep -n END_SAMPLE FOO.hp <span class="p">|</span> tail -1 <span class="p">|</span> cut -d : -f <span class="m">1</span><span class="sb">`</span> FOO.hp <span class="se">\</span>
    <span class="p">|</span> hp2ps &gt; FOO.ps
<span class="k">done</span>
</pre></div>
</div>
<p>Occasionally <strong class="command">gv</strong> will choke as it tries to read an incomplete copy of
<code class="file docutils literal notranslate"><span class="pre">FOO.ps</span></code> (because <strong class="command">hp2ps</strong> is still running as an update occurs). A
slightly more complicated script works around this problem, by using the
fact that sending a SIGHUP to gv will cause it to re-read its input
file:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/sh</span>
head -<span class="sb">`</span>fgrep -n END_SAMPLE FOO.hp <span class="p">|</span> tail -1 <span class="p">|</span> cut -d : -f <span class="m">1</span><span class="sb">`</span> FOO.hp <span class="se">\</span>
  <span class="p">|</span> hp2ps &gt; FOO.ps
gv FOO.ps <span class="p">&amp;</span>
<span class="nv">gvpsnum</span><span class="o">=</span><span class="nv">$!</span>
<span class="k">while</span> <span class="o">[</span> <span class="m">1</span> <span class="o">]</span> <span class="p">;</span> <span class="k">do</span>
  sleep <span class="m">10</span>
  head -<span class="sb">`</span>fgrep -n END_SAMPLE FOO.hp <span class="p">|</span> tail -1 <span class="p">|</span> cut -d : -f <span class="m">1</span><span class="sb">`</span> FOO.hp <span class="se">\</span>
    <span class="p">|</span> hp2ps &gt; FOO.ps
  <span class="nb">kill</span> -HUP <span class="nv">$gvpsnum</span>
<span class="k">done</span>
</pre></div>
</div>
</section>
</section>
<section id="profiling-parallel-and-concurrent-programs">
<span id="prof-threaded"></span><h2><span class="section-number">8.6. </span>Profiling Parallel and Concurrent Programs<a class="headerlink" href="#profiling-parallel-and-concurrent-programs" title="Permalink to this heading">¶</a></h2>
<p>Combining <a class="reference internal" href="phases.html#ghc-flag-threaded"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-threaded</span></code></a> and <a class="reference internal" href="#ghc-flag-prof"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-prof</span></code></a> is perfectly fine, and
indeed it is possible to profile a program running on multiple processors with
the RTS <a class="reference internal" href="using-concurrent.html#rts-flag-N-x"><code class="xref std std-rts-flag docutils literal notranslate"><span class="pre">-N</span> <span class="pre">⟨x⟩</span></code></a> option. <a class="footnote-reference brackets" href="#id7" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a></p>
<p>Some caveats apply, however. In the current implementation, a profiled
program is likely to scale much less well than the unprofiled program,
because the profiling implementation uses some shared data structures
which require locking in the runtime system. Furthermore, the memory
allocation statistics collected by the profiled program are stored in
shared memory but <em>not</em> locked (for speed), which means that these
figures might be inaccurate for parallel programs.</p>
<p>We strongly recommend that you use <a class="reference internal" href="#ghc-flag-fno-prof-count-entries"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fno-prof-count-entries</span></code></a> when
compiling a program to be profiled on multiple cores, because the entry
counts are also stored in shared memory, and continuously updating them
on multiple cores is extremely slow.</p>
<p>We also recommend using
<a class="reference external" href="http://www.haskell.org/haskellwiki/ThreadScope">ThreadScope</a> for
profiling parallel programs; it offers a GUI for visualising parallel
execution, and is complementary to the time and space profiling features
provided with GHC.</p>
</section>
<section id="observing-code-coverage">
<span id="hpc"></span><h2><span class="section-number">8.7. </span>Observing Code Coverage<a class="headerlink" href="#observing-code-coverage" title="Permalink to this heading">¶</a></h2>
<p id="index-8">Code coverage tools allow a programmer to determine what parts of their
code have been actually executed, and which parts have never actually
been invoked. GHC has an option for generating instrumented code that
records code coverage as part of the Haskell Program Coverage (HPC)
toolkit, which is included with GHC. HPC tools can be used to render the
generated code coverage information into human understandable format.</p>
<p>Correctly instrumented code provides coverage information of two kinds:
source coverage and boolean-control coverage. Source coverage is the
extent to which every part of the program was used, measured at three
different levels: declarations (both top-level and local), alternatives
(among several equations or case branches) and expressions (at every
level). Boolean coverage is the extent to which each of the values True
and False is obtained in every syntactic boolean context (ie. guard,
condition, qualifier).</p>
<p>HPC displays both kinds of information in two primary ways: textual
reports with summary statistics (<code class="docutils literal notranslate"><span class="pre">hpc</span> <span class="pre">report</span></code>) and sources with color
mark-up (<code class="docutils literal notranslate"><span class="pre">hpc</span> <span class="pre">markup</span></code>). For boolean coverage, there are four possible
outcomes for each guard, condition or qualifier: both True and False
values occur; only True; only False; never evaluated. In hpc-markup
output, highlighting with a yellow background indicates a part of the
program that was never evaluated; a green background indicates an
always-True expression and a red background indicates an always-False
one.</p>
<section id="a-small-example-reciprocation">
<h3><span class="section-number">8.7.1. </span>A small example: Reciprocation<a class="headerlink" href="#a-small-example-reciprocation" title="Permalink to this heading">¶</a></h3>
<p>For an example we have a program, called <code class="file docutils literal notranslate"><span class="pre">Recip.hs</span></code>, which computes
exact decimal representations of reciprocals, with recurring parts
indicated in brackets.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">reciprocal</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">String</span><span class="p">,</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="w"></span>
<span class="nf">reciprocal</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="sc">&#39;0&#39;</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="sc">&#39;.&#39;</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">digits</span><span class="p">,</span><span class="w"> </span><span class="n">recur</span><span class="p">)</span><span class="w"></span>
<span class="w">             </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="ne">error</span><span class="w"></span>
<span class="w">              </span><span class="s">&quot;attempting to compute reciprocal of number &lt;= 1&quot;</span><span class="w"></span>
<span class="w">  </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="n">digits</span><span class="p">,</span><span class="w"> </span><span class="n">recur</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">divide</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="kt">[]</span><span class="w"></span>
<span class="nf">divide</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">String</span><span class="p">,</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="w"></span>
<span class="nf">divide</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">cs</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="p">`</span><span class="n">elem</span><span class="p">`</span><span class="w"> </span><span class="n">cs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="kt">[]</span><span class="p">,</span><span class="w"> </span><span class="n">position</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">cs</span><span class="p">)</span><span class="w"></span>
<span class="w">              </span><span class="o">|</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w">      </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">show</span><span class="w"> </span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">              </span><span class="o">|</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">0</span><span class="w">      </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">show</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">digits</span><span class="p">,</span><span class="w"> </span><span class="n">recur</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">`</span><span class="n">quotRem</span><span class="p">`</span><span class="w"> </span><span class="n">n</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="n">digits</span><span class="p">,</span><span class="w"> </span><span class="n">recur</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">divide</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="kt">:</span><span class="n">cs</span><span class="p">)</span><span class="w"></span>

<span class="nf">position</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">position</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">n</span><span class="o">==</span><span class="n">x</span><span class="w">      </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">                  </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">position</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">xs</span><span class="w"></span>

<span class="nf">showRecip</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="nf">showRecip</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="s">&quot;1/&quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="s">&quot; = &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"></span>
<span class="w">  </span><span class="kr">if</span><span class="w"> </span><span class="n">r</span><span class="o">==</span><span class="mi">0</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="n">take</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="s">&quot;(&quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">drop</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="s">&quot;)&quot;</span><span class="w"></span>
<span class="w">  </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">p</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">r</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">reciprocal</span><span class="w"> </span><span class="n">n</span><span class="w"></span>

<span class="nf">main</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">  </span><span class="n">number</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">readLn</span><span class="w"></span>
<span class="w">  </span><span class="n">putStrLn</span><span class="w"> </span><span class="p">(</span><span class="n">showRecip</span><span class="w"> </span><span class="n">number</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">main</span><span class="w"></span>
</pre></div>
</div>
<p>HPC instrumentation is enabled with the <a class="reference internal" href="#ghc-flag-fhpc"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fhpc</span></code></a> flag:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ ghc -fhpc Recip.hs
</pre></div>
</div>
<p>GHC creates a subdirectory <code class="docutils literal notranslate"><span class="pre">.hpc</span></code> in the current directory, and puts
HPC index (<code class="docutils literal notranslate"><span class="pre">.mix</span></code>) files in there, one for each module compiled. You
don’t need to worry about these files: they contain information needed
by the <code class="docutils literal notranslate"><span class="pre">hpc</span></code> tool to generate the coverage data for compiled modules
after the program is run.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ ./Recip
<span class="m">1</span>/3
<span class="o">=</span> <span class="m">0</span>.<span class="o">(</span><span class="m">3</span><span class="o">)</span>
</pre></div>
</div>
<p>Running the program generates a file with the <code class="docutils literal notranslate"><span class="pre">.tix</span></code> suffix, in this
case <code class="file docutils literal notranslate"><span class="pre">Recip.tix</span></code>, which contains the coverage data for this run of the
program. The program may be run multiple times (e.g. with different test
data), and the coverage data from the separate runs is accumulated in
the <code class="docutils literal notranslate"><span class="pre">.tix</span></code> file. To reset the coverage data and start again, just
remove the <code class="docutils literal notranslate"><span class="pre">.tix</span></code> file. You can control where the <code class="docutils literal notranslate"><span class="pre">.tix</span></code> file
is generated using the environment variable <span class="target" id="index-9"></span><a class="reference internal" href="#envvar-HPCTIXFILE"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">HPCTIXFILE</span></code></a>.</p>
<dl class="std envvar">
<dt class="sig sig-object std" id="envvar-HPCTIXFILE">
<span class="sig-name descname"><span class="pre">HPCTIXFILE</span></span><a class="headerlink" href="#envvar-HPCTIXFILE" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the HPC <code class="docutils literal notranslate"><span class="pre">.tix</span></code> file output path.</p>
</dd></dl>

<p>Having run the program, we can generate a textual summary of coverage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ hpc report Recip
 80% expressions used (81/101)
 12% boolean coverage (1/8)
      14% guards (1/7), 3 always True,
                        1 always False,
                        2 unevaluated
       0% &#39;if&#39; conditions (0/1), 1 always False
     100% qualifiers (0/0)
 55% alternatives used (5/9)
100% local declarations used (9/9)
100% top-level declarations used (5/5)
</pre></div>
</div>
<p>We can also generate a marked-up version of the source.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ hpc markup Recip
writing Recip.hs.html
</pre></div>
</div>
<p>This generates one file per Haskell module, and 4 index files,
<code class="file docutils literal notranslate"><span class="pre">hpc_index.html</span></code>, <code class="file docutils literal notranslate"><span class="pre">hpc_index_alt.html</span></code>, <code class="file docutils literal notranslate"><span class="pre">hpc_index_exp.html</span></code>,
<code class="file docutils literal notranslate"><span class="pre">hpc_index_fun.html</span></code>.</p>
</section>
<section id="options-for-instrumenting-code-for-coverage">
<h3><span class="section-number">8.7.2. </span>Options for instrumenting code for coverage<a class="headerlink" href="#options-for-instrumenting-code-for-coverage" title="Permalink to this heading">¶</a></h3>
<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-fhpc">
<span class="sig-name descname"><span class="pre">-fhpc</span></span><a class="headerlink" href="#ghc-flag-fhpc" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable code coverage for the current module or modules being
compiled.</p>
<p>Modules compiled with this option can be freely mixed with modules
compiled without it; indeed, most libraries will typically be
compiled without <a class="reference internal" href="#ghc-flag-fhpc"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fhpc</span></code></a>. When the program is run, coverage data
will only be generated for those modules that were compiled with
<a class="reference internal" href="#ghc-flag-fhpc"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fhpc</span></code></a>, and the <strong class="command">hpc</strong> tool will only show information about
those modules.</p>
</dd></dl>

</section>
<section id="the-hpc-toolkit">
<h3><span class="section-number">8.7.3. </span>The hpc toolkit<a class="headerlink" href="#the-hpc-toolkit" title="Permalink to this heading">¶</a></h3>
<p>The hpc command has several sub-commands:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ hpc
Usage: hpc COMMAND ...

Commands:
  help        Display help for hpc or a single command
Reporting Coverage:
  report      Output textual report about program coverage
  markup      Markup Haskell source with program coverage
Processing Coverage files:
  sum         Sum multiple .tix files in a single .tix file
  combine     Combine two .tix files in a single .tix file
  map         Map a function over a single .tix file
Coverage Overlays:
  overlay     Generate a .tix file from an overlay file
  draft       Generate draft overlay that provides 100% coverage
Others:
  show        Show .tix file in readable, verbose format
  version     Display version for hpc
</pre></div>
</div>
<p>In general, these options act on a <code class="docutils literal notranslate"><span class="pre">.tix</span></code> file after an instrumented
binary has generated it.</p>
<p>The hpc tool assumes you are in the top-level directory of the location
where you built your application, and the <code class="docutils literal notranslate"><span class="pre">.tix</span></code> file is in the same
top-level directory. You can use the flag <code class="docutils literal notranslate"><span class="pre">--srcdir</span></code> to use <code class="docutils literal notranslate"><span class="pre">hpc</span></code>
for any other directory, and use <code class="docutils literal notranslate"><span class="pre">--srcdir</span></code> multiple times to analyse
programs compiled from difference locations, as is typical for packages.</p>
<p>We now explain in more details the major modes of hpc.</p>
<section id="hpc-report">
<h4><span class="section-number">8.7.3.1. </span>hpc report<a class="headerlink" href="#hpc-report" title="Permalink to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">hpc</span> <span class="pre">report</span></code> gives a textual report of coverage. By default, all
modules and packages are considered in generating report, unless include
or exclude are used. The report is a summary unless the <code class="docutils literal notranslate"><span class="pre">--per-module</span></code>
flag is used. The <code class="docutils literal notranslate"><span class="pre">--xml-output</span></code> option allows for tools to use hpc to
glean coverage.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ hpc help report
Usage: hpc report [OPTION] .. &lt;TIX_FILE&gt; [&lt;MODULE&gt; [&lt;MODULE&gt; ..]]

Options:

    --per-module                  show module level detail
    --decl-list                   show unused decls
    --exclude=[PACKAGE:][MODULE]  exclude MODULE and/or PACKAGE
    --include=[PACKAGE:][MODULE]  include MODULE and/or PACKAGE
    --srcdir=DIR                  path to source directory of .hs files
                                  multi-use of srcdir possible
    --hpcdir=DIR                  append sub-directory that contains .mix files
                                  default .hpc [rarely used]
    --reset-hpcdirs               empty the list of hpcdir&#39;s
                                  [rarely used]
    --xml-output                  show output in XML
</pre></div>
</div>
</section>
<section id="hpc-markup">
<h4><span class="section-number">8.7.3.2. </span>hpc markup<a class="headerlink" href="#hpc-markup" title="Permalink to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">hpc</span> <span class="pre">markup</span></code> marks up source files into colored html.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ hpc help markup
Usage: hpc markup [OPTION] .. &lt;TIX_FILE&gt; [&lt;MODULE&gt; [&lt;MODULE&gt; ..]]

Options:

    --exclude=[PACKAGE:][MODULE]  exclude MODULE and/or PACKAGE
    --include=[PACKAGE:][MODULE]  include MODULE and/or PACKAGE
    --srcdir=DIR                  path to source directory of .hs files
                                  multi-use of srcdir possible
    --hpcdir=DIR                  append sub-directory that contains .mix files
                                  default .hpc [rarely used]
    --reset-hpcdirs               empty the list of hpcdir&#39;s
                                  [rarely used]
    --fun-entry-count             show top-level function entry counts
    --highlight-covered           highlight covered code, rather that code gaps
    --destdir=DIR                 path to write output to
</pre></div>
</div>
</section>
<section id="hpc-sum">
<h4><span class="section-number">8.7.3.3. </span>hpc sum<a class="headerlink" href="#hpc-sum" title="Permalink to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">hpc</span> <span class="pre">sum</span></code> adds together any number of <code class="docutils literal notranslate"><span class="pre">.tix</span></code> files into a single
<code class="docutils literal notranslate"><span class="pre">.tix</span></code> file. <code class="docutils literal notranslate"><span class="pre">hpc</span> <span class="pre">sum</span></code> does not change the original <code class="docutils literal notranslate"><span class="pre">.tix</span></code> file;
it generates a new <code class="docutils literal notranslate"><span class="pre">.tix</span></code> file.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ hpc help sum
Usage: hpc sum [OPTION] .. &lt;TIX_FILE&gt; [&lt;TIX_FILE&gt; [&lt;TIX_FILE&gt; ..]]
Sum multiple .tix files in a single .tix file

Options:

    --exclude=[PACKAGE:][MODULE]  exclude MODULE and/or PACKAGE
    --include=[PACKAGE:][MODULE]  include MODULE and/or PACKAGE
    --output=FILE                 output FILE
    --union                       use the union of the module namespace (default is intersection)
</pre></div>
</div>
</section>
<section id="hpc-combine">
<h4><span class="section-number">8.7.3.4. </span>hpc combine<a class="headerlink" href="#hpc-combine" title="Permalink to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">hpc</span> <span class="pre">combine</span></code> is the swiss army knife of <code class="docutils literal notranslate"><span class="pre">hpc</span></code>. It can be used to
take the difference between <code class="docutils literal notranslate"><span class="pre">.tix</span></code> files, to subtract one <code class="docutils literal notranslate"><span class="pre">.tix</span></code>
file from another, or to add two <code class="docutils literal notranslate"><span class="pre">.tix</span></code> files. hpc combine does not
change the original <code class="docutils literal notranslate"><span class="pre">.tix</span></code> file; it generates a new <code class="docutils literal notranslate"><span class="pre">.tix</span></code> file.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ hpc help combine
Usage: hpc combine [OPTION] .. &lt;TIX_FILE&gt; &lt;TIX_FILE&gt;
Combine two .tix files in a single .tix file

Options:

    --exclude=[PACKAGE:][MODULE]  exclude MODULE and/or PACKAGE
    --include=[PACKAGE:][MODULE]  include MODULE and/or PACKAGE
    --output=FILE                 output FILE
    --function=FUNCTION           combine .tix files with join function, default = ADD
                                  FUNCTION = ADD | DIFF | SUB
    --union                       use the union of the module namespace (default is intersection)
</pre></div>
</div>
</section>
<section id="hpc-map">
<h4><span class="section-number">8.7.3.5. </span>hpc map<a class="headerlink" href="#hpc-map" title="Permalink to this heading">¶</a></h4>
<p>hpc map inverts or zeros a <code class="docutils literal notranslate"><span class="pre">.tix</span></code> file. hpc map does not change the
original <code class="docutils literal notranslate"><span class="pre">.tix</span></code> file; it generates a new <code class="docutils literal notranslate"><span class="pre">.tix</span></code> file.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ hpc help map
Usage: hpc map [OPTION] .. &lt;TIX_FILE&gt;
Map a function over a single .tix file

Options:

    --exclude=[PACKAGE:][MODULE]  exclude MODULE and/or PACKAGE
    --include=[PACKAGE:][MODULE]  include MODULE and/or PACKAGE
    --output=FILE                 output FILE
    --function=FUNCTION           apply function to .tix files, default = ID
                                  FUNCTION = ID | INV | ZERO
    --union                       use the union of the module namespace (default is intersection)
</pre></div>
</div>
</section>
<section id="hpc-overlay-and-hpc-draft">
<h4><span class="section-number">8.7.3.6. </span>hpc overlay and hpc draft<a class="headerlink" href="#hpc-overlay-and-hpc-draft" title="Permalink to this heading">¶</a></h4>
<p>Overlays are an experimental feature of HPC, a textual description of
coverage. hpc draft is used to generate a draft overlay from a .tix
file, and hpc overlay generates a .tix files from an overlay.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>% hpc help overlay
Usage: hpc overlay [OPTION] .. &lt;OVERLAY_FILE&gt; [&lt;OVERLAY_FILE&gt; [...]]

Options:

    --srcdir=DIR   path to source directory of .hs files
                   multi-use of srcdir possible
    --hpcdir=DIR                  append sub-directory that contains .mix files
                                  default .hpc [rarely used]
    --reset-hpcdirs               empty the list of hpcdir&#39;s
                                  [rarely used]
    --output=FILE  output FILE
% hpc help draft
Usage: hpc draft [OPTION] .. &lt;TIX_FILE&gt;

Options:

    --exclude=[PACKAGE:][MODULE]  exclude MODULE and/or PACKAGE
    --include=[PACKAGE:][MODULE]  include MODULE and/or PACKAGE
    --srcdir=DIR                  path to source directory of .hs files
                                  multi-use of srcdir possible
    --hpcdir=DIR                  append sub-directory that contains .mix files
                                  default .hpc [rarely used]
    --reset-hpcdirs               empty the list of hpcdir&#39;s
                                  [rarely used]
    --output=FILE                 output FILE
</pre></div>
</div>
</section>
</section>
<section id="caveats-and-shortcomings-of-haskell-program-coverage">
<h3><span class="section-number">8.7.4. </span>Caveats and Shortcomings of Haskell Program Coverage<a class="headerlink" href="#caveats-and-shortcomings-of-haskell-program-coverage" title="Permalink to this heading">¶</a></h3>
<p>HPC does not attempt to lock the <code class="docutils literal notranslate"><span class="pre">.tix</span></code> file, so multiple concurrently
running binaries in the same directory will exhibit a race condition.
At compile time, there is no way to change the name of the <code class="docutils literal notranslate"><span class="pre">.tix</span></code> file generated;
at runtime, the name of the generated <code class="docutils literal notranslate"><span class="pre">.tix</span></code> file can be changed
using <span class="target" id="index-10"></span><a class="reference internal" href="#envvar-HPCTIXFILE"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">HPCTIXFILE</span></code></a>; the name of the <code class="docutils literal notranslate"><span class="pre">.tix</span></code> file
will also change if you rename the binary.  HPC does not work with GHCi.</p>
</section>
</section>
<section id="using-ticky-ticky-profiling-for-implementors">
<span id="ticky-ticky"></span><h2><span class="section-number">8.8. </span>Using “ticky-ticky” profiling (for implementors)<a class="headerlink" href="#using-ticky-ticky-profiling-for-implementors" title="Permalink to this heading">¶</a></h2>
<span class="target" id="index-11"></span><dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-ticky">
<span class="sig-name descname"><span class="pre">-ticky</span></span><a class="headerlink" href="#ghc-flag-ticky" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable ticky-ticky profiling. By default this only tracks the allocations
<em>by</em> each closure type. See <a class="reference internal" href="#ghc-flag-ticky-allocd"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-ticky-allocd</span></code></a> to keep track of
allocations <em>of</em> each closure type as well.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-ticky-allocd">
<span class="sig-name descname"><span class="pre">-ticky-allocd</span></span><a class="headerlink" href="#ghc-flag-ticky-allocd" title="Permalink to this definition">¶</a></dt>
<dd><p>Keep track of how much each closure type is allocated.</p>
</dd></dl>

<dl class="std ghc-flag">
<dt class="sig sig-object std" id="ghc-flag-ticky-dyn-thunk">
<span class="sig-name descname"><span class="pre">-ticky-dyn-thunk</span></span><a class="headerlink" href="#ghc-flag-ticky-dyn-thunk" title="Permalink to this definition">¶</a></dt>
<dd><p>Track allocations of dynamic thunks.</p>
</dd></dl>

<p>Because ticky-ticky profiling requires a certain familiarity with GHC
internals, we have moved the documentation to the GHC developers wiki.
Take a look at its
<a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/commentary/profiling">overview of the profiling options</a>,
which includes a link to the ticky-ticky profiling page.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id5" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">1</a><span class="fn-bracket">]</span></span>
<p><a class="reference internal" href="#ghc-flag-fprof-auto"><code class="xref std std-ghc-flag docutils literal notranslate"><span class="pre">-fprof-auto</span></code></a> was known as <code class="docutils literal notranslate"><span class="pre">-auto-all</span></code> prior to
GHC 7.4.1.</p>
</aside>
<aside class="footnote brackets" id="id6" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">2</a><span class="fn-bracket">]</span></span>
<p>Note that this policy has changed slightly in GHC 7.4.1 relative to
earlier versions, and may yet change further, feedback is welcome.</p>
</aside>
<aside class="footnote brackets" id="id7" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">3</a><span class="fn-bracket">]</span></span>
<p>This feature was added in GHC 7.4.1.</p>
</aside>
</aside>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="debug-info.html" class="btn btn-neutral float-right" title="9. Debugging compiled programs" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="extending_ghc.html" class="btn btn-neutral float-left" title="7. Extending and using GHC as a Library" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>