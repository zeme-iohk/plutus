

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6.4.7. Declaring data types with explicit constructor signatures &mdash; Glasgow Haskell Compiler 9.2.5 User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 9.2.5 User&#39;s Guide"
          href="../_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6.4.8. Generalised Algebraic Data Types (GADTs)" href="gadt.html" />
    <link rel="prev" title="6.4.6. Existentially quantified data constructors" href="existential_quantification.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Glasgow Haskell Compiler
          

          
          </a>

          
            
            
              <div class="version">
                9.2.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">2. Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ghci.html">3. Using GHCi</a></li>
<li class="toctree-l1"><a class="reference internal" href="../runghc.html">4. Using runghc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">5. Using GHC</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../exts.html">6. Language extensions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">6.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="syntax.html">6.2. Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="import_export.html">6.3. Import and export</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="types.html">6.4. Types</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="nullary_types.html">6.4.1. Data types with no constructors</a></li>
<li class="toctree-l3"><a class="reference internal" href="datatype_contexts.html">6.4.2. Data type contexts</a></li>
<li class="toctree-l3"><a class="reference internal" href="infix_tycons.html">6.4.3. Infix type constructors, classes, and type variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="type_operators.html">6.4.4. Type operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="liberal_type_synonyms.html">6.4.5. Liberalised type synonyms</a></li>
<li class="toctree-l3"><a class="reference internal" href="existential_quantification.html">6.4.6. Existentially quantified data constructors</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">6.4.7. Declaring data types with explicit constructor signatures</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#formal-syntax-for-gadts">6.4.7.1. Formal syntax for GADTs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gadt-syntax-odds-and-ends">6.4.7.2. GADT syntax odds and ends</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="gadt.html">6.4.8. Generalised Algebraic Data Types (GADTs)</a></li>
<li class="toctree-l3"><a class="reference internal" href="type_families.html">6.4.9. Type families</a></li>
<li class="toctree-l3"><a class="reference internal" href="data_kinds.html">6.4.10. Datatype promotion</a></li>
<li class="toctree-l3"><a class="reference internal" href="poly_kinds.html">6.4.11. Kind polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="levity_polymorphism.html">6.4.12. Levity polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="type_literals.html">6.4.13. Type-Level Literals</a></li>
<li class="toctree-l3"><a class="reference internal" href="type_applications.html">6.4.14. Visible type application</a></li>
<li class="toctree-l3"><a class="reference internal" href="rank_polymorphism.html">6.4.15. Arbitrary-rank polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="impredicative_types.html">6.4.16. Impredicative polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="linear_types.html">6.4.17. Linear types</a></li>
<li class="toctree-l3"><a class="reference internal" href="type_errors.html">6.4.18. Custom compile-time errors</a></li>
<li class="toctree-l3"><a class="reference internal" href="defer_type_errors.html">6.4.19. Deferring type errors to runtime</a></li>
<li class="toctree-l3"><a class="reference internal" href="roles.html">6.4.20. Roles</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="records.html">6.5. Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="deriving.html">6.6. Deriving mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="patterns.html">6.7. Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="typeclasses.html">6.8. Class and instances declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="literals.html">6.9. Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="constraints.html">6.10. Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="type_signatures.html">6.11. Type signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="bindings.html">6.12. Bindings and generalisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="template_haskell.html">6.13. Template Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="strict.html">6.14. Bang patterns and Strict Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel.html">6.15. Parallel and Concurrent</a></li>
<li class="toctree-l2"><a class="reference internal" href="primitives.html">6.16. Unboxed types and primitive operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffi.html">6.17. Foreign function interface (FFI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="safe_haskell.html">6.18. Safe Haskell</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc.html">6.19. Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="pragmas.html">6.20. Pragmas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../extending_ghc.html">7. Extending and using GHC as a Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profiling.html">8. Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debug-info.html">9. Debugging compiled programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gone_wrong.html">10. What to do when something goes wrong</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hints.html">11. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utils.html">12. Other Haskell utility programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../win32-dlls.html">13. Running GHC on Win32 systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bugs.html">14. Known bugs and infelicities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventlog-formats.html">15. Eventlog encodings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../editing-guide.html">16. Care and feeding of your GHC User’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Glasgow Haskell Compiler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../exts.html"><span class="section-number">6. </span>Language extensions</a> &raquo;</li>
        
          <li><a href="types.html"><span class="section-number">6.4. </span>Types</a> &raquo;</li>
        
      <li><span class="section-number">6.4.7. </span>Declaring data types with explicit constructor signatures</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/exts/gadt_syntax.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="declaring-data-types-with-explicit-constructor-signatures">
<span id="gadt-style"></span><h1><span class="section-number">6.4.7. </span>Declaring data types with explicit constructor signatures<a class="headerlink" href="#declaring-data-types-with-explicit-constructor-signatures" title="Permalink to this heading">¶</a></h1>
<dl class="std extension">
<dt class="sig sig-object std" id="extension-GADTSyntax">
<span id="ghc-flag--XGADTSyntax"></span><span id="extension-NoGADTSyntax"></span><span class="sig-name descname"><span class="pre">GADTSyntax</span></span><a class="headerlink" href="#extension-GADTSyntax" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Since<span class="colon">:</span></dt>
<dd class="field-odd"><p>7.2.1</p>
</dd>
</dl>
<p>Allow the use of GADT syntax in data type definitions (but not GADTs
themselves; for this see <a class="reference internal" href="gadt.html#extension-GADTs"><code class="xref std std-extension docutils literal notranslate"><span class="pre">GADTs</span></code></a>)</p>
</dd></dl>

<p>When the <code class="docutils literal notranslate"><span class="pre">GADTSyntax</span></code> extension is enabled, GHC allows you to declare
an algebraic data type by giving the type signatures of constructors
explicitly. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="kt">Nothing</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">    </span><span class="kt">Just</span><span class="w">    </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>The form is called a “GADT-style declaration” because Generalised
Algebraic Data Types, described in <a class="reference internal" href="gadt.html#gadt"><span class="std std-ref">Generalised Algebraic Data Types (GADTs)</span></a>, can only be declared
using this form.</p>
<p>Notice that GADT-style syntax generalises existential types
(<a class="reference internal" href="existential_quantification.html#existential-quantification"><span class="std std-ref">Existentially quantified data constructors</span></a>). For example, these two declarations
are equivalent:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="w"> </span><span class="kt">MkFoo</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="p">)</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Foo&#39;</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">MKFoo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="ow">-&gt;</span><span class="kt">Bool</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Foo&#39;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Any data type that can be declared in standard Haskell 98 syntax can
also be declared using GADT-style syntax. The choice is largely
stylistic, but GADT-style declarations differ in one important respect:
they treat class constraints on the data constructors differently.
Specifically, if the constructor is given a type-class context, that
context is made available by pattern matching. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Set</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">MkSet</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Set</span><span class="w"> </span><span class="n">a</span><span class="w"></span>

<span class="nf">makeSet</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Set</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">makeSet</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkSet</span><span class="w"> </span><span class="p">(</span><span class="n">nub</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w"></span>

<span class="nf">insert</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Set</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Set</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">insert</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="kt">MkSet</span><span class="w"> </span><span class="n">as</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">`</span><span class="n">elem</span><span class="p">`</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkSet</span><span class="w"> </span><span class="n">as</span><span class="w"></span>
<span class="w">                    </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w">   </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkSet</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="kt">:</span><span class="n">as</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>A use of <code class="docutils literal notranslate"><span class="pre">MkSet</span></code> as a constructor (e.g. in the definition of
<code class="docutils literal notranslate"><span class="pre">makeSet</span></code>) gives rise to a <code class="docutils literal notranslate"><span class="pre">(Eq</span> <span class="pre">a)</span></code> constraint, as you would expect.
The new feature is that pattern-matching on <code class="docutils literal notranslate"><span class="pre">MkSet</span></code> (as in the
definition of <code class="docutils literal notranslate"><span class="pre">insert</span></code>) makes <em>available</em> an <code class="docutils literal notranslate"><span class="pre">(Eq</span> <span class="pre">a)</span></code> context. In
implementation terms, the <code class="docutils literal notranslate"><span class="pre">MkSet</span></code> constructor has a hidden field that
stores the <code class="docutils literal notranslate"><span class="pre">(Eq</span> <span class="pre">a)</span></code> dictionary that is passed to <code class="docutils literal notranslate"><span class="pre">MkSet</span></code>; so when
pattern-matching that dictionary becomes available for the right-hand
side of the match. In the example, the equality dictionary is used to
satisfy the equality constraint generated by the call to <code class="docutils literal notranslate"><span class="pre">elem</span></code>, so
that the type of <code class="docutils literal notranslate"><span class="pre">insert</span></code> itself has no <code class="docutils literal notranslate"><span class="pre">Eq</span></code> constraint.</p>
<p>For example, one possible application is to reify dictionaries:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">NumInst</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">MkNumInst</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Num</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">NumInst</span><span class="w"> </span><span class="n">a</span><span class="w"></span>

<span class="nf">intInst</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">NumInst</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">intInst</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkNumInst</span><span class="w"></span>

<span class="nf">plus</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">NumInst</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">plus</span><span class="w"> </span><span class="kt">MkNumInst</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">q</span><span class="w"></span>
</pre></div>
</div>
<p>Here, a value of type <code class="docutils literal notranslate"><span class="pre">NumInst</span> <span class="pre">a</span></code> is equivalent to an explicit
<code class="docutils literal notranslate"><span class="pre">(Num</span> <span class="pre">a)</span></code> dictionary.</p>
<p>All this applies to constructors declared using the syntax of
<a class="reference internal" href="existential_quantification.html#existential-with-context"><span class="std std-ref">Existentials and type classes</span></a>. For example, the <code class="docutils literal notranslate"><span class="pre">NumInst</span></code> data type
above could equivalently be declared like this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">NumInst</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">   </span><span class="ow">=</span><span class="w"> </span><span class="kt">Num</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">MkNumInst</span><span class="w"> </span><span class="p">(</span><span class="kt">NumInst</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Notice that, unlike the situation when declaring an existential, there
is no <code class="docutils literal notranslate"><span class="pre">forall</span></code>, because the <code class="docutils literal notranslate"><span class="pre">Num</span></code> constrains the data type’s
universally quantified type variable <code class="docutils literal notranslate"><span class="pre">a</span></code>. A constructor may have both
universal and existential type variables: for example, the following two
declarations are equivalent:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">T1</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">b</span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="kt">Num</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">MkT1</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">T2</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w"> </span><span class="kt">MkT2</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Num</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">T2</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>All this behaviour contrasts with Haskell 98’s peculiar treatment of
contexts on a data type declaration (Section 4.2.1 of the Haskell 98
Report). In Haskell 98 the definition</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Set&#39;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MkSet&#39;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>gives <code class="docutils literal notranslate"><span class="pre">MkSet'</span></code> the same type as <code class="docutils literal notranslate"><span class="pre">MkSet</span></code> above. But instead of
<em>making available</em> an <code class="docutils literal notranslate"><span class="pre">(Eq</span> <span class="pre">a)</span></code> constraint, pattern-matching on
<code class="docutils literal notranslate"><span class="pre">MkSet'</span></code> <em>requires</em> an <code class="docutils literal notranslate"><span class="pre">(Eq</span> <span class="pre">a)</span></code> constraint! GHC faithfully
implements this behaviour, odd though it is. But for GADT-style
declarations, GHC’s behaviour is much more useful, as well as much more
intuitive.</p>
<section id="formal-syntax-for-gadts">
<span id="formal-gadt-syntax"></span><h2><span class="section-number">6.4.7.1. </span>Formal syntax for GADTs<a class="headerlink" href="#formal-syntax-for-gadts" title="Permalink to this heading">¶</a></h2>
<p>To make more precise what is and what is not permitted inside of a GADT-style
constructor, we provide a BNF-style grammar for GADT below. Note that this
grammar is subject to change in the future.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>gadt_con ::= conids &#39;::&#39; opt_forall opt_ctxt gadt_body

conids ::= conid
        |  conid &#39;,&#39; conids

opt_forall ::= &lt;empty&gt;
            |  &#39;forall&#39; tv_bndrs &#39;.&#39;

tv_bndrs ::= &lt;empty&gt;
          |  tv_bndr tv_bndrs

tv_bndr ::= tyvar
         |  &#39;(&#39; tyvar &#39;::&#39; ctype &#39;)&#39;

opt_ctxt ::= &lt;empty&gt;
          |  btype &#39;=&gt;&#39;
          |  &#39;(&#39; ctxt &#39;)&#39; &#39;=&gt;&#39;

ctxt ::= ctype
      |  ctype &#39;,&#39; ctxt

gadt_body ::= prefix_gadt_body
           |  record_gadt_body

prefix_gadt_body ::= &#39;(&#39; prefix_gadt_body &#39;)&#39;
                  |  return_type
                  |  opt_unpack btype &#39;-&gt;&#39; prefix_gadt_body

record_gadt_body ::= &#39;{&#39; fieldtypes &#39;}&#39; &#39;-&gt;&#39; return_type

fieldtypes ::= &lt;empty&gt;
            |  fieldnames &#39;::&#39; opt_unpack ctype
            |  fieldnames &#39;::&#39; opt_unpack ctype &#39;,&#39; fieldtypes

fieldnames ::= fieldname
            |  fieldname &#39;,&#39; fieldnames

opt_unpack ::= opt_bang
            :  {-# UNPACK #-} opt_bang
            |  {-# NOUNPACK #-} opt_bang

opt_bang ::= &lt;empty&gt;
          |  &#39;!&#39;
          |  &#39;~&#39;
</pre></div>
</div>
<p>Where:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">btype</span></code> is a type that is not allowed to have an outermost
<code class="docutils literal notranslate"><span class="pre">forall</span></code>/<code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> unless it is surrounded by parentheses. For example,
<code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">a.</span> <span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">Eq</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a</span></code> are not legal <code class="docutils literal notranslate"><span class="pre">btype</span></code>s, but
<code class="docutils literal notranslate"><span class="pre">(forall</span> <span class="pre">a.</span> <span class="pre">a)</span></code> and <code class="docutils literal notranslate"><span class="pre">(Eq</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a)</span></code> are legal.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ctype</span></code> is a <code class="docutils literal notranslate"><span class="pre">btype</span></code> that has no restrictions on an outermost
<code class="docutils literal notranslate"><span class="pre">forall</span></code>/<code class="docutils literal notranslate"><span class="pre">=&gt;</span></code>, so <code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">a.</span> <span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">Eq</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a</span></code> are legal <code class="docutils literal notranslate"><span class="pre">ctype</span></code>s.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">return_type</span></code> is a type that is not allowed to have <code class="docutils literal notranslate"><span class="pre">forall</span></code>s, <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code>s,
or <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code>s.</p></li>
</ul>
<p>This is a simplified grammar that does not fully delve into all of the
implementation details of GHC’s parser (such as the placement of Haddock
comments), but it is sufficient to attain an understanding of what is
syntactically allowed. Some further various observations about this grammar:</p>
<ul>
<li><p>GADT constructor types are currently not permitted to have nested <code class="docutils literal notranslate"><span class="pre">forall</span></code>s
or <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code>s. (e.g., something like <code class="docutils literal notranslate"><span class="pre">MkT</span> <span class="pre">::</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">forall</span> <span class="pre">a.</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">T</span></code> would be
rejected.) As a result, <code class="docutils literal notranslate"><span class="pre">gadt_sig</span></code> puts all of its quantification and
constraints up front with <code class="docutils literal notranslate"><span class="pre">opt_forall</span></code> and <code class="docutils literal notranslate"><span class="pre">opt_context</span></code>. Note that
higher-rank <code class="docutils literal notranslate"><span class="pre">forall</span></code>s and <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code>s are only permitted if they do not appear
directly to the right of a function arrow in a <cite>prefix_gadt_body</cite>. (e.g.,
something like <code class="docutils literal notranslate"><span class="pre">MkS</span> <span class="pre">::</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">(forall</span> <span class="pre">a.</span> <span class="pre">a)</span> <span class="pre">-&gt;</span> <span class="pre">S</span></code> is allowed, since
parentheses separate the <code class="docutils literal notranslate"><span class="pre">forall</span></code> from the <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code>.)</p></li>
<li><p>Furthermore, GADT constructors do not permit outermost parentheses that
surround the <code class="docutils literal notranslate"><span class="pre">opt_forall</span></code> or <code class="docutils literal notranslate"><span class="pre">opt_ctxt</span></code>, if at least one of them are
used. For example, <code class="docutils literal notranslate"><span class="pre">MkU</span> <span class="pre">::</span> <span class="pre">(forall</span> <span class="pre">a.</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">U)</span></code> would be rejected, since
it would treat the <code class="docutils literal notranslate"><span class="pre">forall</span></code> as being nested.</p>
<p>Note that it is acceptable to use parentheses in a <code class="docutils literal notranslate"><span class="pre">prefix_gadt_body</span></code>.
For instance, <code class="docutils literal notranslate"><span class="pre">MkV1</span> <span class="pre">::</span> <span class="pre">forall</span> <span class="pre">a.</span> <span class="pre">(a)</span> <span class="pre">-&gt;</span> <span class="pre">(V1)</span></code> is acceptable, as is
<code class="docutils literal notranslate"><span class="pre">MkV2</span> <span class="pre">::</span> <span class="pre">forall</span> <span class="pre">a.</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">V2)</span></code>.</p>
</li>
<li><p>The function arrows in a <code class="docutils literal notranslate"><span class="pre">prefix_gadt_body</span></code>, as well as the function
arrow in a <code class="docutils literal notranslate"><span class="pre">record_gadt_body</span></code>, are required to be used infix. For
example, <code class="docutils literal notranslate"><span class="pre">MkA</span> <span class="pre">::</span> <span class="pre">(-&gt;)</span> <span class="pre">Int</span> <span class="pre">A</span></code> would be rejected.</p></li>
<li><p>GHC uses the function arrows in a <code class="docutils literal notranslate"><span class="pre">prefix_gadt_body</span></code> and
<code class="docutils literal notranslate"><span class="pre">prefix_gadt_body</span></code> to syntactically demarcate the function and result
types. Note that GHC does not attempt to be clever about looking through
type synonyms here. If you attempt to do this, for instance:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">B</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">B</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">MkB</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">C</span><span class="w"></span>
</pre></div>
</div>
<p>Then GHC will interpret the return type of <code class="docutils literal notranslate"><span class="pre">MkB</span></code> to be <code class="docutils literal notranslate"><span class="pre">C</span></code>, and since
GHC requires that the return type must be headed by <code class="docutils literal notranslate"><span class="pre">B</span></code>, this will be
rejected. On the other hand, it is acceptable to use type synonyms within
the argument and result types themselves, so the following is permitted:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kt">B1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kt">B2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">B</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">B</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">MkB</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">B1</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">B2</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>GHC will accept any combination of <code class="docutils literal notranslate"><span class="pre">!</span></code>/<code class="docutils literal notranslate"><span class="pre">~</span></code> and
<code class="docutils literal notranslate"><span class="pre">{-#</span> <span class="pre">UNPACK</span> <span class="pre">#-}</span></code>/<code class="docutils literal notranslate"><span class="pre">{-#</span> <span class="pre">NOUNPACK</span> <span class="pre">#-}</span></code>, although GHC will ignore some
combinations. For example, GHC will produce a warning if you write
<code class="docutils literal notranslate"><span class="pre">{-#</span> <span class="pre">UNPACK</span> <span class="pre">#-}</span> <span class="pre">~Int</span></code> and proceed as if you had written <code class="docutils literal notranslate"><span class="pre">Int</span></code>.</p></li>
</ul>
</section>
<section id="gadt-syntax-odds-and-ends">
<h2><span class="section-number">6.4.7.2. </span>GADT syntax odds and ends<a class="headerlink" href="#gadt-syntax-odds-and-ends" title="Permalink to this heading">¶</a></h2>
<p>The rest of this section gives further details about GADT-style data
type declarations.</p>
<ul>
<li><p>The result type of each data constructor must begin with the type
constructor being defined. If the result type of all constructors has
the form <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">a1</span> <span class="pre">...</span> <span class="pre">an</span></code>, where <code class="docutils literal notranslate"><span class="pre">a1</span> <span class="pre">...</span> <span class="pre">an</span></code> are distinct type
variables, then the data type is <em>ordinary</em>; otherwise is a
<em>generalised</em> data type (<a class="reference internal" href="gadt.html#gadt"><span class="std std-ref">Generalised Algebraic Data Types (GADTs)</span></a>).</p></li>
<li><p>As with other type signatures, you can give a single signature for
several data constructors. In this example we give a single signature
for <code class="docutils literal notranslate"><span class="pre">T1</span></code> and <code class="docutils literal notranslate"><span class="pre">T2</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">T1</span><span class="p">,</span><span class="kt">T2</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">  </span><span class="kt">T3</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>The type signature of each constructor is independent, and is
implicitly universally quantified as usual. In particular, the type
variable(s) in the “<code class="docutils literal notranslate"><span class="pre">data</span> <span class="pre">T</span> <span class="pre">a</span> <span class="pre">where</span></code>” header have no scope, and
different constructors may have different universally-quantified type
variables:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w">        </span><span class="c1">-- The &#39;a&#39; has no scope</span><span class="w"></span>
<span class="w">  </span><span class="kt">T1</span><span class="p">,</span><span class="kt">T2</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">b</span><span class="w">   </span><span class="c1">-- Means forall b. b -&gt; T b</span><span class="w"></span>
<span class="w">  </span><span class="kt">T3</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w">           </span><span class="c1">-- Means forall a. T a</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>A constructor signature may mention type class constraints, which can
differ for different constructors. For example, this is fine:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">T1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="w">  </span><span class="kt">T2</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Show</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="kt">Ix</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
</pre></div>
</div>
<p>When pattern matching, these constraints are made available to
discharge constraints in the body of the match. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="p">(</span><span class="kt">T1</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="o">==</span><span class="n">y</span><span class="w">      </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;yes&quot;</span><span class="w"></span>
<span class="w">           </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;no&quot;</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="p">(</span><span class="kt">T2</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w">             </span><span class="ow">=</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">f</span></code> is not overloaded; the <code class="docutils literal notranslate"><span class="pre">Eq</span></code> constraint arising from
the use of <code class="docutils literal notranslate"><span class="pre">==</span></code> is discharged by the pattern match on <code class="docutils literal notranslate"><span class="pre">T1</span></code> and
similarly the <code class="docutils literal notranslate"><span class="pre">Show</span></code> constraint arising from the use of <code class="docutils literal notranslate"><span class="pre">show</span></code>.</p>
</li>
<li><p>Unlike a Haskell-98-style data type declaration, the type variable(s)
in the “<code class="docutils literal notranslate"><span class="pre">data</span> <span class="pre">Set</span> <span class="pre">a</span> <span class="pre">where</span></code>” header have no scope. Indeed, one can
write a kind signature instead:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Set</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>or even a mixture of the two:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Bar</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>The type variables (if given) may be explicitly kinded, so we could
also write the header for <code class="docutils literal notranslate"><span class="pre">Foo</span></code> like this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Bar</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Type</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>You can use strictness annotations, in the obvious places in the
constructor type:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Term</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="kt">Lit</span><span class="w">    </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Term</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="w">    </span><span class="kt">If</span><span class="w">     </span><span class="ow">::</span><span class="w"> </span><span class="kt">Term</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Term</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Term</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Term</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">    </span><span class="kt">Pair</span><span class="w">   </span><span class="ow">::</span><span class="w"> </span><span class="kt">Term</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Term</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Term</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>You can use a <code class="docutils literal notranslate"><span class="pre">deriving</span></code> clause on a GADT-style data type
declaration. For example, these two declarations are equivalent</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Maybe1</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">Nothing1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Maybe1</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">Just1</span><span class="w">    </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Maybe1</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="kr">deriving</span><span class="p">(</span><span class="w"> </span><span class="kt">Eq</span><span class="p">,</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="p">)</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Maybe2</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Nothing2</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Just2</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">     </span><span class="kr">deriving</span><span class="p">(</span><span class="w"> </span><span class="kt">Eq</span><span class="p">,</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>The type signature may have quantified type variables that do not
appear in the result type:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">   </span><span class="kt">MkFoo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="ow">-&gt;</span><span class="kt">Bool</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Foo</span><span class="w"></span>
<span class="w">   </span><span class="kt">Nil</span><span class="w">   </span><span class="ow">::</span><span class="w"> </span><span class="kt">Foo</span><span class="w"></span>
</pre></div>
</div>
<p>Here the type variable <code class="docutils literal notranslate"><span class="pre">a</span></code> does not appear in the result type of
either constructor. Although it is universally quantified in the type
of the constructor, such a type variable is often called
“existential”. Indeed, the above declaration declares precisely the
same type as the <code class="docutils literal notranslate"><span class="pre">data</span> <span class="pre">Foo</span></code> in <a class="reference internal" href="existential_quantification.html#existential-quantification"><span class="std std-ref">Existentially quantified data constructors</span></a>.</p>
<p>The type may contain a class context too, of course:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Showable</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="kt">MkShowable</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Show</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Showable</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>You can use record syntax on a GADT-style data type declaration:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Person</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="kt">Adult</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">String</span><span class="p">,</span><span class="w"> </span><span class="n">children</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Person</span><span class="p">]</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Person</span><span class="w"></span>
<span class="w">    </span><span class="kt">Child</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Show</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="kt">String</span><span class="p">,</span><span class="w"> </span><span class="n">funny</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Person</span><span class="w"></span>
</pre></div>
</div>
<p>As usual, for every constructor that has a field <code class="docutils literal notranslate"><span class="pre">f</span></code>, the type of
field <code class="docutils literal notranslate"><span class="pre">f</span></code> must be the same (modulo alpha conversion). The <code class="docutils literal notranslate"><span class="pre">Child</span></code>
constructor above shows that the signature may have a context,
existentially-quantified variables, and strictness annotations, just
as in the non-record case. (NB: the “type” that follows the
double-colon is not really a type, because of the record syntax and
strictness annotations. A “type” of this form can appear only in a
constructor signature.)</p>
</li>
<li><p>Record updates are allowed with GADT-style declarations, only fields
that have the following property: the type of the field mentions no
existential type variables.</p></li>
<li><p>As in the case of existentials declared using the Haskell-98-like
record syntax (<a class="reference internal" href="existential_quantification.html#existential-records"><span class="std std-ref">Record Constructors</span></a>), record-selector functions
are generated only for those fields that have well-typed selectors.
Here is the example of that section, in GADT-style syntax:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Counter</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="kt">NewCounter</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">_this</span><span class="w">    </span><span class="ow">::</span><span class="w"> </span><span class="n">self</span><span class="w"></span>
<span class="w">                  </span><span class="p">,</span><span class="w"> </span><span class="n">_inc</span><span class="w">     </span><span class="ow">::</span><span class="w"> </span><span class="n">self</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">self</span><span class="w"></span>
<span class="w">                  </span><span class="p">,</span><span class="w"> </span><span class="n">_display</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">self</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="w">                  </span><span class="p">,</span><span class="w"> </span><span class="n">tag</span><span class="w">      </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">                  </span><span class="p">}</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Counter</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>As before, only one selector function is generated here, that for
<code class="docutils literal notranslate"><span class="pre">tag</span></code>. Nevertheless, you can still use all the field names in
pattern matching and record construction.</p>
</li>
<li><p>In a GADT-style data type declaration there is no obvious way to
specify that a data constructor should be infix, which makes a
difference if you derive <code class="docutils literal notranslate"><span class="pre">Show</span></code> for the type. (Data constructors
declared infix are displayed infix by the derived <code class="docutils literal notranslate"><span class="pre">show</span></code>.) So GHC
implements the following design: a data constructor declared in a
GADT-style data type declaration is displayed infix by <code class="docutils literal notranslate"><span class="pre">Show</span></code> iff
(a) it is an operator symbol, (b) it has two arguments, (c) it has a
programmer-supplied fixity declaration. For example</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">infix</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="p">(</span><span class="kt">:--:</span><span class="p">)</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="kt">:--:</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
</pre></div>
</div>
</li>
</ul>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="gadt.html" class="btn btn-neutral float-right" title="6.4.8. Generalised Algebraic Data Types (GADTs)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="existential_quantification.html" class="btn btn-neutral float-left" title="6.4.6. Existentially quantified data constructors" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, GHC Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>