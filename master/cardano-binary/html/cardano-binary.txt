-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Binary serialization for Cardano
--   
--   This package includes the binary serialization format for Cardano
@package cardano-binary
@version 1.6.0.0

module Cardano.Binary
class Typeable a => FromCBOR a
fromCBOR :: FromCBOR a => Decoder s a
label :: FromCBOR a => Proxy a -> Text
data DecoderError
DecoderErrorCanonicityViolation :: Text -> DecoderError

-- | Custom decoding error, usually due to some validation failure
DecoderErrorCustom :: Text -> Text -> DecoderError
DecoderErrorDeserialiseFailure :: Text -> DeserialiseFailure -> DecoderError
DecoderErrorEmptyList :: Text -> DecoderError
DecoderErrorLeftover :: Text -> ByteString -> DecoderError

-- | A size mismatch <tt>DecoderErrorSizeMismatch label expectedSize
--   actualSize</tt>
DecoderErrorSizeMismatch :: Text -> Int -> Int -> DecoderError
DecoderErrorUnknownTag :: Text -> Word8 -> DecoderError
DecoderErrorVoid :: DecoderError

-- | Enforces that the input size is the same as the decoded one, failing
--   in case it's not
enforceSize :: Text -> Int -> Decoder s ()

-- | Compare two sizes, failing if they are not equal
matchSize :: Text -> Int -> Int -> Decoder s ()
decodeMaybe :: Decoder s a -> Decoder s (Maybe a)

-- | <i>Deprecated: In favor of <a>decodeMaybe</a></i>
fromCBORMaybe :: Decoder s a -> Decoder s (Maybe a)
decodeNullMaybe :: Decoder s a -> Decoder s (Maybe a)
decodeSeq :: Decoder s a -> Decoder s (Seq a)

-- | <tt><a>Decoder</a></tt> for list.
decodeListWith :: Decoder s a -> Decoder s [a]

-- | Checks canonicity by comparing the new key being decoded with the
--   previous one, to enfore these are sorted the correct way. See:
--   <a>https://tools.ietf.org/html/rfc7049#section-3.9</a> "[..]The keys
--   in every map must be sorted lowest value to highest.[...]"
decodeMapSkel :: (Ord k, FromCBOR k, FromCBOR v) => ([(k, v)] -> m) -> Decoder s m
decodeCollection :: Decoder s (Maybe Int) -> Decoder s a -> Decoder s [a]
decodeCollectionWithLen :: Decoder s (Maybe Int) -> Decoder s v -> Decoder s (Int, [v])

-- | Convert a <a>Buildable</a> error message into a <a>MonadFail</a>
--   failure.
cborError :: (MonadFail m, Buildable e) => e -> m a

-- | Convert an <a>Either</a>-encoded failure to a <a>MonadFail</a> failure
--   using the <a>Buildable</a> insatance
toCborError :: (MonadFail m, Buildable e) => Either e a -> m a

-- | Serialize a Haskell value with a <a>ToCBOR</a> instance to an external
--   binary representation.
--   
--   The output is represented as a lazy <tt>LByteString</tt> and is
--   constructed incrementally.
serialize :: ToCBOR a => a -> ByteString

-- | Serialize a Haskell value to an external binary representation.
--   
--   The output is represented as a strict <tt>ByteString</tt>.
serialize' :: ToCBOR a => a -> ByteString

-- | Serialize into a Builder. Useful if you want to throw other
--   ByteStrings around it.
serializeBuilder :: ToCBOR a => a -> Builder

-- | Serialize a Haskell value to an external binary representation using
--   the provided CBOR <a>Encoding</a>
--   
--   The output is represented as an <tt>LByteString</tt> and is
--   constructed incrementally.

-- | <i>Deprecated: Use <a>serialize</a> instead, since <a>Encoding</a> has
--   <a>ToCBOR</a> instance</i>
serializeEncoding :: Encoding -> ByteString

-- | A strict version of <a>serializeEncoding</a>

-- | <i>Deprecated: Use <a>serialize</a>` instead, since <a>Encoding</a>
--   has <a>ToCBOR</a> instance</i>
serializeEncoding' :: Encoding -> ByteString

-- | Encode and serialise the given <tt>a</tt> and sorround it with the
--   semantic tag 24 In CBOR diagnostic notation: &gt;&gt;&gt;
--   24(h<tt>DEADBEEF</tt>)
encodeNestedCbor :: ToCBOR a => a -> Encoding

-- | Like <a>encodeNestedCbor</a>, but assumes nothing about the shape of
--   input object, so that it must be passed as a binary
--   <tt>ByteString</tt> blob. It's the caller responsibility to ensure the
--   input <tt>ByteString</tt> correspond indeed to valid,
--   previously-serialised CBOR data.
encodeNestedCborBytes :: ByteString -> Encoding
nestedCborSizeExpr :: Size -> Size
nestedCborBytesSizeExpr :: Size -> Size
class Typeable a => ToCBOR a
toCBOR :: ToCBOR a => a -> Encoding
encodedSizeExpr :: ToCBOR a => (forall t. ToCBOR t => Proxy t -> Size) -> Proxy a -> Size
encodedListSizeExpr :: ToCBOR a => (forall t. ToCBOR t => Proxy t -> Size) -> Proxy [a] -> Size

-- | Compute encoded size of an integer
withWordSize :: (Integral s, Integral a) => s -> a
encodeMaybe :: (a -> Encoding) -> Maybe a -> Encoding

-- | <i>Deprecated: In favor of <a>encodeMaybe</a></i>
toCBORMaybe :: (a -> Encoding) -> Maybe a -> Encoding

-- | Alternative way to encode a Maybe type.
--   
--   <i>Note</i> - this is not the default method for encoding
--   <a>Maybe</a>, use <a>encodeMaybe</a> instead
encodeNullMaybe :: (a -> Encoding) -> Maybe a -> Encoding
encodeSeq :: (a -> Encoding) -> Seq a -> Encoding

-- | A range of values. Should satisfy the invariant <tt>forall x. lo x
--   &lt;= hi x</tt>.
data Range b
Range :: b -> b -> Range b
[lo] :: Range b -> b
[hi] :: Range b -> b

-- | Fully evaluate a size expression by applying the given function to any
--   suspended computations. <tt>szEval g</tt> effectively turns each
--   "thunk" of the form <tt>TodoF f x</tt> into <tt>g x</tt>, then
--   evaluates the result.
szEval :: (forall t. ToCBOR t => (Proxy t -> Size) -> Proxy t -> Range Natural) -> Size -> Range Natural

-- | Expressions describing the statically-computed size bounds on a type's
--   possible values.
type Size = Fix SizeF

-- | An individual labeled case.
data Case t
Case :: Text -> t -> Case t

-- | Discard the label on a case.
caseValue :: Case t -> t

-- | A type used to represent the length of a value in <a>Size</a>
--   computations.
newtype LengthOf xs
LengthOf :: xs -> LengthOf xs

-- | Override mechanisms to be used with <a>szWithCtx</a>.
data SizeOverride

-- | Replace with a fixed <tt>Size</tt>.
SizeConstant :: Size -> SizeOverride

-- | Recursively compute the size.
SizeExpression :: ((forall a. ToCBOR a => Proxy a -> Size) -> Size) -> SizeOverride

-- | Select only a specific case from a <tt>CasesF</tt>.
SelectCases :: [Text] -> SizeOverride

-- | Is this expression a thunk?
isTodo :: Size -> Bool

-- | Create a case expression from individual cases.
szCases :: [Case Size] -> Size

-- | Evaluate the expression lazily, by immediately creating a thunk that
--   will evaluate its contents lazily.
--   
--   <pre>
--   ghci&gt; putStrLn $ pretty $ szLazy (Proxy @TxAux)
--   (_ :: TxAux)
--   </pre>
szLazy :: ToCBOR a => Proxy a -> Size

-- | Evaluate an expression greedily. There may still be thunks in the
--   result, for types that did not provide a custom <a>encodedSizeExpr</a>
--   method in their <a>ToCBOR</a> instance.
--   
--   <pre>
--   ghci&gt; putStrLn $ pretty $ szGreedy (Proxy @TxAux)
--   (0 + { TxAux=(2 + ((0 + (((1 + (2 + ((_ :: LengthOf [TxIn]) * (2 + { TxInUtxo=(2 + ((1 + 34) + { minBound=1 maxBound=5 })) })))) + (2 + ((_ :: LengthOf [TxOut]) * (0 + { TxOut=(2 + ((0 + ((2 + ((2 + withWordSize((((1 + 30) + (_ :: Attributes AddrAttributes)) + 1))) + (((1 + 30) + (_ :: Attributes AddrAttributes)) + 1))) + { minBound=1 maxBound=5 })) + { minBound=1 maxBound=9 })) })))) + (_ :: Attributes ()))) + (_ :: Vector TxInWitness))) })
--   </pre>
szGreedy :: ToCBOR a => Proxy a -> Size

-- | Force any thunks in the given <tt>Size</tt> expression.
--   
--   <pre>
--   ghci&gt; putStrLn $ pretty $ szForce $ szLazy (Proxy @TxAux)
--   (0 + { TxAux=(2 + ((0 + (_ :: Tx)) + (_ :: Vector TxInWitness))) })
--   </pre>
szForce :: Size -> Size

-- | Greedily compute the size bounds for a type, using the given context
--   to override sizes for specific types.
szWithCtx :: ToCBOR a => Map TypeRep SizeOverride -> Proxy a -> Size

-- | Simplify the given <tt>Size</tt>, resulting in either the simplified
--   <tt>Size</tt> or, if it was fully simplified, an explicit upper and
--   lower bound.
szSimplify :: Size -> Either Size (Range Natural)

-- | Apply a monotonically increasing function to the expression. There are
--   three cases when applying <tt>f</tt> to a <tt>Size</tt> expression: *
--   When applied to a value <tt>x</tt>, compute <tt>f x</tt>. * When
--   applied to cases, apply to each case individually. * In all other
--   cases, create a deferred application of <tt>f</tt>.
apMono :: Text -> (Natural -> Natural) -> Size -> Size
szBounds :: ToCBOR a => a -> Either Size (Range Natural)

-- | Deserialize a Haskell value from the external binary representation
--   (which must have been made using <tt>serialize</tt> or related
--   function).
--   
--   <i>Throws</i>: <tt><a>DeserialiseFailure</a></tt> if the given
--   external representation is invalid or does not correspond to a value
--   of the expected type.
unsafeDeserialize :: FromCBOR a => ByteString -> a

-- | Strict variant of <tt>deserialize</tt>.
unsafeDeserialize' :: FromCBOR a => ByteString -> a

-- | Turn an <a>Encoding</a> into a strict <a>ByteString</a> in CBOR binary
--   format.
toStrictByteString :: Encoding -> ByteString

-- | Deserialize a Haskell value from the external binary representation,
--   failing if there are leftovers. In a nutshell, the <tt>full</tt> here
--   implies the contract of this function is that what you feed as input
--   needs to be consumed entirely.
decodeFull :: forall a. FromCBOR a => ByteString -> Either DecoderError a
decodeFull' :: forall a. FromCBOR a => ByteString -> Either DecoderError a
decodeFullDecoder :: Text -> (forall s. Decoder s a) -> ByteString -> Either DecoderError a
decodeFullDecoder' :: Text -> (forall s. Decoder s a) -> ByteString -> Either DecoderError a

-- | Remove the the semantic tag 24 from the enclosed CBOR data item,
--   decoding back the inner <tt>ByteString</tt> as a proper Haskell type.
--   Consume its input in full.
decodeNestedCbor :: FromCBOR a => Decoder s a

-- | Like <tt>decodeKnownCborDataItem</tt>, but assumes nothing about the
--   Haskell type we want to deserialise back, therefore it yields the
--   <tt>ByteString</tt> Tag 24 surrounded (stripping such tag away).
--   
--   In CBOR notation, if the data was serialised as:
--   
--   <pre>
--   &gt;&gt;&gt; 24(h'DEADBEEF')
--   </pre>
--   
--   then <a>decodeNestedCborBytes</a> yields the inner <tt>DEADBEEF</tt>,
--   unchanged.
decodeNestedCborBytes :: Decoder s ByteString
